From b2449d5fb7c4add53464c3dc2b458e6094745fca Mon Sep 17 00:00:00 2001
From: Wada Kotaro <Wada_Kotaro@stu.kobe-u.ac.jp>
Date: Sun, 12 Mar 2023 01:53:18 +0900
Subject: [PATCH] Pose-graph optimization using Proximity-Point-Pair matching

---
 g2o/EXTERNAL/freeglut/CMakeLists.txt         |   2 +-
 g2o/core/sparse_optimizer.cpp                |  16 +-
 g2o/solvers/eigen/CMakeLists.txt             |   2 +-
 g2o/stuff/opengl_primitives.cpp              |   8 +
 g2o/stuff/opengl_primitives.h                |   5 +
 g2o/types/slam2d/CMakeLists.txt              |  37 +--
 g2o/types/slam2d/cache_prox.cpp              |  39 +++
 g2o/types/slam2d/cache_prox.h                |  42 ++++
 g2o/types/slam2d/edge_prox.cpp               | 248 +++++++++++++++++++
 g2o/types/slam2d/edge_prox.h                 | 117 +++++++++
 g2o/types/slam2d/edge_se2.cpp                |  24 +-
 g2o/types/slam2d/edge_se2.h                  |   2 +
 g2o/types/slam2d/edge_switch_prox.cpp        | 199 +++++++++++++++
 g2o/types/slam2d/edge_switch_prox.h          | 104 ++++++++
 g2o/types/slam2d/edge_switch_se2.cpp         | 228 +++++++++++++++++
 g2o/types/slam2d/edge_switch_se2.h           | 136 ++++++++++
 g2o/types/slam2d/parameter_switch_weight.cpp |  53 ++++
 g2o/types/slam2d/parameter_switch_weight.h   |  59 +++++
 g2o/types/slam2d/types_slam2d.cpp            |  15 ++
 g2o/types/slam2d/types_slam2d.h              |   7 +
 g2o/types/slam2d/vertex_prox.cpp             | 163 ++++++++++++
 g2o/types/slam2d/vertex_prox.h               |  91 +++++++
 g2o/types/slam2d/vertex_se2.h                |   9 +-
 g2o/types/slam2d/vertex_switch.cpp           |  33 +++
 g2o/types/slam2d/vertex_switch.h             |  60 +++++
 25 files changed, 1660 insertions(+), 39 deletions(-)
 create mode 100644 g2o/types/slam2d/cache_prox.cpp
 create mode 100644 g2o/types/slam2d/cache_prox.h
 create mode 100644 g2o/types/slam2d/edge_prox.cpp
 create mode 100644 g2o/types/slam2d/edge_prox.h
 create mode 100644 g2o/types/slam2d/edge_switch_prox.cpp
 create mode 100644 g2o/types/slam2d/edge_switch_prox.h
 create mode 100644 g2o/types/slam2d/edge_switch_se2.cpp
 create mode 100644 g2o/types/slam2d/edge_switch_se2.h
 create mode 100644 g2o/types/slam2d/parameter_switch_weight.cpp
 create mode 100644 g2o/types/slam2d/parameter_switch_weight.h
 create mode 100644 g2o/types/slam2d/vertex_prox.cpp
 create mode 100644 g2o/types/slam2d/vertex_prox.h
 create mode 100644 g2o/types/slam2d/vertex_switch.cpp
 create mode 100644 g2o/types/slam2d/vertex_switch.h

diff --git a/g2o/EXTERNAL/freeglut/CMakeLists.txt b/g2o/EXTERNAL/freeglut/CMakeLists.txt
index 75c7a9d9..f831bf76 100644
--- a/g2o/EXTERNAL/freeglut/CMakeLists.txt
+++ b/g2o/EXTERNAL/freeglut/CMakeLists.txt
@@ -7,7 +7,7 @@ add_library(freeglut_minimal ${G2O_LIB_TYPE}
 target_link_libraries(freeglut_minimal PUBLIC ${G2O_OPENGL_TARGET})
 target_include_directories(freeglut_minimal PUBLIC
   "$<BUILD_INTERFACE:${g2o_SOURCE_DIR};${PROJECT_BINARY_DIR}>"
-  $<INSTALL_INTERFACE:include/g2o/freeglut_minimal>
+  $<INSTALL_INTERFACE:include/g2o/EXTERNAL/freeglut>
 )
 
 set_target_properties(freeglut_minimal PROPERTIES OUTPUT_NAME ${LIB_PREFIX}ext_freeglut_minimal)
diff --git a/g2o/core/sparse_optimizer.cpp b/g2o/core/sparse_optimizer.cpp
index 901de809..91b226c6 100644
--- a/g2o/core/sparse_optimizer.cpp
+++ b/g2o/core/sparse_optimizer.cpp
@@ -379,6 +379,7 @@ void SparseOptimizer::computeInitialGuess(
 }
 
 int SparseOptimizer::optimize(int iterations, bool online) {
+  int itr = (iterations == 0 ? INT_MAX : iterations);
   if (_ivMap.size() == 0) {
     cerr << __PRETTY_FUNCTION__
          << ": 0 vertices to optimize, maybe forgot to call "
@@ -398,13 +399,15 @@ int SparseOptimizer::optimize(int iterations, bool online) {
   }
 
   _batchStatistics.clear();
-  if (_computeBatchStatistics) _batchStatistics.resize(iterations);
+  if (_computeBatchStatistics && iterations) _batchStatistics.resize(iterations);
+
+  number_t chi2 = DBL_MAX;
 
   OptimizationAlgorithm::SolverResult result = OptimizationAlgorithm::OK;
-  for (int i = 0; i < iterations && !terminate() && ok; i++) {
+  for (int i = 0; i < itr && !terminate() && ok; i++) {
     preIteration(i);
 
-    if (_computeBatchStatistics) {
+    if (_computeBatchStatistics && iterations) {
       G2OBatchStatistics& cstat = _batchStatistics[i];
       G2OBatchStatistics::setGlobalStats(&cstat);
       cstat.iteration = i;
@@ -417,7 +420,7 @@ int SparseOptimizer::optimize(int iterations, bool online) {
     ok = (result == OptimizationAlgorithm::OK);
 
     bool errorComputed = false;
-    if (_computeBatchStatistics) {
+    if (_computeBatchStatistics && iterations) {
       computeActiveErrors();
       errorComputed = true;
       _batchStatistics[i].chi2 = activeRobustChi2();
@@ -436,6 +439,11 @@ int SparseOptimizer::optimize(int iterations, bool online) {
     }
     ++cjIterations;
     postIteration(i);
+
+    number_t _chi2 = activeRobustChi2();
+    if (!iterations && fabs(chi2 - _chi2) < 1.e-6)
+        break;
+    chi2 = _chi2;
   }
   if (result == OptimizationAlgorithm::Fail) {
     return 0;
diff --git a/g2o/solvers/eigen/CMakeLists.txt b/g2o/solvers/eigen/CMakeLists.txt
index 8dae9fda..6b723ce5 100644
--- a/g2o/solvers/eigen/CMakeLists.txt
+++ b/g2o/solvers/eigen/CMakeLists.txt
@@ -9,7 +9,7 @@ endif()
 target_link_libraries(solver_eigen core)
 
 target_include_directories(solver_eigen PUBLIC
-  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>
+  "$<BUILD_INTERFACE:${g2o_SOURCE_DIR};${PROJECT_BINARY_DIR}>"
   $<INSTALL_INTERFACE:include/g2o/solvers/eigen>
 )
 
diff --git a/g2o/stuff/opengl_primitives.cpp b/g2o/stuff/opengl_primitives.cpp
index 33be81e5..5bd69cfe 100644
--- a/g2o/stuff/opengl_primitives.cpp
+++ b/g2o/stuff/opengl_primitives.cpp
@@ -305,5 +305,13 @@ void drawPoint(float pointSize) {
   glVertex3f(0, 0, 0);
   glEnd();
 }
+
+void drawLine(float lineLength, float  lineWidth) {
+    glLineWidth(lineWidth);
+    glBegin(GL_LINES);
+    glVertex3f(0.f, 0.f, 0.f);
+    glVertex3f(lineLength, 0.f, 0.f);
+    glEnd();
+}
 }  // namespace opengl
 }  // namespace g2o
diff --git a/g2o/stuff/opengl_primitives.h b/g2o/stuff/opengl_primitives.h
index f3aade98..00b123ea 100644
--- a/g2o/stuff/opengl_primitives.h
+++ b/g2o/stuff/opengl_primitives.h
@@ -139,6 +139,11 @@ void G2O_OPENGL_API drawArrow2D(float len, float head_width, float head_len);
  */
 void G2O_OPENGL_API drawPoint(float pointSize);
 
+/**
+ * draw a line along the x axis
+ */
+void G2O_OPENGL_API drawLine(float lineLength, float  lineWidth);
+
 // @}
 
 #define POSE_VERTEX_COLOR 0.5f, 0.5f, 0.8f
diff --git a/g2o/types/slam2d/CMakeLists.txt b/g2o/types/slam2d/CMakeLists.txt
index 067cf139..2b2b7ce2 100644
--- a/g2o/types/slam2d/CMakeLists.txt
+++ b/g2o/types/slam2d/CMakeLists.txt
@@ -1,19 +1,28 @@
 add_library(types_slam2d ${G2O_LIB_TYPE}
+  types_slam2d.cpp			    types_slam2d.h
   se2.h
-  edge_se2_pointxy_bearing.h  edge_se2_prior.h
-  edge_se2.cpp                  edge_se2_pointxy_calib.cpp  types_slam2d.cpp
-  edge_se2.h                    edge_se2_pointxy_calib.h    vertex_point_xy.cpp
-  edge_se2_pointxy.cpp        vertex_point_xy.h
-  edge_se2_pointxy.h          vertex_se2.cpp
-  edge_se2_pointxy_bearing.cpp  edge_se2_prior.cpp          vertex_se2.h
-  parameter_se2_offset.cpp     parameter_se2_offset.h
-  edge_se2_offset.cpp          edge_se2_offset.h
-  edge_se2_pointxy_offset.cpp  edge_se2_pointxy_offset.h
-  edge_se2_xyprior.cpp edge_se2_xyprior.h
-  edge_pointxy.cpp             edge_pointxy.h
-  edge_se2_twopointsxy.cpp	edge_se2_twopointsxy.h
-  edge_se2_lotsofxy.cpp		edge_se2_lotsofxy.h
-  edge_xy_prior.cpp		edge_xy_prior.h
+  cache_prox.cpp				cache_prox.h		#added by wada
+  edge_se2.cpp					edge_se2.h
+  edge_se2_pointxy_bearing.cpp	edge_se2_pointxy_bearing.h
+  edge_se2_pointxy_calib.cpp	edge_se2_pointxy_calib.h
+  edge_se2_pointxy.cpp			edge_se2_pointxy.h
+  edge_se2_prior.cpp			edge_se2_prior.h
+  edge_se2_offset.cpp			edge_se2_offset.h
+  edge_se2_pointxy_offset.cpp	edge_se2_pointxy_offset.h
+  edge_se2_xyprior.cpp			edge_se2_xyprior.h
+  edge_pointxy.cpp				edge_pointxy.h
+  edge_se2_twopointsxy.cpp		edge_se2_twopointsxy.h
+  edge_se2_lotsofxy.cpp			edge_se2_lotsofxy.h
+  edge_xy_prior.cpp				edge_xy_prior.h
+  edge_prox.cpp					edge_prox.h				#added by wada
+  edge_switch_se2.cpp			edge_switch_se2.h		#added by wada
+  edge_switch_prox.cpp			edge_switch_prox.h		#added by wada
+  vertex_se2.cpp				vertex_se2.h
+  vertex_point_xy.cpp			vertex_point_xy.h
+  vertex_switch.cpp				vertex_switch.h			#added by wada
+  vertex_prox.cpp				vertex_prox.h			#added by wada
+  parameter_se2_offset.cpp		parameter_se2_offset.h
+  parameter_switch_weight.cpp	parameter_switch_weight.h	#added by wada
   g2o_types_slam2d_api.h
 )
 
diff --git a/g2o/types/slam2d/cache_prox.cpp b/g2o/types/slam2d/cache_prox.cpp
new file mode 100644
index 00000000..8c08b02e
--- /dev/null
+++ b/g2o/types/slam2d/cache_prox.cpp
@@ -0,0 +1,39 @@
+// This library was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#include "cache_prox.h"
+#include <iostream>
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+
+CacheProximity::CacheProximity() : Cache(){}
+
+bool CacheProximity::resolveDependencies() {
+    return true;
+}
+
+void CacheProximity::updateImpl() {
+  const VertexProx* v = static_cast<const VertexProx*>(vertex());
+  Eigen::Rotation2Dd dR = Eigen::Rotation2Dd(v->estimate().rotation().angle() + M_PI_2);
+  int n = v->numProx();
+  _locProxPoints.resize(n);
+  _locNormalVecs.resize(n);
+  _absProxPoints.resize(n);
+  _absNormalVecs.resize(n);
+  _diffProxPoints.resize(n);
+  _diffNormalVecs.resize(n);
+  for (int i = 0; i < n; i++) {
+      _locProxPoints[i] = v->proximity(i);
+      _locNormalVecs[i] = r(i) / r(i).norm();
+      _absProxPoints[i] = v->estimate() * r(i);
+      _absNormalVecs[i] = v->estimate().rotation() * u(i);
+      _diffProxPoints[i] = dR * r(i);
+      _diffNormalVecs[i] = dR * u(i);
+  }
+}
+
+}
diff --git a/g2o/types/slam2d/cache_prox.h b/g2o/types/slam2d/cache_prox.h
new file mode 100644
index 00000000..c5cdfde9
--- /dev/null
+++ b/g2o/types/slam2d/cache_prox.h
@@ -0,0 +1,42 @@
+// This library was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#ifndef G2O_PARAMETER_PROXIMITY_H_
+#define G2O_PARAMETER_PROXIMITY_H_
+
+#include <cmath>
+#include <vector>
+
+#include "g2o/core/cache.h"
+#include "g2o_types_slam2d_api.h"
+#include "vertex_prox.h"
+
+namespace g2o {
+
+class G2O_TYPES_SLAM2D_API CacheProximity : public Cache {
+ public:
+  EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
+  CacheProximity();
+  virtual void updateImpl();
+
+  inline const int& numProx() const { return _locProxPoints.size(); }
+  inline const Vector2& r(int i) const { return _locProxPoints[i]; }
+  inline const Vector2& u(int i) const { return _locNormalVecs[i]; }
+  inline const Vector2& q(int i) const { return _absProxPoints[i]; }
+  inline const Vector2& e(int i) const { return _absNormalVecs[i]; }
+  inline const Vector2& dq(int i) const { return _diffProxPoints[i]; }
+  inline const Vector2& de(int i) const { return _diffNormalVecs[i]; }
+
+ protected:
+     std::vector<Vector2> _locProxPoints;
+     std::vector<Vector2> _absProxPoints;
+     std::vector<Vector2> _diffProxPoints;
+     std::vector<Vector2> _locNormalVecs;
+     std::vector<Vector2> _absNormalVecs;
+     std::vector<Vector2> _diffNormalVecs;
+
+ protected:
+  virtual bool resolveDependencies();
+};
+
+}
+#endif
diff --git a/g2o/types/slam2d/edge_prox.cpp b/g2o/types/slam2d/edge_prox.cpp
new file mode 100644
index 00000000..70014b09
--- /dev/null
+++ b/g2o/types/slam2d/edge_prox.cpp
@@ -0,0 +1,248 @@
+// This library was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#include "edge_prox.h"
+#include <iostream>
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+  using namespace std;
+
+
+  EdgeProx::EdgeProx()
+      : BaseBinaryEdge<2, array<int, 2>, VertexProx, VertexProx>() {
+      information().setZero();
+      _cacheFrom = 0;
+      _cacheTo = 0;
+  }
+
+  bool EdgeProx::resolveCaches() {
+      ParameterVector pv(0);
+      resolveCache(_cacheFrom, (OptimizableGraph::Vertex*)_vertices[0],
+          "CACHE_PROX", pv);
+      resolveCache(_cacheTo, (OptimizableGraph::Vertex*)_vertices[1],
+          "CACHE_PROX", pv);
+      return (_cacheFrom && _cacheTo);
+  }
+
+  bool EdgeProx::read(std::istream& is) {
+    setMeasurementData(0);
+    if (is.bad()) return false;
+    is >> _measurement[0] >> _measurement[1];
+    double info;
+    is >> info;
+    information().setZero();
+    information()(0, 0) = info;
+    information()(1, 1) = info;
+    if (is.bad()) return false;
+    return true;
+  }
+
+  bool EdgeProx::write(std::ostream& os) const {
+      os << _measurement[0] << " " << _measurement[1] << " " << information()(0, 0) << " ";
+      return true;
+  }
+
+  void EdgeProx::computeError() {
+      _error.setZero();
+      const int fi = fp(), ti = tp();
+      _error(0, 0) = fc()->e(fi).dot(tc()->q(ti) - fc()->q(fi));
+      _error(1, 0) = tc()->e(ti).dot(fc()->q(fi) - tc()->q(ti));
+  }
+
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+  void EdgeProx::linearizeOplus() {
+      _jacobianOplusXi.setZero();
+      _jacobianOplusXj.setZero();
+      const SE2 vi = dynamic_cast<VertexProx*>(_vertices[0])->estimate();
+      const SE2 vj = dynamic_cast<VertexProx*>(_vertices[1])->estimate();
+      const Matrix2 Ri = vi.rotation().toRotationMatrix(),
+          Rj = vj.rotation().toRotationMatrix();
+      const int fi = fp(), ti = tp();
+      _jacobianOplusXi.block<1, 2>(0, 0) = -fc()->u(fi);
+      _jacobianOplusXi(0, 2) = fc()->de(fi).dot(tc()->q(ti) - fc()->q(fi)) - fc()->e(fi).dot(fc()->dq(fi));
+      _jacobianOplusXi.block<1, 2>(1, 0) = Ri.transpose() * tc()->e(ti);
+      _jacobianOplusXi(1, 2) = tc()->e(ti).dot(fc()->dq(fi));
+      _jacobianOplusXj.block<1, 2>(0, 0) = Rj.transpose() * fc()->e(fi);
+      _jacobianOplusXj(0, 2) = fc()->e(fi).dot(tc()->dq(ti));
+      _jacobianOplusXj.block<1, 2>(1, 0) = -tc()->u(ti);
+      _jacobianOplusXj(1, 2) = tc()->de(ti).dot(fc()->q(fi) - tc()->q(ti)) - tc()->e(ti).dot(tc()->dq(ti));
+  }
+#endif
+
+  bool EdgeProx::setMeasurementFromState(){
+      //VertexSE2Proximity* from_node = static_cast<VertexSE2Proximity*>(_vertices[0]);
+      //VertexSE2Proximity* to_node = static_cast<VertexSE2Proximity*>(_vertices[1]);
+      //_measurement = from_node->estimate().inverse() * to_node->estimate();
+    return true;
+  }
+
+
+  void EdgeProx::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* /*to_*/)
+  {
+    //VertexSE2Proximity* from_node = dynamic_cast<VertexSE2Proximity*>(_vertices[0]);
+    //VertexSE2Proximity* to_node = dynamic_cast<VertexSE2Proximity*>(_vertices[1]);
+    //if (from.count(from_node) > 0)
+    //    to_node->setEstimate(from_node->estimate() * _measurement);
+    //else
+    //    from_node->setEstimate(to_node->estimate() * _measurement.inverse());
+  }
+
+  bool EdgeMEstProx::read(std::istream& is) {
+      setMeasurementData(0);
+      if (is.bad()) return false;
+      double robustKernelDelta;
+      is >> _strRobustKernel >> robustKernelDelta;
+      is >> _measurement[0] >> _measurement[1];
+      double info;
+      is >> info;
+      information().setZero();
+      information()(0, 0) = info;
+      information()(1, 1) = info;
+      if (is.bad()) return false;
+      setRobustKernel(RobustKernelFactory::instance()->creator(_strRobustKernel)->construct());
+      robustKernel()->setDelta(robustKernelDelta);
+      return true;
+  }
+
+  bool EdgeMEstProx::write(std::ostream& os) const {
+      vector<string> strRobustKernels;
+      RobustKernelFactory::instance()->fillKnownKernels(strRobustKernels);
+      os << _strRobustKernel << " " << robustKernel()->delta() << " "
+          << _measurement[0] << " " << _measurement[1] << " " << information()(0, 0) << " ";
+      return true;
+  }
+
+#ifdef G2O_HAVE_OPENGL
+  EdgeProxDrawAction::EdgeProxDrawAction()
+      : DrawAction(typeid(EdgeProx).name()), _triangleY(nullptr), _triangleZ(nullptr) {}
+
+  bool EdgeProxDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_) {
+      if (!DrawAction::refreshPropertyPtrs(params_))
+          return false;
+      if (_previousParams) {
+          _triangleY = _previousParams->makeProperty<FloatProperty>(_typeName + "::N_Edge_Width", 3.0f);
+          _triangleZ = _previousParams->makeProperty<FloatProperty>(_typeName + "::P_Edge_Width", 2.0f);
+      }
+      else {
+          _triangleY = 0;
+          _triangleZ = 0;
+      }
+      return true;
+  }
+
+  HyperGraphElementAction* EdgeProxDrawAction::operator()(HyperGraph::HyperGraphElement* element,
+      HyperGraphElementAction::Parameters* params_) {
+      if (typeid(*element).name() != _typeName)
+          return nullptr;
+
+      refreshPropertyPtrs(params_);
+      if (!_previousParams)
+          return this;
+
+      if (_show && !_show->value())
+          return this;
+
+      EdgeProx* e = static_cast<EdgeProx*>(element);
+      VertexProx* from = static_cast<VertexProx*>(e->vertex(0));
+      VertexProx* to = static_cast<VertexProx*>(e->vertex(1));
+      if (!from && !to)
+          return this;
+      SE2 fromTransform;
+      SE2 toTransform;
+      Vector2 fromProximity;
+      Vector2 toProximity;
+      glPushAttrib(GL_ENABLE_BIT | GL_LIGHTING | GL_COLOR);
+      glDisable(GL_LIGHTING);
+      fromTransform = from->estimate();
+      toTransform = to->estimate();
+      fromProximity = e->fc()->q(e->fp());
+      toProximity = e->tc()->q(e->tp());
+      if (_triangleY->value() != 0) {
+          glLineWidth((float)_triangleY->value());
+          glColor3f(POSE_EDGE_COLOR);
+          glBegin(GL_LINES);
+          glVertex3f((float)fromTransform.translation().x(), (float)fromTransform.translation().y(), 0.f);
+          glVertex3f((float)toTransform.translation().x(), (float)toTransform.translation().y(), 0.f);
+          glEnd();
+      }
+      if (_triangleZ->value() != 0) {
+          glLineWidth((float)_triangleZ->value());
+          glColor3f(LANDMARK_EDGE_COLOR);
+          glBegin(GL_LINES);
+          glVertex3f((float)fromProximity.x(), (float)fromProximity.y(), 0.f);
+          glVertex3f((float)toProximity.x(), (float)toProximity.y(), 0.f);
+          glEnd();
+      }
+      glPopAttrib();
+      return this;
+  }
+
+  EdgeMEstProxDrawAction::EdgeMEstProxDrawAction()
+      : DrawAction(typeid(EdgeMEstProx).name()), _triangleY(nullptr), _triangleZ(nullptr) {}
+
+  bool EdgeMEstProxDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_) {
+      if (!DrawAction::refreshPropertyPtrs(params_))
+          return false;
+      if (_previousParams) {
+          _triangleY = _previousParams->makeProperty<FloatProperty>(_typeName + "::N_Edge_Width", 3.0f);
+          _triangleZ = _previousParams->makeProperty<FloatProperty>(_typeName + "::P_Edge_Width", 2.0f);
+      }
+      else {
+          _triangleY = 0;
+          _triangleZ = 0;
+      }
+      return true;
+  }
+
+  HyperGraphElementAction* EdgeMEstProxDrawAction::operator()(HyperGraph::HyperGraphElement* element,
+      HyperGraphElementAction::Parameters* params_) {
+      if (typeid(*element).name() != _typeName)
+          return nullptr;
+
+      refreshPropertyPtrs(params_);
+      if (!_previousParams)
+          return this;
+
+      if (_show && !_show->value())
+          return this;
+
+      EdgeMEstProx* e = static_cast<EdgeMEstProx*>(element);
+      VertexProx* from = static_cast<VertexProx*>(e->vertex(0));
+      VertexProx* to = static_cast<VertexProx*>(e->vertex(1));
+      if (!from && !to)
+          return this;
+      SE2 fromTransform;
+      SE2 toTransform;
+      Vector2 fromProximity;
+      Vector2 toProximity;
+      glPushAttrib(GL_ENABLE_BIT | GL_LIGHTING | GL_COLOR);
+      glDisable(GL_LIGHTING);
+      fromTransform = from->estimate();
+      toTransform = to->estimate();
+      fromProximity = e->fc()->q(e->fp());
+      toProximity = e->tc()->q(e->tp());
+      if (_triangleY->value() != 0) {
+          glLineWidth((float)_triangleY->value());
+          glColor3f(POSE_EDGE_COLOR);
+          glBegin(GL_LINES);
+          glVertex3f((float)fromTransform.translation().x(), (float)fromTransform.translation().y(), 0.f);
+          glVertex3f((float)toTransform.translation().x(), (float)toTransform.translation().y(), 0.f);
+          glEnd();
+      }
+      if (_triangleZ->value() != 0) {
+          glLineWidth((float)_triangleZ->value());
+          glColor3f(LANDMARK_EDGE_COLOR);
+          glBegin(GL_LINES);
+          glVertex3f((float)fromProximity.x(), (float)fromProximity.y(), 0.f);
+          glVertex3f((float)toProximity.x(), (float)toProximity.y(), 0.f);
+          glEnd();
+      }
+      glPopAttrib();
+      return this;
+  }
+#endif
+}
diff --git a/g2o/types/slam2d/edge_prox.h b/g2o/types/slam2d/edge_prox.h
new file mode 100644
index 00000000..2f0dcfcd
--- /dev/null
+++ b/g2o/types/slam2d/edge_prox.h
@@ -0,0 +1,117 @@
+// This library was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#ifndef G2O_EDGE_SE2_PROXIMITY_H_
+#define G2O_EDGE_SE2_PROXIMITY_H_
+
+//#define NUMERIC_JACOBIAN_TWO_D_TYPES
+
+#include "g2o/core/base_binary_edge.h"
+#include "vertex_prox.h"
+#include "cache_prox.h"
+#include "g2o_types_slam2d_api.h"
+#include "g2o/core/robust_kernel_impl.h"
+#include "g2o/core/robust_kernel_factory.h"
+
+namespace g2o {
+
+class G2O_TYPES_SLAM2D_API EdgeProx : public BaseBinaryEdge < 2, std::array<int, 2>, VertexProx, VertexProx > {
+  public:
+      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+          EdgeProx();
+
+      virtual bool resolveCaches();
+
+      virtual bool read(std::istream& is);
+      virtual bool write(std::ostream& os) const;
+
+      void computeError();
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+      virtual void linearizeOplus();
+#endif
+
+      virtual void setMeasurement(const std::array<int, 2> m) {
+          for (int i = 0; i < 2; i++)
+              _measurement[i] = m[i];
+      }
+
+      virtual void setMeasurement(const int m[2]) {
+          for (int i = 0; i < 2; i++)
+              _measurement[i] = m[i];
+      }
+
+      virtual bool setMeasurementData(const int* d) {
+          for(int i = 0; i < 2; i++)
+              _measurement[i] = d[i];
+          return true;
+      }
+
+      virtual bool setMeasurementData(const int d) {
+          for (int i = 0; i < 2; i++)
+              _measurement[i] = d;
+          return true;
+      }
+
+      virtual bool getMeasurementData(int d[2]) const {
+          for (int i = 0; i < 2; i++)
+              d[i] = _measurement[i];
+          return true;
+      }
+
+      virtual int measurementDimension() const { return 3; }
+
+      virtual bool setMeasurementFromState();
+
+      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to) {
+          (void)to;
+          return (from.count(_vertices[0]) == 1 ? 1.0 : -1.0);
+      }
+
+      virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
+
+      const virtual inline int fp() const { return _measurement[0]; };
+      const virtual inline int tp() const { return _measurement[1]; };
+      const virtual inline CacheProximity* fc() const { return _cacheFrom; };
+      const virtual inline CacheProximity* tc() const { return _cacheTo; };
+
+protected:
+    CacheProximity* _cacheFrom, * _cacheTo;
+};
+
+class G2O_TYPES_SLAM2D_API EdgeMEstProx : public EdgeProx {
+public:
+    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+        EdgeMEstProx() : EdgeProx(), _strRobustKernel(){};
+
+    virtual void setStrRobustKernel(const std::string& strRobustKernel) { _strRobustKernel = strRobustKernel; };
+
+    virtual bool read(std::istream& is);
+    virtual bool write(std::ostream& os) const;
+
+protected:
+    std::string _strRobustKernel;
+};
+
+#ifdef G2O_HAVE_OPENGL
+  class G2O_TYPES_SLAM2D_API EdgeProxDrawAction : public DrawAction {
+  public:
+      EdgeProxDrawAction();
+      virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
+          HyperGraphElementAction::Parameters* params_);
+  protected:
+      virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
+      FloatProperty* _triangleY, * _triangleZ;
+  };
+
+  class G2O_TYPES_SLAM2D_API EdgeMEstProxDrawAction : public DrawAction {
+  public:
+      EdgeMEstProxDrawAction();
+      virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
+          HyperGraphElementAction::Parameters* params_);
+  protected:
+      virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
+      FloatProperty* _triangleY, * _triangleZ;
+  };
+#endif
+
+}
+#endif
diff --git a/g2o/types/slam2d/edge_se2.cpp b/g2o/types/slam2d/edge_se2.cpp
index 0a06459a..ec28dae9 100644
--- a/g2o/types/slam2d/edge_se2.cpp
+++ b/g2o/types/slam2d/edge_se2.cpp
@@ -63,23 +63,19 @@ void EdgeSE2::initialEstimate(const OptimizableGraph::VertexSet& from,
 void EdgeSE2::linearizeOplus() {
   const VertexSE2* vi = static_cast<const VertexSE2*>(_vertices[0]);
   const VertexSE2* vj = static_cast<const VertexSE2*>(_vertices[1]);
-  number_t thetai = vi->estimate().rotation().angle();
-
+  number_t thetai = vi->estimate().rotation().angle(), 
+      thetaj = vj->estimate().rotation().angle(), 
+      thetam = measurement().rotation().angle();
   Vector2 dt = vj->estimate().translation() - vi->estimate().translation();
-  number_t si = std::sin(thetai), ci = std::cos(thetai);
-
-  _jacobianOplusXi << -ci, -si, -si * dt.x() + ci * dt.y(), si, -ci,
-      -ci * dt.x() - si * dt.y(), 0, 0, -1;
 
-  _jacobianOplusXj << ci, si, 0, -si, ci, 0, 0, 0, 1;
+  _jacobianOplusXi.setZero();
+  _jacobianOplusXi.block<2, 2>(0, 0) = -Matrix2(Rotation2D(-thetam));
+  _jacobianOplusXi.block<2, 1>(0, 2) = Matrix2(Rotation2D(-thetai - thetam - M_PI_2)) * dt;
+  _jacobianOplusXi(2, 2) = -1.;
 
-  const SE2& rmean = _inverseMeasurement;
-  Matrix3 z;
-  z.block<2, 2>(0, 0) = rmean.rotation().toRotationMatrix();
-  z.col(2) << cst(0.), cst(0.), cst(1.);
-  z.row(2).head<2>() << cst(0.), cst(0.);
-  _jacobianOplusXi = z * _jacobianOplusXi;
-  _jacobianOplusXj = z * _jacobianOplusXj;
+  _jacobianOplusXj.setZero();
+  _jacobianOplusXj.block<2, 2>(0, 0) = Matrix2(Rotation2D(thetaj - thetai - thetam));
+  _jacobianOplusXj(2, 2) = 1.;
 }
 #endif
 
diff --git a/g2o/types/slam2d/edge_se2.h b/g2o/types/slam2d/edge_se2.h
index afdf8e4e..87456ed0 100644
--- a/g2o/types/slam2d/edge_se2.h
+++ b/g2o/types/slam2d/edge_se2.h
@@ -27,6 +27,8 @@
 #ifndef G2O_EDGE_SE2_H
 #define G2O_EDGE_SE2_H
 
+//#define NUMERIC_JACOBIAN_TWO_D_TYPES
+
 #include "g2o/config.h"
 #include "g2o/core/base_binary_edge.h"
 #include "g2o_types_slam2d_api.h"
diff --git a/g2o/types/slam2d/edge_switch_prox.cpp b/g2o/types/slam2d/edge_switch_prox.cpp
new file mode 100644
index 00000000..058ae9ca
--- /dev/null
+++ b/g2o/types/slam2d/edge_switch_prox.cpp
@@ -0,0 +1,199 @@
+// This class was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#include "edge_switch_prox.h"
+#include <iostream>
+#include <iomanip>
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+  using namespace std;
+
+
+  // point to camera projection, monocular
+  EdgeSwitchProx::EdgeSwitchProx()
+      : BaseTernaryEdge < 3, std::array<int, 2>, VertexProx, VertexProx, VertexSwitch >() {
+      _cacheFrom = 0;
+      _cacheTo = 0;
+    information().setZero();
+  }
+
+  bool EdgeSwitchProx::resolveCaches() {
+      ParameterVector pv(0);
+      resolveCache(_cacheFrom, (OptimizableGraph::Vertex*)_vertices[0],
+          "CACHE_PROX", pv);
+      resolveCache(_cacheTo, (OptimizableGraph::Vertex*)_vertices[1],
+          "CACHE_PROX", pv);
+      return (_cacheFrom && _cacheTo);
+  }
+
+  bool EdgeSwitchProx::read(std::istream& is) {
+    setMeasurementData(0);
+    if (is.bad()) return false;
+    information().setZero();
+
+    is >> _measurement[0] >> _measurement[1];
+    double info, sinfo;
+    is >> info >> sinfo;
+    information()(0, 0) = info;
+    information()(1, 1) = info;
+    information()(2, 2) = sinfo;
+    if (is.bad()) return false;
+    return true;
+  }
+
+  bool EdgeSwitchProx::write(std::ostream& os) const {
+      os << _measurement[0] << " " << _measurement[1] << " "
+          << information()(0, 0) << " " << information()(2, 2) << " ";
+      return true;
+  }
+
+  void EdgeSwitchProx::computeError() {
+      _error.setZero();
+      const number_t vk = dynamic_cast<VertexSwitch*>(_vertices[2])->estimate();
+      const int fi = fp(), ti = tp();
+      _error(0, 0) = vk * fc()->e(fi).dot(tc()->q(ti) - fc()->q(fi));
+      _error(1, 0) = vk * tc()->e(ti).dot(fc()->q(fi) - tc()->q(ti));
+      _error(2, 0) = cst(1.) - vk;
+  }
+
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+  void EdgeSwitchProx::linearizeOplus() {
+      _jacobianOplusXi.setZero();
+      _jacobianOplusXj.setZero();
+      _jacobianOplusXk.setZero();
+      const SE2 vi = dynamic_cast<VertexProx*>(_vertices[0])->estimate();
+      const SE2 vj = dynamic_cast<VertexProx*>(_vertices[1])->estimate();
+      const number_t vk = dynamic_cast<VertexSwitch*>(_vertices[2])->estimate();
+      const Matrix2 Ri = vi.rotation().toRotationMatrix(),
+          Rj = vj.rotation().toRotationMatrix();
+      const int fi = fp(), ti = tp();
+      _jacobianOplusXi.block<1, 2>(0, 0) = -vk * fc()->u(fi);
+      _jacobianOplusXi(0, 2) = vk * (fc()->de(fi).dot(tc()->q(ti) - fc()->q(fi)) - fc()->e(fi).dot(fc()->dq(fi)));
+      _jacobianOplusXi.block<1, 2>(1, 0) = vk * Ri.transpose() * tc()->e(ti);
+      _jacobianOplusXi(1, 2) = vk * tc()->e(ti).dot(fc()->dq(fi));
+      _jacobianOplusXj.block<1, 2>(0, 0) = vk * Rj.transpose() * fc()->e(fi);
+      _jacobianOplusXj(0, 2) = vk * fc()->e(fi).dot(tc()->dq(ti));
+      _jacobianOplusXj.block<1, 2>(1, 0) = -vk * tc()->u(ti);
+      _jacobianOplusXj(1, 2) = vk * (tc()->de(ti).dot(fc()->q(fi) - tc()->q(ti)) - tc()->e(ti).dot(tc()->dq(ti)));
+      _jacobianOplusXk.block<2, 1>(0, 0) << cst(fc()->e(fi).dot(tc()->q(ti) - fc()->q(fi))), cst(tc()->e(ti).dot(fc()->q(fi) - tc()->q(ti)));
+      _jacobianOplusXk(2, 0) = -cst(1.);  }
+#endif
+
+  bool EdgeSwitchProx::setMeasurementFromState(){
+      //VertexSE2Proximity* from_node = static_cast<VertexSE2Proximity*>(_vertices[0]);
+      //VertexSE2Proximity* to_node = static_cast<VertexSE2Proximity*>(_vertices[1]);
+      //_measurement = from_node->estimate().inverse() * to_node->estimate();
+    return true;
+  }
+
+
+  void EdgeSwitchProx::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* /*to_*/)
+  {
+    //VertexSE2Proximity* from_node = dynamic_cast<VertexSE2Proximity*>(_vertices[0]);
+    //VertexSE2Proximity* to_node = dynamic_cast<VertexSE2Proximity*>(_vertices[1]);
+    //if (from.count(from_node) > 0)
+    //    to_node->setEstimate(from_node->estimate() * _measurement);
+    //else
+    //    from_node->setEstimate(to_node->estimate() * _measurement.inverse());
+  }
+
+  // point to camera projection, monocular
+  EdgeSwitchProxSIP::EdgeSwitchProxSIP()
+      : EdgeSwitchProx() {
+      _ProxPairWeightInfo = 0;
+      resizeParameters(1);
+      installParameter(_ProxPairWeightInfo, 0);
+  }
+
+  bool EdgeSwitchProxSIP::read(std::istream& is) {
+      setMeasurementData(0);
+      if (is.bad()) return false;
+      information().setZero();
+      if (!setParameterId(0, 0))
+          return false;
+
+      is >> _measurement[0] >> _measurement[1];
+      double info;
+      is >> info;
+      information()(0, 0) = info;
+      information()(1, 1) = info;
+      information()(2, 2) = _ProxPairWeightInfo->Info();
+      if (is.bad()) return false;
+      return true;
+  }
+
+  bool EdgeSwitchProxSIP::write(std::ostream& os) const {
+      os << _measurement[0] << " " << _measurement[1] << " " << information()(0, 0) << " ";
+      return true;
+  }
+
+#ifdef G2O_HAVE_OPENGL
+  EdgeSwitchProxDrawAction::EdgeSwitchProxDrawAction()
+      : DrawAction(typeid(EdgeSwitchProx).name()), _triangleY(nullptr), _triangleZ(nullptr) {}
+
+  bool EdgeSwitchProxDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_) {
+      if (!DrawAction::refreshPropertyPtrs(params_))
+          return false;
+      if (_previousParams) {
+          _triangleY = _previousParams->makeProperty<FloatProperty>(_typeName + "::N_Edge_Width", 3.0f);
+          _triangleZ = _previousParams->makeProperty<FloatProperty>(_typeName + "::P_Edge_Width", 2.0f);
+      }
+      else {
+          _triangleY = 0;
+          _triangleZ = 0;
+      }
+      return true;
+  }
+
+  HyperGraphElementAction* EdgeSwitchProxDrawAction::operator()(HyperGraph::HyperGraphElement* element,
+      HyperGraphElementAction::Parameters* params_) {
+      if (typeid(*element).name() != _typeName)
+          return nullptr;
+
+      refreshPropertyPtrs(params_);
+      if (!_previousParams)
+          return this;
+
+      if (_show && !_show->value())
+          return this;
+
+      EdgeSwitchProx* e = static_cast<EdgeSwitchProx*>(element);
+      VertexProx* from = static_cast<VertexProx*>(e->vertex(0));
+      VertexProx* to = static_cast<VertexProx*>(e->vertex(1));
+      if (!from && !to)
+          return this;
+      SE2 fromTransform;
+      SE2 toTransform;
+      Vector2 fromProximity;
+      Vector2 toProximity;
+      glPushAttrib(GL_ENABLE_BIT | GL_LIGHTING | GL_COLOR);
+      glDisable(GL_LIGHTING);
+      fromTransform = from->estimate();
+      toTransform = to->estimate();
+      fromProximity = e->fc()->q(e->fp());
+      toProximity = e->tc()->q(e->tp());
+      if (_triangleY->value() != 0) {
+          glLineWidth((float)_triangleY->value());
+          glColor3f(POSE_EDGE_COLOR);
+          glBegin(GL_LINES);
+          glVertex3f((float)fromTransform.translation().x(), (float)fromTransform.translation().y(), 0.f);
+          glVertex3f((float)toTransform.translation().x(), (float)toTransform.translation().y(), 0.f);
+          glEnd();
+      }
+      if (_triangleZ->value() != 0) {
+          glLineWidth((float)_triangleZ->value());
+          glColor3f(LANDMARK_EDGE_COLOR);
+          glBegin(GL_LINES);
+          glVertex3f((float)fromProximity.x(), (float)fromProximity.y(), 0.f);
+          glVertex3f((float)toProximity.x(), (float)toProximity.y(), 0.f);
+          glEnd();
+      }
+      glPopAttrib();
+      return this;
+  }
+#endif
+}
diff --git a/g2o/types/slam2d/edge_switch_prox.h b/g2o/types/slam2d/edge_switch_prox.h
new file mode 100644
index 00000000..4a396017
--- /dev/null
+++ b/g2o/types/slam2d/edge_switch_prox.h
@@ -0,0 +1,104 @@
+// This class was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#ifndef G2O_EDGE_SWITCHING_PROX_H_
+#define G2O_EDGE_SWITCHING_PROX_H_
+
+//#define NUMERIC_JACOBIAN_TWO_D_TYPES
+
+#include "g2o/core/base_ternary_edge.h"
+#include "vertex_prox.h"
+#include "vertex_switch.h"
+#include "cache_prox.h"
+#include "parameter_switch_weight.h"
+#include "g2o_types_slam2d_api.h"
+
+namespace g2o {
+    class G2O_TYPES_SLAM2D_API EdgeSwitchProx : public BaseTernaryEdge < 3, std::array<int, 2>, VertexProx, VertexProx, VertexSwitch > {
+  public:
+      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+          EdgeSwitchProx();
+
+      virtual bool resolveCaches();
+
+      virtual bool read(std::istream& is);
+      virtual bool write(std::ostream& os) const;
+
+      void computeError();
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+      virtual void linearizeOplus();
+#endif
+
+      virtual void setMeasurement(const std::array<int, 2> m) {
+          for (int i = 0; i < 2; i++)
+              _measurement[i] = m[i];
+      }
+
+      virtual void setMeasurement(const int m[2]) {
+          for (int i = 0; i < 2; i++)
+              _measurement[i] = m[i];
+      }
+
+      virtual bool setMeasurementData(const int* d) {
+          for(int i = 0; i < 2; i++)
+              _measurement[i] = d[i];
+          return true;
+      }
+
+      virtual bool setMeasurementData(const int d) {
+          for (int i = 0; i < 2; i++)
+              _measurement[i] = d;
+          return true;
+      }
+
+      virtual bool getMeasurementData(int d[2]) const {
+          for (int i = 0; i < 2; i++)
+              d[i] = _measurement[i];
+          return true;
+      }
+
+      virtual int measurementDimension() const { return 3; }
+
+      virtual bool setMeasurementFromState();
+
+      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to) {
+          (void)to;
+          return (from.count(_vertices[0]) == 1 ? 1.0 : -1.0);
+      }
+
+      virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
+
+      const virtual inline int fp() const { return _measurement[0]; };
+      const virtual inline int tp() const { return _measurement[1]; };
+      const virtual inline CacheProximity* fc() const { return _cacheFrom; };
+      const virtual inline CacheProximity* tc() const { return _cacheTo; };
+
+  protected:
+      CacheProximity* _cacheFrom, * _cacheTo;
+  };
+
+    class G2O_TYPES_SLAM2D_API EdgeSwitchProxSIP : public EdgeSwitchProx {
+    public:
+        EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+            EdgeSwitchProxSIP();
+
+        virtual bool read(std::istream& is);
+        virtual bool write(std::ostream& os) const;
+
+    private:
+        ParameterSwitchWeight* _ProxPairWeightInfo;
+    };
+
+#ifdef G2O_HAVE_OPENGL
+  class G2O_TYPES_SLAM2D_API EdgeSwitchProxDrawAction : public DrawAction {
+  public:
+      EdgeSwitchProxDrawAction();
+      virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
+          HyperGraphElementAction::Parameters* params_);
+  protected:
+      virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
+      FloatProperty* _triangleY, * _triangleZ;
+  };
+#endif
+
+}
+#endif
diff --git a/g2o/types/slam2d/edge_switch_se2.cpp b/g2o/types/slam2d/edge_switch_se2.cpp
new file mode 100644
index 00000000..5f7a255b
--- /dev/null
+++ b/g2o/types/slam2d/edge_switch_se2.cpp
@@ -0,0 +1,228 @@
+// g2o - General Graph Optimization
+// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright
+//   notice, this list of conditions and the following disclaimer in the
+//   documentation and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "edge_switch_se2.h"
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+
+  EdgeSwitchSE2::EdgeSwitchSE2() :
+      BaseTernaryEdge<4, SE2, VertexSE2, VertexSE2, VertexSwitch>() {}
+
+  bool EdgeSwitchSE2::read(std::istream& is)
+  {
+    Vector3 p;
+    internal::readVector(is, p);
+    setMeasurement(SE2(p));
+    _inverseMeasurement = measurement().inverse();
+    information().setZero();
+    for (int i = 0; i < 3 && is.good(); ++i)
+        for (int j = i; j < 3 && is.good(); ++j) {
+            is >> information()(i, j);
+            if (i != j) information()(j, i) = information()(i, j);
+        }
+    is >> information()(3, 3);
+    return true;
+  }
+
+  bool EdgeSwitchSE2::write(std::ostream& os) const
+  {
+    internal::writeVector(os, measurement().toVector());
+    for (int i = 0; i < 3; ++i)
+        for (int j = i; j < 3; ++j)
+            os << information()(i, j) << " ";
+    os << information()(3, 3) << " ";
+    return true;
+  }
+
+  void EdgeSwitchSE2::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* /* to */)
+  {
+    VertexSE2* fromEdge = static_cast<VertexSE2*>(_vertices[0]);
+    VertexSE2* toEdge   = static_cast<VertexSE2*>(_vertices[1]);
+    if (from.count(fromEdge) > 0)
+      toEdge->setEstimate(fromEdge->estimate() * _measurement);
+    else
+      fromEdge->setEstimate(toEdge->estimate() * _inverseMeasurement);
+  }
+
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+  void EdgeSwitchSE2::linearizeOplus()
+  {
+      const VertexSE2* vi = static_cast<const VertexSE2*>(_vertices[0]);
+      const VertexSE2* vj = static_cast<const VertexSE2*>(_vertices[1]);
+      const VertexSwitch* s = static_cast<const VertexSwitch*>(_vertices[2]);
+      SE2 delta = _inverseMeasurement * (vi->estimate().inverse() * vj->estimate());
+      delta.setRotation(Rotation2D(normalize_theta(delta.rotation().angle())));
+
+      Vector2 dt = vj->estimate().translation() - vi->estimate().translation();
+      Matrix2 dR = vi->estimate().rotation().toRotationMatrix().transpose() * vj->estimate().rotation().toRotationMatrix();
+      const SE2& rmean = _inverseMeasurement;
+      Vector2 z = rmean.rotation().toRotationMatrix() * vi->estimate().rotation().toRotationMatrix().transpose() * dt;
+
+      _jacobianOplusXi.setZero();
+      _jacobianOplusXi.block<2, 2>(0, 0) = - s->estimate() * rmean.rotation().toRotationMatrix();
+      _jacobianOplusXi.col(2) = s->estimate() * Vector4{ z.y(), -z.x(), -1., 0. };
+      _jacobianOplusXj.setZero();
+      _jacobianOplusXj.block<2, 2>(0, 0) = s->estimate() * rmean.rotation().toRotationMatrix() * dR;
+      _jacobianOplusXj(2,2) = s->estimate();
+      _jacobianOplusXk << delta.toVector(), -cst(1.);
+  }
+#endif
+
+  EdgeSwitchSE2SIP::EdgeSwitchSE2SIP() : EdgeSwitchSE2()
+  {
+      _WeightInfo = 0;
+      resizeParameters(1);
+      installParameter(_WeightInfo, 0);
+  }
+
+  bool EdgeSwitchSE2SIP::read(std::istream& is)
+  {
+      Vector3 p;
+      internal::readVector(is, p);
+      setMeasurement(SE2(p));
+      _inverseMeasurement = measurement().inverse();
+      information().setZero();
+      for (int i = 0; i < 3 && is.good(); ++i)
+          for (int j = i; j < 3 && is.good(); ++j) {
+              is >> information()(i, j);
+              if (i != j) information()(j, i) = information()(i, j);
+          }
+      if (!setParameterId(0, 0))
+          return false;
+      resolveParameters();
+      information()(3, 3) = _WeightInfo->Info();
+      return true;
+  }
+
+  bool EdgeSwitchSE2SIP::write(std::ostream& os) const
+  {
+      internal::writeVector(os, measurement().toVector());
+      for (int i = 0; i < 3; ++i)
+          for (int j = i; j < 3; ++j)
+              os << information()(i, j);
+      return true;
+  }
+
+  EdgeSwitchSE2WriteGnuplotAction::EdgeSwitchSE2WriteGnuplotAction(): WriteGnuplotAction(typeid(EdgeSwitchSE2).name()){}
+
+  HyperGraphElementAction* EdgeSwitchSE2WriteGnuplotAction::operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* params_){
+    if (typeid(*element).name()!=_typeName)
+      return nullptr;
+    WriteGnuplotAction::Parameters* params=static_cast<WriteGnuplotAction::Parameters*>(params_);
+    if (!params->os){
+      std::cerr << __PRETTY_FUNCTION__ << ": warning, on valid os specified" << std::endl;
+      return nullptr;
+    }
+
+    EdgeSwitchSE2* e =  static_cast<EdgeSwitchSE2*>(element);
+    VertexSE2* fromEdge = static_cast<VertexSE2*>(e->vertex(0));
+    VertexSE2* toEdge   = static_cast<VertexSE2*>(e->vertex(1));
+    *(params->os) << fromEdge->estimate().translation().x() << " " << fromEdge->estimate().translation().y()
+      << " " << fromEdge->estimate().rotation().angle() << std::endl;
+    *(params->os) << toEdge->estimate().translation().x() << " " << toEdge->estimate().translation().y()
+      << " " << toEdge->estimate().rotation().angle() << std::endl;
+    *(params->os) << std::endl;
+    return this;
+  }
+
+#ifdef G2O_HAVE_OPENGL
+  EdgeSwitchSE2DrawAction::EdgeSwitchSE2DrawAction()
+      : DrawAction(typeid(EdgeSwitchSE2).name()), _triangleX(nullptr), _triangleY(nullptr) {}
+
+  bool EdgeSwitchSE2DrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_){
+    if (!DrawAction::refreshPropertyPtrs(params_))
+      return false;
+    if (_previousParams){
+      _triangleX = _previousParams->makeProperty<FloatProperty>(_typeName + "::GHOST_TRIANGLE_X", .2f);
+      _triangleY = _previousParams->makeProperty<FloatProperty>(_typeName + "::GHOST_TRIANGLE_Y", .05f);
+    } else {
+      _triangleX = 0;
+      _triangleY = 0;
+    }
+    return true;
+  }
+
+  HyperGraphElementAction* EdgeSwitchSE2DrawAction::operator()(HyperGraph::HyperGraphElement* element,
+               HyperGraphElementAction::Parameters* params_){
+    if (typeid(*element).name()!=_typeName)
+      return nullptr;
+
+    refreshPropertyPtrs(params_);
+    if (! _previousParams)
+      return this;
+
+    if (_show && !_show->value())
+      return this;
+
+    EdgeSwitchSE2* e =  static_cast<EdgeSwitchSE2*>(element);
+    VertexSE2* from = static_cast<VertexSE2*>(e->vertex(0));
+    VertexSE2* to   = static_cast<VertexSE2*>(e->vertex(1));
+    if (! from && ! to)
+      return this;
+    SE2 fromTransform;
+    SE2 toTransform;
+    glPushAttrib(GL_ENABLE_BIT | GL_LIGHTING | GL_COLOR);
+    glDisable(GL_LIGHTING);
+    if (! from) {
+      glColor3f(POSE_EDGE_GHOST_COLOR);
+      toTransform = to->estimate();
+      fromTransform = to->estimate()*e->measurement().inverse();
+      // DRAW THE FROM EDGE AS AN ARROW
+      glPushMatrix();
+      glTranslatef((float)fromTransform.translation().x(), (float)fromTransform.translation().y(),0.f);
+      glRotatef((float)RAD2DEG(fromTransform.rotation().angle()),0.f,0.f,1.f);
+      opengl::drawArrow2D((float)_triangleX->value(), (float)_triangleY->value(), (float)_triangleX->value()*.3f);
+      glPopMatrix();
+    } else if (! to){
+      glColor3f(POSE_EDGE_GHOST_COLOR);
+      fromTransform = from->estimate();
+      toTransform = from->estimate()*e->measurement();
+      // DRAW THE TO EDGE AS AN ARROW
+      glPushMatrix();
+      glTranslatef(toTransform.translation().x(),toTransform.translation().y(),0.f);
+      glRotatef((float)RAD2DEG(toTransform.rotation().angle()),0.f,0.f,1.f);
+      opengl::drawArrow2D((float)_triangleX->value(), (float)_triangleY->value(), (float)_triangleX->value()*.3f);
+      glPopMatrix();
+    } else {
+      glColor3f(POSE_EDGE_COLOR);
+      fromTransform = from->estimate();
+      toTransform = to->estimate();
+    }
+    glBegin(GL_LINES);
+    glVertex3f((float)fromTransform.translation().x(),(float)fromTransform.translation().y(),0.f);
+    glVertex3f((float)toTransform.translation().x(),(float)toTransform.translation().y(),0.f);
+    glEnd();
+    glPopAttrib();
+    return this;
+  }
+#endif
+
+} // end namespace
diff --git a/g2o/types/slam2d/edge_switch_se2.h b/g2o/types/slam2d/edge_switch_se2.h
new file mode 100644
index 00000000..4d0afffc
--- /dev/null
+++ b/g2o/types/slam2d/edge_switch_se2.h
@@ -0,0 +1,136 @@
+// g2o - General Graph Optimization
+// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright
+//   notice, this list of conditions and the following disclaimer in the
+//   documentation and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef G2O_EDGE_SWITCHING_SE2_H
+#define G2O_EDGE_SWITCHING_SE2_H
+
+//#define NUMERIC_JACOBIAN_TWO_D_TYPES
+
+#include "vertex_se2.h"
+#include "vertex_switch.h"
+#include "parameter_switch_weight.h"
+#include "g2o/config.h"
+#include "g2o/core/base_ternary_edge.h"
+#include "g2o_types_slam2d_api.h"
+
+namespace g2o {
+
+  /**
+   * \brief 2D edge between two Vertex2
+   */
+  class G2O_TYPES_SLAM2D_API EdgeSwitchSE2 : public BaseTernaryEdge<4, SE2, VertexSE2, VertexSE2, VertexSwitch>
+  {
+    public:
+      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+          EdgeSwitchSE2();
+
+      void computeError()
+      {
+        const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
+        const VertexSE2* v2 = static_cast<const VertexSE2*>(_vertices[1]);
+        const VertexSwitch* s = static_cast<const VertexSwitch*>(_vertices[2]);
+        SE2 delta = _inverseMeasurement * (v1->estimate().inverse()*v2->estimate());
+        delta.setRotation(Rotation2D(normalize_theta(delta.rotation().angle())));
+        _error.block<3,1>(0,0) = s->estimate() * delta.toVector();
+        _error(3, 0) = cst(1.) - s->estimate();
+      }
+      virtual bool read(std::istream& is);
+      virtual bool write(std::ostream& os) const;
+
+      virtual void setMeasurement(const SE2& m){
+        _measurement = m;
+        _inverseMeasurement = m.inverse();
+      }
+
+      virtual bool setMeasurementData(const number_t* d){
+        _measurement=SE2(d[0], d[1], d[2]);
+        _inverseMeasurement = _measurement.inverse();
+        return true;
+      }
+
+      virtual bool getMeasurementData(number_t* d) const {
+        Vector3 v=_measurement.toVector();
+        d[0] = v[0];
+        d[1] = v[1];
+        d[2] = v[2];
+        return true;
+      }
+
+      virtual int measurementDimension() const {return 3;}
+
+      virtual bool setMeasurementFromState() {
+        const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
+        const VertexSE2* v2 = static_cast<const VertexSE2*>(_vertices[1]);
+        _measurement = v1->estimate().inverse()*v2->estimate();
+        _inverseMeasurement = _measurement.inverse();
+        return true;
+      }
+
+
+      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& , OptimizableGraph::Vertex* ) { return 1.;}
+      virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+      virtual void linearizeOplus();
+#endif
+    protected:
+      SE2 _inverseMeasurement;
+  };
+
+  class G2O_TYPES_SLAM2D_API EdgeSwitchSE2SIP : public EdgeSwitchSE2
+  {
+  public:
+      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+          EdgeSwitchSE2SIP();
+
+      virtual bool read(std::istream& is);
+      virtual bool write(std::ostream& os) const;
+
+  private:
+      ParameterSwitchWeight* _WeightInfo;
+  };
+
+  class G2O_TYPES_SLAM2D_API EdgeSwitchSE2WriteGnuplotAction: public WriteGnuplotAction {
+  public:
+    EdgeSwitchSE2WriteGnuplotAction();
+    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
+            HyperGraphElementAction::Parameters* params_);
+  };
+
+#ifdef G2O_HAVE_OPENGL
+  class G2O_TYPES_SLAM2D_API EdgeSwitchSE2DrawAction: public DrawAction{
+  public:
+    EdgeSwitchSE2DrawAction();
+    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
+            HyperGraphElementAction::Parameters* params_);
+  protected:
+    virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
+    FloatProperty *_triangleX, *_triangleY;
+  };
+#endif
+
+} // end namespace
+
+#endif
diff --git a/g2o/types/slam2d/parameter_switch_weight.cpp b/g2o/types/slam2d/parameter_switch_weight.cpp
new file mode 100644
index 00000000..c8a8fb3d
--- /dev/null
+++ b/g2o/types/slam2d/parameter_switch_weight.cpp
@@ -0,0 +1,53 @@
+// g2o - General Graph Optimization
+// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright
+//   notice, this list of conditions and the following disclaimer in the
+//   documentation and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "parameter_switch_weight.h"
+
+#include "g2o/core/io_helper.h"
+#include "vertex_se2.h"
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#endif
+
+namespace g2o {
+
+	ParameterSwitchWeight::ParameterSwitchWeight() { setInfo();}
+
+bool ParameterSwitchWeight::read(std::istream& is) {
+	number_t i;
+	is >> i;
+  if (is.bad()) return false;
+  setInfo(i);
+  return true;
+}
+
+bool ParameterSwitchWeight::write(std::ostream& os) const {
+	os << Info();
+	return true;
+}
+
+}  // namespace g2o
diff --git a/g2o/types/slam2d/parameter_switch_weight.h b/g2o/types/slam2d/parameter_switch_weight.h
new file mode 100644
index 00000000..08842e53
--- /dev/null
+++ b/g2o/types/slam2d/parameter_switch_weight.h
@@ -0,0 +1,59 @@
+// g2o - General Graph Optimization
+// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright
+//   notice, this list of conditions and the following disclaimer in the
+//   documentation and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef G2O_SWITCHING_WEIGHT_H_
+#define G2O_SWITCHING_WEIGHT_H_
+
+
+#include "g2o_types_slam2d_api.h"
+#include "g2o/core/cache.h"
+
+
+namespace g2o {
+
+  /**
+   * \brief offset for an SE2
+   */
+  class G2O_TYPES_SLAM2D_API ParameterSwitchWeight : public Parameter
+  {
+    public:
+      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
+      ParameterSwitchWeight();
+
+      virtual bool read(std::istream& is);
+      virtual bool write(std::ostream& os) const;
+
+      inline void setInfo(const number_t info = 0.) { _info = info; };
+
+      inline number_t Info() const { return _info; };
+
+    protected:
+      number_t _info;
+  };
+
+}
+
+#endif
diff --git a/g2o/types/slam2d/types_slam2d.cpp b/g2o/types/slam2d/types_slam2d.cpp
index 532f5bd4..24db6dd5 100644
--- a/g2o/types/slam2d/types_slam2d.cpp
+++ b/g2o/types/slam2d/types_slam2d.cpp
@@ -37,8 +37,12 @@ G2O_REGISTER_TYPE_GROUP(slam2d);
 
 G2O_REGISTER_TYPE(VERTEX_SE2, VertexSE2);
 G2O_REGISTER_TYPE(VERTEX_XY, VertexPointXY);
+G2O_REGISTER_TYPE(VERTEX_PROX, VertexProx);                       //added by wada
+G2O_REGISTER_TYPE(VERTEX_SWITCH, VertexSwitch);                   //added by wada
 G2O_REGISTER_TYPE(PARAMS_SE2OFFSET, ParameterSE2Offset);
+G2O_REGISTER_TYPE(PARAMS_SWITCH_WEIGHT, ParameterSwitchWeight);   //added by wada
 G2O_REGISTER_TYPE(CACHE_SE2_OFFSET, CacheSE2Offset);
+G2O_REGISTER_TYPE(CACHE_PROX, CacheProximity);                    //added by wada
 G2O_REGISTER_TYPE(EDGE_PRIOR_SE2, EdgeSE2Prior);
 G2O_REGISTER_TYPE(EDGE_PRIOR_SE2_XY, EdgeSE2XYPrior);
 G2O_REGISTER_TYPE(EDGE_SE2, EdgeSE2);
@@ -51,9 +55,16 @@ G2O_REGISTER_TYPE(EDGE_POINTXY, EdgePointXY);
 G2O_REGISTER_TYPE(EDGE_SE2_TWOPOINTSXY, EdgeSE2TwoPointsXY);
 G2O_REGISTER_TYPE(EDGE_SE2_LOTSOFXY, EdgeSE2LotsOfXY);
 G2O_REGISTER_TYPE(EDGE_PRIOR_XY, EdgeXYPrior);
+G2O_REGISTER_TYPE(EDGE_PROX, EdgeProx);	                          //added by wada
+G2O_REGISTER_TYPE(EDGE_M_Est_PROX, EdgeMEstProx);	              //added by wada
+G2O_REGISTER_TYPE(EDGE_SWITCH_SE2, EdgeSwitchSE2SIP);             //added by wada
+G2O_REGISTER_TYPE(EDGE_SWITCH_PROX, EdgeSwitchProxSIP);           //added by wada
+G2O_REGISTER_TYPE(EDGE_SWITCH_SE2_, EdgeSwitchSE2);               //added by wada
+G2O_REGISTER_TYPE(EDGE_SWITCH_PROX_, EdgeSwitchProx);             //added by wada
 
 G2O_REGISTER_ACTION(VertexSE2WriteGnuplotAction);
 G2O_REGISTER_ACTION(VertexPointXYWriteGnuplotAction);
+G2O_REGISTER_ACTION(VertexProxWriteGnuplotAction);                //added by wada
 G2O_REGISTER_ACTION(EdgeSE2WriteGnuplotAction);
 G2O_REGISTER_ACTION(EdgeSE2PointXYWriteGnuplotAction);
 G2O_REGISTER_ACTION(EdgeSE2PointXYBearingWriteGnuplotAction);
@@ -61,9 +72,13 @@ G2O_REGISTER_ACTION(EdgeSE2PointXYBearingWriteGnuplotAction);
 #ifdef G2O_HAVE_OPENGL
 G2O_REGISTER_ACTION(VertexSE2DrawAction);
 G2O_REGISTER_ACTION(VertexPointXYDrawAction);
+G2O_REGISTER_ACTION(VertexProxDrawAction);                        //added by wada
 G2O_REGISTER_ACTION(EdgeSE2DrawAction);
 G2O_REGISTER_ACTION(EdgeSE2PointXYDrawAction);
 G2O_REGISTER_ACTION(EdgeSE2PointXYBearingDrawAction);
+G2O_REGISTER_ACTION(EdgeProxDrawAction);                          //added by wada
+G2O_REGISTER_ACTION(EdgeMEstProxDrawAction);                      //added by wada
+G2O_REGISTER_ACTION(EdgeSwitchProxDrawAction);                    //added by wada
 
 #endif
 }  // namespace g2o
diff --git a/g2o/types/slam2d/types_slam2d.h b/g2o/types/slam2d/types_slam2d.h
index 385f1cee..a8b84d33 100644
--- a/g2o/types/slam2d/types_slam2d.h
+++ b/g2o/types/slam2d/types_slam2d.h
@@ -27,6 +27,7 @@
 #ifndef G2O_TYPES_SLAM2D_
 #define G2O_TYPES_SLAM2D_
 
+#include "cache_prox.h"				//added by wada
 #include "edge_pointxy.h"
 #include "edge_se2.h"
 #include "edge_se2_lotsofxy.h"
@@ -39,9 +40,15 @@
 #include "edge_se2_twopointsxy.h"
 #include "edge_se2_xyprior.h"
 #include "edge_xy_prior.h"
+#include "edge_prox.h"               //added by wada
+#include "edge_switch_prox.h"        //added by wada
+#include "edge_switch_se2.h"         //added by wada
 #include "g2o/config.h"
 #include "parameter_se2_offset.h"
+#include "parameter_switch_weight.h" //added by wada
 #include "vertex_point_xy.h"
 #include "vertex_se2.h"
+#include "vertex_prox.h"             //added by wada
+#include "vertex_switch.h"           //added by wada
 
 #endif
diff --git a/g2o/types/slam2d/vertex_prox.cpp b/g2o/types/slam2d/vertex_prox.cpp
new file mode 100644
index 00000000..d70ebb98
--- /dev/null
+++ b/g2o/types/slam2d/vertex_prox.cpp
@@ -0,0 +1,163 @@
+// This library was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#include <string>
+#include "vertex_prox.h"
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+
+  VertexProx::VertexProx() :
+    BaseVertex<3, SE2>(), _proximityParam(){}
+
+  void VertexProx::oplusImpl(const number_t* update)
+  {
+    SE2 t = _estimate, dt = SE2();
+    dt.setTranslation(Vector2(update[0], update[1]));
+    dt.setRotation(Rotation2D(normalize_theta(update[2])));
+    _estimate = t * dt;
+  }
+
+  bool VertexProx::setProximityParam(const std::vector<Vector2>& pp)
+  {
+      _proximityParam.clear();
+      for (const Vector2& _pp : pp)
+          _proximityParam.push_back(_pp);
+      return true;
+  }
+
+  bool VertexProx::read(std::istream& is)
+  {
+    Vector3 p;
+    bool state = internal::readVector(is, p);
+    setEstimate(p);
+    int n;
+    is >> n;
+    _proximityParam.resize(n);
+    std::vector<Vector2> pp(n);
+    for (Vector2& r : pp) {
+        bool state_r = internal::readVector(is, r);
+        if (state_r == false) return false;
+    }
+    state = setProximityParam(pp) & state;
+    return state;
+  }
+
+  bool VertexProx::write(std::ostream& os) const
+  {
+    bool state_p = internal::writeVector(os, estimate().toVector());
+    os << _proximityParam.size() << " ";
+    for (const Vector2& r : _proximityParam) {
+        bool state_r = internal::writeVector(os, r);
+        if (state_r == false) return false;
+    }
+    return state_p;
+  }
+
+  VertexProxWriteGnuplotAction::VertexProxWriteGnuplotAction(): WriteGnuplotAction(typeid(VertexProx).name()){}
+
+  HyperGraphElementAction* VertexProxWriteGnuplotAction::operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* params_){
+    if (typeid(*element).name()!=_typeName)
+      return nullptr;
+    WriteGnuplotAction::Parameters* params= dynamic_cast<WriteGnuplotAction::Parameters*>(params_);
+    if (!params || !params->os){
+      std::cerr << __PRETTY_FUNCTION__ << ": warning, no valid output stream specified" << std::endl;
+      return nullptr;
+    }
+
+    VertexProx* v = dynamic_cast<VertexProx*>(element);
+    *(params->os) << v->estimate().translation().x() << " " << v->estimate().translation().y()
+      << " " << v->estimate().rotation().angle() << std::endl;
+    return this;
+  }
+
+#ifdef G2O_HAVE_OPENGL
+  VertexProxDrawAction::VertexProxDrawAction()
+      : DrawAction(typeid(VertexProx).name()), _drawActions(nullptr), _arrow_length(nullptr), _arrow_width(nullptr),
+      _point_size(nullptr), _line_width(nullptr) {}
+
+  bool VertexProxDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_){
+    if (!DrawAction::refreshPropertyPtrs(params_))
+      return false;
+    if (_previousParams){
+        _arrow_length = _previousParams->makeProperty<FloatProperty>(_typeName + "::N_Vertex_Arrow_Length", .5f);
+        _arrow_width = _previousParams->makeProperty<FloatProperty>(_typeName + "::N_Vertex_Arrow_Width", .3f);
+        _point_size = _previousParams->makeProperty<FloatProperty>(_typeName + "::P_Vertex_Size", 5.0f);
+        _line_width = _previousParams->makeProperty<FloatProperty>(_typeName + "::PN_line_width", .0f);
+    } else {
+        _arrow_length = 0;
+        _arrow_width = 0;
+        _point_size = 0;
+        _line_width = 0;
+    }
+    return true;
+  }
+
+
+  HyperGraphElementAction* VertexProxDrawAction::operator()(HyperGraph::HyperGraphElement* element,
+                 HyperGraphElementAction::Parameters* params_){
+   if (typeid(*element).name()!=_typeName)
+      return nullptr;
+    //initializeDrawActionsCache();
+    refreshPropertyPtrs(params_);
+
+    if (! _previousParams)
+      return this;
+
+    if (_show && !_show->value())
+      return this;
+
+    VertexProx* that = static_cast<VertexProx*>(element);
+
+    glPushAttrib(GL_ENABLE_BIT | GL_LIGHTING | GL_COLOR);
+    glDisable(GL_LIGHTING);
+    glColor3f(POSE_VERTEX_COLOR);
+    glPushMatrix();
+    glTranslatef((float)that->estimate().translation().x(),(float)that->estimate().translation().y(),0.f);
+    glRotatef((float)RAD2DEG(that->estimate().rotation().angle()),0.f,0.f,1.f);
+    opengl::drawArrow2D((float)_arrow_length->value(), (float)_arrow_width->value(), (float)_arrow_width->value()*.5f);
+    //drawCache(that->cacheContainer(), params_);
+    //drawUserData(that->userData(), params_);
+    glPopMatrix();
+    glColor3f(LANDMARK_VERTEX_COLOR);
+    for (int i = 0; i < that->numProx(); i++) {
+        if ((float)_point_size->value() != 0) {
+            //glColor3f(POSE_VERTEX_COLOR);
+            glPushMatrix();
+            glTranslatef((float)(that->estimate() * that->proximity(i)).x(), (float)(that->estimate() * that->proximity(i)).y(), 0.f);
+            glRotatef((float)RAD2DEG(that->estimate().rotation().angle()), 0.f, 0.f, 1.f);
+            opengl::drawPoint((float)_point_size->value());
+            //drawCache(that->cacheContainer(), params_);
+            //drawUserData(that->userData(), params_);
+            glPopMatrix();
+            glColor3f(LANDMARK_VERTEX_COLOR);
+        }
+        if ((float)_line_width->value() != 0) {
+            glColor3f(POSE_VERTEX_COLOR);
+            glPushMatrix();
+            glTranslatef((float)that->estimate().translation().x(), (float)that->estimate().translation().y(), 0.f);
+            glRotatef((float)RAD2DEG(that->estimate().rotation().angle() + atan2(that->proximity(i).y(), that->proximity(i).x())), 0.f, 0.f, 1.f);
+            opengl::drawLine((float)that->proximity(i).norm(), (float)_line_width->value());
+            //drawCache(that->cacheContainer(), params_);
+            //drawUserData(that->userData(), params_);
+            glPopMatrix();
+            glColor3f(LANDMARK_VERTEX_COLOR);
+            //glLineWidth((float)_line_width->value());
+            //glBegin(GL_LINES);
+            //glVertex3f((float)that->estimate().translation().x(), (float)that->estimate().translation().y(), 0.f);
+            //glVertex3f((float)(that->estimate() * that->proximity(i)).x(), (float)(that->estimate() * that->proximity(i)).y(), 0.f);
+            //glEnd();
+        }
+    }
+    //drawCache(that->cacheContainer(), params_);
+    //drawUserData(that->userData(), params_);
+    glPopAttrib();
+    return this;
+  }
+#endif
+
+
+} // end namespace
diff --git a/g2o/types/slam2d/vertex_prox.h b/g2o/types/slam2d/vertex_prox.h
new file mode 100644
index 00000000..37c7600c
--- /dev/null
+++ b/g2o/types/slam2d/vertex_prox.h
@@ -0,0 +1,91 @@
+// This library was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#ifndef G2O_VERTEX_SE2_PROXIMITY_H
+#define G2O_VERTEX_SE2_PROXIMITY_H
+
+#include "g2o/core/base_binary_edge.h"
+
+#include "g2o/config.h"
+#include "g2o/core/base_vertex.h"
+#include "g2o/core/hyper_graph_action.h"
+#include "se2.h"
+#include "g2o_types_slam2d_api.h"
+
+namespace g2o {
+
+  class G2O_TYPES_SLAM2D_API VertexProx : public BaseVertex<3, SE2>
+  {
+    public:
+      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+          VertexProx();
+
+      virtual void setToOriginImpl() {
+        _estimate = SE2();
+      }
+
+      virtual void oplusImpl(const number_t* update);
+
+      virtual bool setEstimateDataImpl(const number_t* est){
+        _estimate=SE2(est[0], est[1], est[2]);
+        return true;
+      }
+
+      virtual bool getEstimateData(number_t* est) const {
+        Eigen::Map<Vector3> v(est);
+        v = _estimate.toVector();
+        return true;
+      }
+      
+      virtual int estimateDimension() const { return 3; }
+
+      virtual bool setMinimalEstimateDataImpl(const number_t* est){
+        return setEstimateData(est);
+      }
+
+      virtual bool getMinimalEstimateData(number_t* est) const {
+        return getEstimateData(est);
+      }
+      
+      virtual int minimalEstimateDimension() const { return 3; }
+
+      bool setProximityParam(const std::vector<Vector2>& pp);
+
+      virtual bool read(std::istream& is);
+      virtual bool write(std::ostream& os) const;
+
+      virtual inline int numProx() const { return _proximityParam.size(); };
+      virtual inline Vector2 proximity(int i) const {
+          if(0 <= i && i < numProx())
+            return _proximityParam[i];
+          std::cerr << typeid(*this).name() << " : Out of Proximity Index Range!" << std::endl;
+          return Vector2();
+      };
+
+  private:
+      std::vector<Vector2> _proximityParam;
+  };
+
+  class G2O_TYPES_SLAM2D_API VertexProxWriteGnuplotAction: public WriteGnuplotAction {
+  public:
+      VertexProxWriteGnuplotAction();
+    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element, 
+            HyperGraphElementAction::Parameters* params_ );
+  };
+
+#ifdef G2O_HAVE_OPENGL
+  class G2O_TYPES_SLAM2D_API VertexProxDrawAction: public DrawAction{
+  public:
+    VertexProxDrawAction();
+    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element, 
+            HyperGraphElementAction::Parameters* params_ );
+  protected:
+    HyperGraphElementAction* _drawActions;
+    virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
+    FloatProperty* _arrow_length, * _arrow_width, * _point_size, * _line_width;
+
+  };
+#endif
+
+} // end namespace
+
+#endif
diff --git a/g2o/types/slam2d/vertex_se2.h b/g2o/types/slam2d/vertex_se2.h
index e9fc88fc..91168c66 100644
--- a/g2o/types/slam2d/vertex_se2.h
+++ b/g2o/types/slam2d/vertex_se2.h
@@ -46,11 +46,10 @@ class G2O_TYPES_SLAM2D_API VertexSE2 : public BaseVertex<3, SE2> {
   virtual void setToOriginImpl() { _estimate = SE2(); }
 
   virtual void oplusImpl(const number_t* update) {
-    Vector2 t = _estimate.translation();
-    t += Eigen::Map<const Vector2>(update);
-    number_t angle = normalize_theta(_estimate.rotation().angle() + update[2]);
-    _estimate.setTranslation(t);
-    _estimate.setRotation(Rotation2D(angle));
+    SE2 t = _estimate, dt = SE2();
+    dt.setTranslation(Vector2(update[0], update[1]));
+    dt.setRotation(Rotation2D(normalize_theta(update[2])));
+    _estimate = t * dt;
   }
 
   virtual bool setEstimateDataImpl(const number_t* est) {
diff --git a/g2o/types/slam2d/vertex_switch.cpp b/g2o/types/slam2d/vertex_switch.cpp
new file mode 100644
index 00000000..4d2888d6
--- /dev/null
+++ b/g2o/types/slam2d/vertex_switch.cpp
@@ -0,0 +1,33 @@
+// This class was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#include <string>
+#include "vertex_switch.h"
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+
+    VertexSwitch::VertexSwitch() :
+        BaseVertex<1, number_t>() { 
+        setToOriginImpl();
+    }
+  void VertexSwitch::oplusImpl(const number_t* update) {
+      _estimate += update[0];
+  }
+
+  bool VertexSwitch::read(std::istream& is) {
+      setToOriginImpl();
+    if (is.bad()) return true;
+    is >> _estimate;
+    return true;
+  }
+
+  bool VertexSwitch::write(std::ostream& os) const {
+    os << _estimate << " ";
+    return true;
+  }
+
+} // end namespace
diff --git a/g2o/types/slam2d/vertex_switch.h b/g2o/types/slam2d/vertex_switch.h
new file mode 100644
index 00000000..bda3e668
--- /dev/null
+++ b/g2o/types/slam2d/vertex_switch.h
@@ -0,0 +1,60 @@
+// This class was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#ifndef G2O_SWITCHING_H
+#define G2O_SWITCHING_H
+
+#include "g2o/core/base_ternary_edge.h"
+#include "parameter_switch_weight.h"
+
+#include "g2o/config.h"
+#include "g2o/core/base_vertex.h"
+#include "g2o/core/hyper_graph_action.h"
+#include "g2o_types_slam2d_api.h"
+
+namespace g2o {
+
+    class G2O_TYPES_SLAM2D_API VertexSwitch : public BaseVertex<1, number_t>
+    {
+    public:
+        EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+            VertexSwitch();
+
+        virtual void setToOriginImpl() {
+            //for (int i = 0; i < prox_maxN; i++)
+            //    _estimate[i] = 1.;
+            _estimate = 1.;
+        }
+
+        virtual void oplusImpl(const number_t* update);
+
+        virtual bool setEstimateDataImpl(const number_t* est) {
+            _estimate = est[0];
+            return true;
+        }
+
+        virtual bool getEstimateData(number_t* est) const {
+            est[0] = _estimate;
+            return true;
+        }
+
+        virtual int estimateDimension() const { return 1; }
+
+        virtual bool setMinimalEstimateDataImpl(const number_t* est) {
+            return setEstimateData(est);
+        }
+
+        virtual bool getMinimalEstimateData(number_t* est) const {
+            return getEstimateData(est);
+        }
+
+        virtual int minimalEstimateDimension() const { return 1; }
+
+        virtual bool read(std::istream& is);
+        virtual bool write(std::ostream& os) const;
+
+    private:
+    };
+
+} // end namespace
+
+#endif
-- 
2.33.1.windows.1

