<<<<<<< HEAD:0001-.patch
From a31710b4f10883c1cb50f7f75c4a40fdeebdad13 Mon Sep 17 00:00:00 2001
=======
From 13bc8b84ffc421009ed81f326100dd1b45f5a174 Mon Sep 17 00:00:00 2001
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
From: Wada Kotaro <Wada_Kotaro@stu.kobe-u.ac.jp>
Date: Thu, 20 Oct 2022 11:16:40 +0900
Subject: [PATCH] Pose-graph optimization using proximity-point pair matching
 extended to g2o/types/slam2d .

---
 g2o/EXTERNAL/freeglut/CMakeLists.txt         |   2 +-
 g2o/core/CMakeLists.txt                      |  49 +--
 g2o/core/base_ternary_edge.h                 |  31 ++
 g2o/core/sparse_optimizer.cpp                |  18 +-
 g2o/solvers/eigen/CMakeLists.txt             |   2 +-
 g2o/stuff/opengl_primitives.cpp              |   8 +
 g2o/stuff/opengl_primitives.h                |   5 +
 g2o/types/slam2d/CMakeLists.txt              |  41 ++-
 g2o/types/slam2d/cache_prox.cpp              |  39 +++
 g2o/types/slam2d/cache_prox.h                |  42 +++
<<<<<<< HEAD:0001-.patch
 g2o/types/slam2d/edge_em_prox.cpp            | 161 ++++++++++
 g2o/types/slam2d/edge_em_prox.h              |  96 ++++++
 g2o/types/slam2d/edge_em_se2.cpp             | 220 +++++++++++++
 g2o/types/slam2d/edge_em_se2.h               | 126 ++++++++
 g2o/types/slam2d/edge_prox.cpp               | 248 +++++++++++++++
 g2o/types/slam2d/edge_prox.h                 | 117 +++++++
 g2o/types/slam2d/edge_se2.cpp                |  24 +-
 g2o/types/slam2d/edge_se2.h                  |   3 +
 g2o/types/slam2d/edge_switch_prox.cpp        | 199 ++++++++++++
 g2o/types/slam2d/edge_switch_prox.h          | 104 +++++++
 g2o/types/slam2d/edge_switch_se2.cpp         | 228 ++++++++++++++
 g2o/types/slam2d/edge_switch_se2.h           | 136 ++++++++
=======
 g2o/types/slam2d/edge_em_prox.cpp            | 172 ++++++++++
 g2o/types/slam2d/edge_em_prox.h              |  96 ++++++
 g2o/types/slam2d/edge_em_se2.cpp             | 220 +++++++++++++
 g2o/types/slam2d/edge_em_se2.h               | 126 ++++++++
 g2o/types/slam2d/edge_prox.cpp               | 159 ++++++++++
 g2o/types/slam2d/edge_prox.h                 |  92 ++++++
 g2o/types/slam2d/edge_se2.cpp                |  24 +-
 g2o/types/slam2d/edge_se2.h                  |   3 +
 g2o/types/slam2d/edge_switch_prox.cpp        | 174 +++++++++++
 g2o/types/slam2d/edge_switch_prox.h          |  94 ++++++
 g2o/types/slam2d/edge_switch_se2.cpp         | 222 +++++++++++++
 g2o/types/slam2d/edge_switch_se2.h           | 127 ++++++++
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
 g2o/types/slam2d/parameter_em.cpp            |  63 ++++
 g2o/types/slam2d/parameter_em.h              |  58 ++++
 g2o/types/slam2d/parameter_em_prox.cpp       | 311 +++++++++++++++++++
 g2o/types/slam2d/parameter_em_prox.h         |  86 +++++
 g2o/types/slam2d/parameter_switch_weight.cpp |  53 ++++
 g2o/types/slam2d/parameter_switch_weight.h   |  59 ++++
 g2o/types/slam2d/se2.h                       | 104 ++++---
<<<<<<< HEAD:0001-.patch
 g2o/types/slam2d/types_slam2d.cpp            |  17 +
 g2o/types/slam2d/types_slam2d.h              |   8 +
 g2o/types/slam2d/vertex_prox.cpp             | 163 ++++++++++
 g2o/types/slam2d/vertex_prox.h               |  91 ++++++
 g2o/types/slam2d/vertex_se2.h                |   9 +-
 g2o/types/slam2d/vertex_switch.cpp           |  33 ++
 g2o/types/slam2d/vertex_switch.h             |  60 ++++
 36 files changed, 2900 insertions(+), 114 deletions(-)
=======
 g2o/types/slam2d/types_slam2d.cpp            |  13 +
 g2o/types/slam2d/types_slam2d.h              |   8 +
 g2o/types/slam2d/vertex_prox.cpp             | 153 +++++++++
 g2o/types/slam2d/vertex_prox.h               |  89 ++++++
 g2o/types/slam2d/vertex_se2.h                |   9 +-
 g2o/types/slam2d/vertex_switch.cpp           |  33 ++
 g2o/types/slam2d/vertex_switch.h             |  60 ++++
 36 files changed, 2731 insertions(+), 114 deletions(-)
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
 create mode 100644 g2o/core/base_ternary_edge.h
 create mode 100644 g2o/types/slam2d/cache_prox.cpp
 create mode 100644 g2o/types/slam2d/cache_prox.h
 create mode 100644 g2o/types/slam2d/edge_em_prox.cpp
 create mode 100644 g2o/types/slam2d/edge_em_prox.h
 create mode 100644 g2o/types/slam2d/edge_em_se2.cpp
 create mode 100644 g2o/types/slam2d/edge_em_se2.h
 create mode 100644 g2o/types/slam2d/edge_prox.cpp
 create mode 100644 g2o/types/slam2d/edge_prox.h
 create mode 100644 g2o/types/slam2d/edge_switch_prox.cpp
 create mode 100644 g2o/types/slam2d/edge_switch_prox.h
 create mode 100644 g2o/types/slam2d/edge_switch_se2.cpp
 create mode 100644 g2o/types/slam2d/edge_switch_se2.h
 create mode 100644 g2o/types/slam2d/parameter_em.cpp
 create mode 100644 g2o/types/slam2d/parameter_em.h
 create mode 100644 g2o/types/slam2d/parameter_em_prox.cpp
 create mode 100644 g2o/types/slam2d/parameter_em_prox.h
 create mode 100644 g2o/types/slam2d/parameter_switch_weight.cpp
 create mode 100644 g2o/types/slam2d/parameter_switch_weight.h
 create mode 100644 g2o/types/slam2d/vertex_prox.cpp
 create mode 100644 g2o/types/slam2d/vertex_prox.h
 create mode 100644 g2o/types/slam2d/vertex_switch.cpp
 create mode 100644 g2o/types/slam2d/vertex_switch.h

diff --git a/g2o/EXTERNAL/freeglut/CMakeLists.txt b/g2o/EXTERNAL/freeglut/CMakeLists.txt
index 75c7a9d9..f831bf76 100644
--- a/g2o/EXTERNAL/freeglut/CMakeLists.txt
+++ b/g2o/EXTERNAL/freeglut/CMakeLists.txt
@@ -7,7 +7,7 @@ add_library(freeglut_minimal ${G2O_LIB_TYPE}
 target_link_libraries(freeglut_minimal PUBLIC ${G2O_OPENGL_TARGET})
 target_include_directories(freeglut_minimal PUBLIC
   "$<BUILD_INTERFACE:${g2o_SOURCE_DIR};${PROJECT_BINARY_DIR}>"
-  $<INSTALL_INTERFACE:include/g2o/freeglut_minimal>
+  $<INSTALL_INTERFACE:include/g2o/EXTERNAL/freeglut>
 )
 
 set_target_properties(freeglut_minimal PROPERTIES OUTPUT_NAME ${LIB_PREFIX}ext_freeglut_minimal)
diff --git a/g2o/core/CMakeLists.txt b/g2o/core/CMakeLists.txt
index 4ac05b18..92d6fcaf 100644
--- a/g2o/core/CMakeLists.txt
+++ b/g2o/core/CMakeLists.txt
@@ -3,40 +3,43 @@ dynamic_aligned_buffer.hpp
 ownership.h
 base_edge.h
 base_multi_edge.h
-base_fixed_sized_edge.h        hyper_graph_action.cpp
-base_fixed_sized_edge.hpp      hyper_graph_action.h
-base_variable_sized_edge.h     hyper_graph.cpp
-base_variable_sized_edge.hpp   hyper_graph.h
-base_unary_edge.h           linear_solver.h
-base_binary_edge.h          marginal_covariance_cholesky.cpp
-base_vertex.h               marginal_covariance_cholesky.h
-base_vertex.hpp             matrix_structure.cpp
-batch_stats.cpp             matrix_structure.h
-batch_stats.h               openmp_mutex.h
+base_fixed_sized_edge.hpp   base_fixed_sized_edge.h
+base_variable_sized_edge.h  base_variable_sized_edge.hpp
+base_unary_edge.h
+base_binary_edge.h
+base_ternary_edge.h
+base_vertex.h               base_vertex.hpp
+batch_stats.cpp             batch_stats.h
+hyper_graph_action.cpp      hyper_graph_action.h
+hyper_graph.cpp             hyper_graph.h
+linear_solver.h
+marginal_covariance_cholesky.cpp marginal_covariance_cholesky.h
+matrix_structure.cpp        matrix_structure.h
+openmp_mutex.h
 block_solver.h              block_solver.hpp
 parameter.cpp               parameter.h
 cache.cpp                   cache.h
 optimizable_graph.cpp       optimizable_graph.h
 solver.cpp                  solver.h
-creators.h                  optimization_algorithm_factory.cpp
-estimate_propagator.cpp     optimization_algorithm_factory.h
-estimate_propagator.h
-factory.cpp                 optimization_algorithm_property.h
-factory.h                   sparse_block_matrix.h
-sparse_optimizer.cpp  sparse_block_matrix.hpp
-sparse_optimizer.h
-hyper_dijkstra.cpp hyper_dijkstra.h
+creators.h
+estimate_propagator.cpp     estimate_propagator.h
+factory.cpp                 factory.h
+sparse_optimizer.cpp        sparse_optimizer.h
+optimization_algorithm_factory.cpp optimization_algorithm_factory.h
+optimization_algorithm_property.h
+sparse_block_matrix.h       sparse_block_matrix.hpp
+hyper_dijkstra.cpp          hyper_dijkstra.h
 parameter_container.cpp     parameter_container.h
-optimization_algorithm.cpp optimization_algorithm.h
+optimization_algorithm.cpp  optimization_algorithm.h
 optimization_algorithm_with_hessian.cpp optimization_algorithm_with_hessian.h
 optimization_algorithm_gauss_newton.cpp optimization_algorithm_gauss_newton.h
 optimization_algorithm_levenberg.cpp optimization_algorithm_levenberg.h
 optimization_algorithm_dogleg.cpp optimization_algorithm_dogleg.h
 sparse_optimizer_terminate_action.cpp sparse_optimizer_terminate_action.h
-jacobian_workspace.cpp jacobian_workspace.h
-robust_kernel.cpp robust_kernel.h
-robust_kernel_impl.cpp robust_kernel_impl.h
-robust_kernel_factory.cpp robust_kernel_factory.h
+jacobian_workspace.cpp      jacobian_workspace.h
+robust_kernel.cpp           robust_kernel.h
+robust_kernel_impl.cpp      robust_kernel_impl.h
+robust_kernel_factory.cpp   robust_kernel_factory.h
 io_helper.h
 g2o_core_api.h
 )
diff --git a/g2o/core/base_ternary_edge.h b/g2o/core/base_ternary_edge.h
new file mode 100644
index 00000000..eb7b613f
--- /dev/null
+++ b/g2o/core/base_ternary_edge.h
@@ -0,0 +1,31 @@
+// This class was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#ifndef G2O_BASE_TERNARY_EDGE_H
+#define G2O_BASE_TERNARY_EDGE_H
+
+#include "base_fixed_sized_edge.h"
+
+namespace g2o {
+
+// This could be a simple using statement, but in multiple places
+// _jacobianOplusXi, _jacobianOplusXj and _jacobianOplusXk are used.
+template <int D, typename E, typename VertexXi, typename VertexXj, typename VertexXk>
+class BaseTernaryEdge : public BaseFixedSizedEdge<D, E, VertexXi, VertexXj, VertexXk> {
+ public:
+  using VertexXiType = VertexXi;
+  using VertexXjType = VertexXj;
+  using VertexXkType = VertexXk;
+  BaseTernaryEdge() : BaseFixedSizedEdge<D, E, VertexXi, VertexXj, VertexXk>(){};
+
+ protected:
+  typename BaseFixedSizedEdge<D, E, VertexXi, VertexXj, VertexXk>::template JacobianType<
+      D, VertexXi::Dimension>& _jacobianOplusXi = std::get<0>(this->_jacobianOplus);
+  typename BaseFixedSizedEdge<D, E, VertexXi, VertexXj, VertexXk>::template JacobianType<
+      D, VertexXj::Dimension>& _jacobianOplusXj = std::get<1>(this->_jacobianOplus);
+  typename BaseFixedSizedEdge<D, E, VertexXi, VertexXj, VertexXk>::template JacobianType<
+      D, VertexXk::Dimension>& _jacobianOplusXk = std::get<2>(this->_jacobianOplus);
+};
+
+}  // namespace g2o
+
+#endif
diff --git a/g2o/core/sparse_optimizer.cpp b/g2o/core/sparse_optimizer.cpp
index e55f929b..4fddd9c8 100644
--- a/g2o/core/sparse_optimizer.cpp
+++ b/g2o/core/sparse_optimizer.cpp
@@ -50,7 +50,7 @@ SparseOptimizer::SparseOptimizer()
     : _forceStopFlag(0),
       _verbose(false),
       _algorithm(nullptr),
-      _computeBatchStatistics(false) {
+      _computeBatchStatistics(false){
   _graphActions.resize(AT_NUM_ELEMENTS);
 }
 
@@ -390,6 +390,7 @@ void SparseOptimizer::computeInitialGuess(
 }
 
 int SparseOptimizer::optimize(int iterations, bool online) {
+    int itr = (iterations == 0 ? INT_MAX : iterations);
   if (_ivMap.size() == 0) {
     cerr << __PRETTY_FUNCTION__
          << ": 0 vertices to optimize, maybe forgot to call "
@@ -409,13 +410,15 @@ int SparseOptimizer::optimize(int iterations, bool online) {
   }
 
   _batchStatistics.clear();
-  if (_computeBatchStatistics) _batchStatistics.resize(iterations);
+  if (_computeBatchStatistics && iterations) _batchStatistics.resize(iterations);
+
+  number_t chi2 = DBL_MAX;
 
   OptimizationAlgorithm::SolverResult result = OptimizationAlgorithm::OK;
-  for (int i = 0; i < iterations && !terminate() && ok; i++) {
+  for (int i = 0; i < itr && !terminate() && ok; i++) {
     preIteration(i);
 
-    if (_computeBatchStatistics) {
+    if (_computeBatchStatistics && iterations) {
       G2OBatchStatistics& cstat = _batchStatistics[i];
       G2OBatchStatistics::setGlobalStats(&cstat);
       cstat.iteration = i;
@@ -428,7 +431,7 @@ int SparseOptimizer::optimize(int iterations, bool online) {
     ok = (result == OptimizationAlgorithm::OK);
 
     bool errorComputed = false;
-    if (_computeBatchStatistics) {
+    if (_computeBatchStatistics && iterations) {
       computeActiveErrors();
       errorComputed = true;
       _batchStatistics[i].chi2 = activeRobustChi2();
@@ -447,6 +450,11 @@ int SparseOptimizer::optimize(int iterations, bool online) {
     }
     ++cjIterations;
     postIteration(i);
+
+    number_t _chi2 = activeRobustChi2();
+    if (!iterations && fabs(chi2 - _chi2) < 1.e-6)
+        break;
+    chi2 = _chi2;
   }
   if (result == OptimizationAlgorithm::Fail) {
     return 0;
diff --git a/g2o/solvers/eigen/CMakeLists.txt b/g2o/solvers/eigen/CMakeLists.txt
index 3f4da300..6b723ce5 100644
--- a/g2o/solvers/eigen/CMakeLists.txt
+++ b/g2o/solvers/eigen/CMakeLists.txt
@@ -10,7 +10,7 @@ target_link_libraries(solver_eigen core)
 
 target_include_directories(solver_eigen PUBLIC
   "$<BUILD_INTERFACE:${g2o_SOURCE_DIR};${PROJECT_BINARY_DIR}>"
-  $<INSTALL_INTERFACE:include/g2o/solver_eigen>
+  $<INSTALL_INTERFACE:include/g2o/solvers/eigen>
 )
 
 install(TARGETS solver_eigen
diff --git a/g2o/stuff/opengl_primitives.cpp b/g2o/stuff/opengl_primitives.cpp
index 33be81e5..5bd69cfe 100644
--- a/g2o/stuff/opengl_primitives.cpp
+++ b/g2o/stuff/opengl_primitives.cpp
@@ -305,5 +305,13 @@ void drawPoint(float pointSize) {
   glVertex3f(0, 0, 0);
   glEnd();
 }
+
+void drawLine(float lineLength, float  lineWidth) {
+    glLineWidth(lineWidth);
+    glBegin(GL_LINES);
+    glVertex3f(0.f, 0.f, 0.f);
+    glVertex3f(lineLength, 0.f, 0.f);
+    glEnd();
+}
 }  // namespace opengl
 }  // namespace g2o
diff --git a/g2o/stuff/opengl_primitives.h b/g2o/stuff/opengl_primitives.h
index f3aade98..00b123ea 100644
--- a/g2o/stuff/opengl_primitives.h
+++ b/g2o/stuff/opengl_primitives.h
@@ -139,6 +139,11 @@ void G2O_OPENGL_API drawArrow2D(float len, float head_width, float head_len);
  */
 void G2O_OPENGL_API drawPoint(float pointSize);
 
+/**
+ * draw a line along the x axis
+ */
+void G2O_OPENGL_API drawLine(float lineLength, float  lineWidth);
+
 // @}
 
 #define POSE_VERTEX_COLOR 0.5f, 0.5f, 0.8f
diff --git a/g2o/types/slam2d/CMakeLists.txt b/g2o/types/slam2d/CMakeLists.txt
index a565f5fd..e1bc7a38 100644
--- a/g2o/types/slam2d/CMakeLists.txt
+++ b/g2o/types/slam2d/CMakeLists.txt
@@ -1,19 +1,32 @@
 add_library(types_slam2d ${G2O_LIB_TYPE}
+  types_slam2d.cpp			types_slam2d.h
   se2.h
-  edge_se2_pointxy_bearing.h  edge_se2_prior.h
-  edge_se2.cpp                  edge_se2_pointxy_calib.cpp  types_slam2d.cpp
-  edge_se2.h                    edge_se2_pointxy_calib.h    vertex_point_xy.cpp
-  edge_se2_pointxy.cpp        vertex_point_xy.h
-  edge_se2_pointxy.h          vertex_se2.cpp
-  edge_se2_pointxy_bearing.cpp  edge_se2_prior.cpp          vertex_se2.h
-  parameter_se2_offset.cpp     parameter_se2_offset.h
-  edge_se2_offset.cpp          edge_se2_offset.h
-  edge_se2_pointxy_offset.cpp  edge_se2_pointxy_offset.h
-  edge_se2_xyprior.cpp edge_se2_xyprior.h
-  edge_pointxy.cpp             edge_pointxy.h
-  edge_se2_twopointsxy.cpp	edge_se2_twopointsxy.h
-  edge_se2_lotsofxy.cpp		edge_se2_lotsofxy.h
-  edge_xy_prior.cpp		edge_xy_prior.h
+  cache_prox.cpp				cache_prox.h		#added by wada
+  edge_se2.cpp					edge_se2.h
+  edge_se2_pointxy_bearing.cpp	edge_se2_pointxy_bearing.h
+  edge_se2_pointxy_calib.cpp	edge_se2_pointxy_calib.h
+  edge_se2_pointxy.cpp			edge_se2_pointxy.h
+  edge_se2_prior.cpp			edge_se2_prior.h
+  edge_se2_offset.cpp			edge_se2_offset.h
+  edge_se2_pointxy_offset.cpp	edge_se2_pointxy_offset.h
+  edge_se2_xyprior.cpp			edge_se2_xyprior.h
+  edge_pointxy.cpp				edge_pointxy.h
+  edge_se2_twopointsxy.cpp		edge_se2_twopointsxy.h
+  edge_se2_lotsofxy.cpp			edge_se2_lotsofxy.h
+  edge_xy_prior.cpp				edge_xy_prior.h
+  edge_prox.cpp					edge_prox.h				#added by wada
+  edge_switch_se2.cpp			edge_switch_se2.h		#added by wada
+  edge_switch_prox.cpp			edge_switch_prox.h		#added by wada
+#  edge_em_se2.cpp				edge_em_se2.h			#added by wada
+  edge_em_prox.cpp				edge_em_prox.h			#added by wada
+  vertex_se2.cpp				vertex_se2.h
+  vertex_point_xy.cpp			vertex_point_xy.h
+  vertex_switch.cpp				vertex_switch.h			#added by wada
+  vertex_prox.cpp				vertex_prox.h			#added by wada
+  parameter_se2_offset.cpp		parameter_se2_offset.h
+  parameter_switch_weight.cpp	parameter_switch_weight.h	#added by wada
+#  parameter_em_se2.cpp			parameter_em_se2.h		#added by wada
+#  parameter_em_prox.cpp		parameter_em_prox.h		#added by wada
   g2o_types_slam2d_api.h
 )
 
diff --git a/g2o/types/slam2d/cache_prox.cpp b/g2o/types/slam2d/cache_prox.cpp
new file mode 100644
index 00000000..8c08b02e
--- /dev/null
+++ b/g2o/types/slam2d/cache_prox.cpp
@@ -0,0 +1,39 @@
+// This library was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#include "cache_prox.h"
+#include <iostream>
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+
+CacheProximity::CacheProximity() : Cache(){}
+
+bool CacheProximity::resolveDependencies() {
+    return true;
+}
+
+void CacheProximity::updateImpl() {
+  const VertexProx* v = static_cast<const VertexProx*>(vertex());
+  Eigen::Rotation2Dd dR = Eigen::Rotation2Dd(v->estimate().rotation().angle() + M_PI_2);
+  int n = v->numProx();
+  _locProxPoints.resize(n);
+  _locNormalVecs.resize(n);
+  _absProxPoints.resize(n);
+  _absNormalVecs.resize(n);
+  _diffProxPoints.resize(n);
+  _diffNormalVecs.resize(n);
+  for (int i = 0; i < n; i++) {
+      _locProxPoints[i] = v->proximity(i);
+      _locNormalVecs[i] = r(i) / r(i).norm();
+      _absProxPoints[i] = v->estimate() * r(i);
+      _absNormalVecs[i] = v->estimate().rotation() * u(i);
+      _diffProxPoints[i] = dR * r(i);
+      _diffNormalVecs[i] = dR * u(i);
+  }
+}
+
+}
diff --git a/g2o/types/slam2d/cache_prox.h b/g2o/types/slam2d/cache_prox.h
new file mode 100644
index 00000000..c5cdfde9
--- /dev/null
+++ b/g2o/types/slam2d/cache_prox.h
@@ -0,0 +1,42 @@
+// This library was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#ifndef G2O_PARAMETER_PROXIMITY_H_
+#define G2O_PARAMETER_PROXIMITY_H_
<<<<<<< HEAD:0001-.patch
+
+#include <cmath>
+#include <vector>
+
+#include "g2o/core/cache.h"
+#include "g2o_types_slam2d_api.h"
+#include "vertex_prox.h"
+
+namespace g2o {
+
+class G2O_TYPES_SLAM2D_API CacheProximity : public Cache {
+ public:
+  EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
+  CacheProximity();
+  virtual void updateImpl();
+
+  inline const int& numProx() const { return _locProxPoints.size(); }
+  inline const Vector2& r(int i) const { return _locProxPoints[i]; }
+  inline const Vector2& u(int i) const { return _locNormalVecs[i]; }
+  inline const Vector2& q(int i) const { return _absProxPoints[i]; }
+  inline const Vector2& e(int i) const { return _absNormalVecs[i]; }
+  inline const Vector2& dq(int i) const { return _diffProxPoints[i]; }
+  inline const Vector2& de(int i) const { return _diffNormalVecs[i]; }
+
+ protected:
+     std::vector<Vector2> _locProxPoints;
+     std::vector<Vector2> _absProxPoints;
+     std::vector<Vector2> _diffProxPoints;
+     std::vector<Vector2> _locNormalVecs;
+     std::vector<Vector2> _absNormalVecs;
+     std::vector<Vector2> _diffNormalVecs;
+
+ protected:
+  virtual bool resolveDependencies();
+};
+
+}
+#endif
diff --git a/g2o/types/slam2d/edge_em_prox.cpp b/g2o/types/slam2d/edge_em_prox.cpp
new file mode 100644
index 00000000..dcf5a479
--- /dev/null
+++ b/g2o/types/slam2d/edge_em_prox.cpp
@@ -0,0 +1,161 @@
+// This library was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#include "edge_em_prox.h"
+#include <iostream>
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+    using namespace std;
+
+
+    EdgeEMProx::EdgeEMProx()
+        : BaseBinaryEdge<2, array<int, 2>, VertexProx, VertexProx>(), _proxPair(), switchInfo(0.){
+        _cacheFrom = 0;
+        _cacheTo = 0;
+        information().setZero();
+        maxInfo.setZero();
+        _ProxPairWeightInfo = 0;
+        resizeParameters(1);
+        installParameter(_ProxPairWeightInfo, 0);
+    }
+
+    bool EdgeEMProx::resolveCaches() {
+        ParameterVector pv(0);
+        resolveCache(_cacheFrom, (OptimizableGraph::Vertex*)_vertices[0],
+            "CACHE_PROX", pv);
+        resolveCache(_cacheTo, (OptimizableGraph::Vertex*)_vertices[1],
+            "CACHE_PROX", pv);
+        return (_cacheFrom && _cacheTo);
+    }
+
+    bool EdgeEMProx::read(std::istream& is) {
+        setMeasurementData(0);
+        if (is.bad()) return false;
+        information().setZero();
+        maxInfo.setZero();
+        if (!setParameterId(0, 0))
+            return false;
+        resolveParameters();
+        switchInfo = _ProxPairWeightInfo->Info();
+
+        is >> _proxPair[0] >> _proxPair[1];
+        double info;
+        is >> info;
+        maxInfo(0, 0) = info;
+        maxInfo(1, 1) = info;
+        information() = maxInfo;
+        if (is.bad()) return false;
+        return true;
+    }
+
+    bool EdgeEMProx::write(std::ostream& os) const {
+        os << _proxPair[0] << " " << _proxPair[1] << " " << maxInfo(0, 0) << " ";
+        return true;
+    }
+
+    void EdgeEMProx::computeError() {
+        _error.setZero();
+        information() = maxInfo;
+        const int fi = fp(), ti = tp();
+        _error(0, 0) = fc()->e(fi).dot(tc()->q(ti) - fc()->q(fi));
+        _error(1, 0) = tc()->e(ti).dot(fc()->q(fi) - tc()->q(ti));
+        information() = maxInfo * min(2. * switchInfo / (switchInfo + chi2()), 1.);
+    }
+
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+    void EdgeEMProx::linearizeOplus() {
+        _jacobianOplusXi.setZero();
+        _jacobianOplusXj.setZero();
+        const SE2 vi = dynamic_cast<VertexProx*>(_vertices[0])->estimate();
+        const SE2 vj = dynamic_cast<VertexProx*>(_vertices[1])->estimate();
+        const Matrix2 Ri = vi.rotation().toRotationMatrix(),
+            Rj = vj.rotation().toRotationMatrix();
+        const int fi = fp(), ti = tp();
+        _jacobianOplusXi.block<1, 2>(0, 0) = -fc()->u(fi);
+        _jacobianOplusXi(0, 2) = fc()->de(fi).dot(tc()->q(ti) - fc()->q(fi)) - fc()->e(fi).dot(fc()->dq(fi));
+        _jacobianOplusXi.block<1, 2>(1, 0) = Ri.transpose() * tc()->e(ti);
+        _jacobianOplusXi(1, 2) = tc()->e(ti).dot(fc()->dq(fi));
+        _jacobianOplusXj.block<1, 2>(0, 0) = Rj.transpose() * fc()->e(fi);
+        _jacobianOplusXj(0, 2) = fc()->e(fi).dot(tc()->dq(ti));
+        _jacobianOplusXj.block<1, 2>(1, 0) = -tc()->u(ti);
+        _jacobianOplusXj(1, 2) = tc()->de(ti).dot(fc()->q(fi) - tc()->q(ti)) - tc()->e(ti).dot(tc()->dq(ti));
+    }
+#endif
+
+    bool EdgeEMProx::setMeasurementFromState() {
+        return true;
+    }
+
+
+    void EdgeEMProx::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* /*to_*/) {}
+
+#ifdef G2O_HAVE_OPENGL
+    EdgeEMProxDrawAction::EdgeEMProxDrawAction()
+        : DrawAction(typeid(EdgeEMProx).name()), _triangleY(nullptr), _triangleZ(nullptr) {}
+
+    bool EdgeEMProxDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_) {
+        if (!DrawAction::refreshPropertyPtrs(params_))
+            return false;
+        if (_previousParams) {
+            _triangleY = _previousParams->makeProperty<FloatProperty>(_typeName + "::N_Edge_Width", 3.0f);
+            _triangleZ = _previousParams->makeProperty<FloatProperty>(_typeName + "::P_Edge_Width", 2.0f);
+        }
+        else {
+            _triangleY = 0;
+            _triangleZ = 0;
+        }
+        return true;
+    }
+
+    HyperGraphElementAction* EdgeEMProxDrawAction::operator()(HyperGraph::HyperGraphElement* element,
+        HyperGraphElementAction::Parameters* params_) {
+        if (typeid(*element).name() != _typeName)
+            return nullptr;
+
+        refreshPropertyPtrs(params_);
+        if (!_previousParams)
+            return this;
+
+        if (_show && !_show->value())
+            return this;
+
+        EdgeEMProx* e = static_cast<EdgeEMProx*>(element);
+        VertexProx* from = static_cast<VertexProx*>(e->vertex(0));
+        VertexProx* to = static_cast<VertexProx*>(e->vertex(1));
+        if (!from && !to)
+            return this;
+        SE2 fromTransform;
+        SE2 toTransform;
+        Vector2 fromProximity;
+        Vector2 toProximity;
+        glPushAttrib(GL_ENABLE_BIT | GL_LIGHTING | GL_COLOR);
+        glDisable(GL_LIGHTING);
+        fromTransform = from->estimate();
+        toTransform = to->estimate();
+        fromProximity = e->fc()->q(e->fp());
+        toProximity = e->tc()->q(e->tp());
+        if (_triangleY->value() != 0) {
+            glLineWidth((float)_triangleY->value());
+            glColor3f(POSE_EDGE_COLOR);
+            glBegin(GL_LINES);
+            glVertex3f((float)fromTransform.translation().x(), (float)fromTransform.translation().y(), 0.f);
+            glVertex3f((float)toTransform.translation().x(), (float)toTransform.translation().y(), 0.f);
+            glEnd();
+        }
+        if (_triangleZ->value() != 0) {
+            glLineWidth((float)_triangleZ->value());
+            glColor3f(LANDMARK_EDGE_COLOR);
+            glBegin(GL_LINES);
+            glVertex3f((float)fromProximity.x(), (float)fromProximity.y(), 0.f);
+            glVertex3f((float)toProximity.x(), (float)toProximity.y(), 0.f);
+            glEnd();
+        }
+        glPopAttrib();
+        return this;
+    }
+#endif
+}
diff --git a/g2o/types/slam2d/edge_em_prox.h b/g2o/types/slam2d/edge_em_prox.h
new file mode 100644
index 00000000..06c6a9f6
--- /dev/null
+++ b/g2o/types/slam2d/edge_em_prox.h
@@ -0,0 +1,96 @@
+// This library was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#ifndef G2O_EDGE_EM_PROX_H_
+#define G2O_EDGE_EM_PROX_H_
+
+//#define NUMERIC_JACOBIAN_TWO_D_TYPES
+
=======
+
+#include <cmath>
+#include <vector>
+
+#include "g2o/core/cache.h"
+#include "g2o_types_slam2d_api.h"
+#include "vertex_prox.h"
+
+namespace g2o {
+
+class G2O_TYPES_SLAM2D_API CacheProximity : public Cache {
+ public:
+  EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
+  CacheProximity();
+  virtual void updateImpl();
+
+  inline const int& numProx() const { return _locProxPoints.size(); }
+  inline const Vector2& r(int i) const { return _locProxPoints[i]; }
+  inline const Vector2& u(int i) const { return _locNormalVecs[i]; }
+  inline const Vector2& q(int i) const { return _absProxPoints[i]; }
+  inline const Vector2& e(int i) const { return _absNormalVecs[i]; }
+  inline const Vector2& dq(int i) const { return _diffProxPoints[i]; }
+  inline const Vector2& de(int i) const { return _diffNormalVecs[i]; }
+
+ protected:
+     std::vector<Vector2> _locProxPoints;
+     std::vector<Vector2> _absProxPoints;
+     std::vector<Vector2> _diffProxPoints;
+     std::vector<Vector2> _locNormalVecs;
+     std::vector<Vector2> _absNormalVecs;
+     std::vector<Vector2> _diffNormalVecs;
+
+ protected:
+  virtual bool resolveDependencies();
+};
+
+}
+#endif
diff --git a/g2o/types/slam2d/edge_em_prox.cpp b/g2o/types/slam2d/edge_em_prox.cpp
new file mode 100644
index 00000000..36198755
--- /dev/null
+++ b/g2o/types/slam2d/edge_em_prox.cpp
@@ -0,0 +1,172 @@
+// This library was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#include "edge_em_prox.h"
+#include <iostream>
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+    using namespace std;
+
+
+    EdgeEMProx::EdgeEMProx()
+        : BaseBinaryEdge<2, array<int, 2>, VertexProx, VertexProx>(), _proxPair(), switchInfo(0.){
+        _cacheFrom = 0;
+        _cacheTo = 0;
+        information().setZero();
+        maxInfo.setZero();
+        _ProxPairWeightInfo = 0;
+        resizeParameters(1);
+        installParameter(_ProxPairWeightInfo, 0);
+    }
+
+    bool EdgeEMProx::resolveCaches() {
+        ParameterVector pv(0);
+        resolveCache(_cacheFrom, (OptimizableGraph::Vertex*)_vertices[0],
+            "CACHE_PROX", pv);
+        resolveCache(_cacheTo, (OptimizableGraph::Vertex*)_vertices[1],
+            "CACHE_PROX", pv);
+        return (_cacheFrom && _cacheTo);
+    }
+
+    bool EdgeEMProx::read(std::istream& is) {
+        setMeasurementData(0);
+        if (is.bad()) return false;
+        information().setZero();
+        maxInfo.setZero();
+        if (!setParameterId(0, 0))
+            return false;
+        resolveParameters();
+        switchInfo = _ProxPairWeightInfo->Info();
+
+        is >> _proxPair[0] >> _proxPair[1];
+        double info;
+        is >> info;
+        maxInfo(0, 0) = info;
+        maxInfo(1, 1) = info;
+        information() = maxInfo;
+        if (is.bad()) return false;
+        return true;
+    }
+
+    bool EdgeEMProx::write(std::ostream& os) const {
+        os << _proxPair[0] << " " << _proxPair[1] << " " << information()(0, 0) << " ";
+        return true;
+    }
+
+    void EdgeEMProx::computeError() {
+        _error.setZero();
+        information() = maxInfo;
+        const int fi = fp(), ti = tp();
+        _error(0, 0) = fc()->e(fi).dot(tc()->q(ti) - fc()->q(fi));
+        _error(1, 0) = tc()->e(ti).dot(fc()->q(fi) - tc()->q(ti));
+        information() = maxInfo * min(2. * switchInfo / (switchInfo + chi2()), 1.);
+    }
+
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+    void EdgeEMProx::linearizeOplus() {
+        _jacobianOplusXi.setZero();
+        _jacobianOplusXj.setZero();
+        const SE2 vi = dynamic_cast<VertexProx*>(_vertices[0])->estimate();
+        const SE2 vj = dynamic_cast<VertexProx*>(_vertices[1])->estimate();
+        const Matrix2 Ri = vi.rotation().toRotationMatrix(),
+            Rj = vj.rotation().toRotationMatrix();
+        const int fi = fp(), ti = tp();
+        _jacobianOplusXi.block<1, 2>(0, 0) = -fc()->u(fi);
+        _jacobianOplusXi(0, 2) = fc()->de(fi).dot(tc()->q(ti) - fc()->q(fi)) - fc()->e(fi).dot(fc()->dq(fi));
+        _jacobianOplusXi.block<1, 2>(1, 0) = Ri.transpose() * tc()->e(ti);
+        _jacobianOplusXi(1, 2) = tc()->e(ti).dot(fc()->dq(fi));
+        _jacobianOplusXj.block<1, 2>(0, 0) = Rj.transpose() * fc()->e(fi);
+        _jacobianOplusXj(0, 2) = fc()->e(fi).dot(tc()->dq(ti));
+        _jacobianOplusXj.block<1, 2>(1, 0) = -tc()->u(ti);
+        _jacobianOplusXj(1, 2) = tc()->de(ti).dot(fc()->q(fi) - tc()->q(ti)) - tc()->e(ti).dot(tc()->dq(ti));
+    }
+#endif
+
+    bool EdgeEMProx::setMeasurementFromState() {
+        //VertexSE2Proximity* from_node = static_cast<VertexSE2Proximity*>(_vertices[0]);
+        //VertexSE2Proximity* to_node = static_cast<VertexSE2Proximity*>(_vertices[1]);
+        //_measurement = from_node->estimate().inverse() * to_node->estimate();
+        return true;
+    }
+
+
+    void EdgeEMProx::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* /*to_*/)
+    {
+        //VertexSE2Proximity* from_node = dynamic_cast<VertexSE2Proximity*>(_vertices[0]);
+        //VertexSE2Proximity* to_node = dynamic_cast<VertexSE2Proximity*>(_vertices[1]);
+        //if (from.count(from_node) > 0)
+        //    to_node->setEstimate(from_node->estimate() * _measurement);
+        //else
+        //    from_node->setEstimate(to_node->estimate() * _measurement.inverse());
+    }
+
+#ifdef G2O_HAVE_OPENGL
+    EdgeEMProxDrawAction::EdgeEMProxDrawAction()
+        : DrawAction(typeid(EdgeEMProx).name()), _triangleY(nullptr), _triangleZ(nullptr) {}
+
+    bool EdgeEMProxDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_) {
+        if (!DrawAction::refreshPropertyPtrs(params_))
+            return false;
+        if (_previousParams) {
+            _triangleY = _previousParams->makeProperty<FloatProperty>(_typeName + "::N_Edge_Width", 3.0f);
+            _triangleZ = _previousParams->makeProperty<FloatProperty>(_typeName + "::P_Edge_Width", 2.0f);
+        }
+        else {
+            _triangleY = 0;
+            _triangleZ = 0;
+        }
+        return true;
+    }
+
+    HyperGraphElementAction* EdgeEMProxDrawAction::operator()(HyperGraph::HyperGraphElement* element,
+        HyperGraphElementAction::Parameters* params_) {
+        if (typeid(*element).name() != _typeName)
+            return nullptr;
+
+        refreshPropertyPtrs(params_);
+        if (!_previousParams)
+            return this;
+
+        if (_show && !_show->value())
+            return this;
+
+        EdgeEMProx* e = static_cast<EdgeEMProx*>(element);
+        VertexProx* from = static_cast<VertexProx*>(e->vertex(0));
+        VertexProx* to = static_cast<VertexProx*>(e->vertex(1));
+        if (!from && !to)
+            return this;
+        SE2 fromTransform;
+        SE2 toTransform;
+        Vector2 fromProximity;
+        Vector2 toProximity;
+        glPushAttrib(GL_ENABLE_BIT | GL_LIGHTING | GL_COLOR);
+        glDisable(GL_LIGHTING);
+        fromTransform = from->estimate();
+        toTransform = to->estimate();
+        fromProximity = e->fc()->q(e->fp());
+        toProximity = e->tc()->q(e->tp());
+        if (_triangleY->value() != 0) {
+            glLineWidth((float)_triangleY->value());
+            glColor3f(POSE_EDGE_COLOR);
+            glBegin(GL_LINES);
+            glVertex3f((float)fromTransform.translation().x(), (float)fromTransform.translation().y(), 0.f);
+            glVertex3f((float)toTransform.translation().x(), (float)toTransform.translation().y(), 0.f);
+            glEnd();
+        }
+        if (_triangleZ->value() != 0) {
+            glLineWidth((float)_triangleZ->value());
+            glColor3f(LANDMARK_EDGE_COLOR);
+            glBegin(GL_LINES);
+            glVertex3f((float)fromProximity.x(), (float)fromProximity.y(), 0.f);
+            glVertex3f((float)toProximity.x(), (float)toProximity.y(), 0.f);
+            glEnd();
+        }
+        glPopAttrib();
+        return this;
+    }
+#endif
+}
diff --git a/g2o/types/slam2d/edge_em_prox.h b/g2o/types/slam2d/edge_em_prox.h
new file mode 100644
index 00000000..06c6a9f6
--- /dev/null
+++ b/g2o/types/slam2d/edge_em_prox.h
@@ -0,0 +1,96 @@
+// This library was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#ifndef G2O_EDGE_EM_PROX_H_
+#define G2O_EDGE_EM_PROX_H_
+
+//#define NUMERIC_JACOBIAN_TWO_D_TYPES
+
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
+#include "g2o/core/base_binary_edge.h"
+#include "vertex_prox.h"
+#include "cache_prox.h"
+#include "parameter_switch_weight.h"
+#include "g2o_types_slam2d_api.h"
+
+namespace g2o {
+
+    class G2O_TYPES_SLAM2D_API EdgeEMProx : public BaseBinaryEdge < 2, std::array<int, 2>, VertexProx, VertexProx > {
+    public:
+        EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+            EdgeEMProx();
+
+        virtual bool resolveCaches();
+
+        virtual bool read(std::istream& is);
+        virtual bool write(std::ostream& os) const;
+
+        void computeError();
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+        virtual void linearizeOplus();
+#endif
+
+        virtual void setMeasurement(const std::array<int, 2> m) {
+            for (int i = 0; i < 2; i++)
+                _measurement[i] = m[i];
+        }
+
+        virtual void setMeasurement(const int m[2]) {
+            for (int i = 0; i < 2; i++)
+                _measurement[i] = m[i];
+        }
+
+        virtual bool setMeasurementData(const int* d) {
+            for (int i = 0; i < 2; i++)
+                _measurement[i] = d[i];
+            return true;
+        }
+
+        virtual bool setMeasurementData(const int d) {
+            for (int i = 0; i < 2; i++)
+                _measurement[i] = d;
+            return true;
+        }
+
+        virtual bool getMeasurementData(int d[2]) const {
+            for (int i = 0; i < 2; i++)
+                d[i] = _measurement[i];
+            return true;
+        }
+
+        virtual int measurementDimension() const { return 3; }
+
+        virtual bool setMeasurementFromState();
+
+        virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to) {
+            (void)to;
+            return (from.count(_vertices[0]) == 1 ? 1.0 : -1.0);
+        }
+
+        virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
+
+        const virtual inline int fp() const { return _proxPair[0]; };
+        const virtual inline int tp() const { return _proxPair[1]; };
+        const virtual inline CacheProximity* fc() const { return _cacheFrom; };
+        const virtual inline CacheProximity* tc() const { return _cacheTo; };
+
+    private:
+        std::array<int, 2> _proxPair;
+        ParameterSwitchWeight* _ProxPairWeightInfo;
+        CacheProximity* _cacheFrom, * _cacheTo;
+        Matrix2 maxInfo;
+        double switchInfo;
+    };
+
+#ifdef G2O_HAVE_OPENGL
+    class G2O_TYPES_SLAM2D_API EdgeEMProxDrawAction : public DrawAction {
+    public:
+        EdgeEMProxDrawAction();
+        virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
+            HyperGraphElementAction::Parameters* params_);
+    protected:
+        virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
+        FloatProperty* _triangleY, * _triangleZ;
+    };
+#endif
+
+}
+#endif
diff --git a/g2o/types/slam2d/edge_em_se2.cpp b/g2o/types/slam2d/edge_em_se2.cpp
new file mode 100644
index 00000000..c87f048d
--- /dev/null
+++ b/g2o/types/slam2d/edge_em_se2.cpp
@@ -0,0 +1,220 @@
+// g2o - General Graph Optimization
+// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright
+//   notice, this list of conditions and the following disclaimer in the
+//   documentation and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "edge_em_se2.h"
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+
+  EdgeSwitchSE2::EdgeSwitchSE2() :
+      BaseBinaryEdge<3, SE2, VertexSE2, VertexSE2>(), info(1.)
+  {
+      _WeightInfo = 0;
+      resizeParameters(1);
+      installParameter(_WeightInfo, 0);
+  }
+
+  bool EdgeSwitchSE2::read(std::istream& is)
+  {
+    Vector3 p;
+    internal::readVector(is, p);
+    setMeasurement(SE2(p));
+    _inverseMeasurement = measurement().inverse();
+    information().setZero();
+    for (int i = 0; i < 3 && is.good(); ++i)
+        for (int j = i; j < 3 && is.good(); ++j) {
+            is >> information()(i, j);
+            if (i != j) information()(j, i) = information()(i, j);
+        }
+    if (!setParameterId(0, 0))
+        return false;
+    resolveParameters();
+    info = _WeightInfo->Info();
+    information()(3, 3) = info;
+    return true;
+  }
+
+  bool EdgeSwitchSE2::write(std::ostream& os) const
+  {
+    internal::writeVector(os, measurement().toVector());
+    return writeInformationMatrix(os);
+  }
+
+  void EdgeSwitchSE2::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* /* to */)
+  {
+    VertexSE2* fromEdge = static_cast<VertexSE2*>(_vertices[0]);
+    VertexSE2* toEdge   = static_cast<VertexSE2*>(_vertices[1]);
+    if (from.count(fromEdge) > 0)
+      toEdge->setEstimate(fromEdge->estimate() * _measurement);
+    else
+      fromEdge->setEstimate(toEdge->estimate() * _inverseMeasurement);
+  }
+
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+  void EdgeSwitchSE2::linearizeOplus()
+  {
+    //const VertexSE2* vi = static_cast<const VertexSE2*>(_vertices[0]);
+    //const VertexSE2* vj = static_cast<const VertexSE2*>(_vertices[1]);
+    //number_t thetai = vi->estimate().rotation().angle();
+
+    //Vector2 dt = vj->estimate().translation() - vi->estimate().translation();
+    //number_t si=std::sin(thetai), ci=std::cos(thetai);
+
+    //_jacobianOplusXi <<
+    //    -ci, -si, -si*dt.x()+ci*dt.y(),
+    //     si, -ci, -ci*dt.x()-si*dt.y(),
+    //     0,  0,   -1;
+
+    //_jacobianOplusXj <<
+    //     ci, si, 0,
+    //    -si, ci, 0,
+    //     0,  0,  1;
+
+    //const SE2& rmean = _inverseMeasurement;
+    //Matrix3 z;
+    //z.block<2, 2>(0, 0) = rmean.rotation().toRotationMatrix();
+    //z.col(2) << cst(0.), cst(0.), cst(1.);
+    //z.row(2).head<2>() << cst(0.), cst(0.);
+    //_jacobianOplusXi = z * _jacobianOplusXi;
+    //_jacobianOplusXj = z * _jacobianOplusXj;
+      const VertexSE2* vi = static_cast<const VertexSE2*>(_vertices[0]);
+      const VertexSE2* vj = static_cast<const VertexSE2*>(_vertices[1]);
+      SE2 delta = _inverseMeasurement * (vi->estimate().inverse() * vj->estimate());
+      delta.setRotation(Rotation2D(normalize_theta(delta.rotation().angle())));
+
+      Vector2 dt = vj->estimate().translation() - vi->estimate().translation();
+      Matrix2 dR = vi->estimate().rotation().toRotationMatrix().transpose() * vj->estimate().rotation().toRotationMatrix();
+      const SE2& rmean = _inverseMeasurement;
+      Vector2 z = rmean.rotation().toRotationMatrix() * vi->estimate().rotation().toRotationMatrix().transpose() * dt;
+
+      _jacobianOplusXi.setZero();
+      _jacobianOplusXi.block<2, 2>(0, 0) = - s * rmean.rotation().toRotationMatrix();
+      _jacobianOplusXi.col(2) = s * Vector4{ z.y(), -z.x(), -1., 0. };
+      _jacobianOplusXj.setZero();
+      _jacobianOplusXj.block<2, 2>(0, 0) = s * rmean.rotation().toRotationMatrix() * dR;
+      _jacobianOplusXj(2,2) = s;
+  }
+#endif
+
+  EdgeSwitchSE2WriteGnuplotAction::EdgeSwitchSE2WriteGnuplotAction(): WriteGnuplotAction(typeid(EdgeSwitchSE2).name()){}
+
+  HyperGraphElementAction* EdgeSwitchSE2WriteGnuplotAction::operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* params_){
+    if (typeid(*element).name()!=_typeName)
+      return nullptr;
+    WriteGnuplotAction::Parameters* params=static_cast<WriteGnuplotAction::Parameters*>(params_);
+    if (!params->os){
+      std::cerr << __PRETTY_FUNCTION__ << ": warning, on valid os specified" << std::endl;
+      return nullptr;
+    }
+
+    EdgeSwitchSE2* e =  static_cast<EdgeSwitchSE2*>(element);
+    VertexSE2* fromEdge = static_cast<VertexSE2*>(e->vertex(0));
+    VertexSE2* toEdge   = static_cast<VertexSE2*>(e->vertex(1));
+    *(params->os) << fromEdge->estimate().translation().x() << " " << fromEdge->estimate().translation().y()
+      << " " << fromEdge->estimate().rotation().angle() << std::endl;
+    *(params->os) << toEdge->estimate().translation().x() << " " << toEdge->estimate().translation().y()
+      << " " << toEdge->estimate().rotation().angle() << std::endl;
+    *(params->os) << std::endl;
+    return this;
+  }
+
+#ifdef G2O_HAVE_OPENGL
+  EdgeSwitchSE2DrawAction::EdgeSwitchSE2DrawAction()
+      : DrawAction(typeid(EdgeSwitchSE2).name()), _triangleX(nullptr), _triangleY(nullptr) {}
+
+  bool EdgeSwitchSE2DrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_){
+    if (!DrawAction::refreshPropertyPtrs(params_))
+      return false;
+    if (_previousParams){
+      _triangleX = _previousParams->makeProperty<FloatProperty>(_typeName + "::GHOST_TRIANGLE_X", .2f);
+      _triangleY = _previousParams->makeProperty<FloatProperty>(_typeName + "::GHOST_TRIANGLE_Y", .05f);
+    } else {
+      _triangleX = 0;
+      _triangleY = 0;
+    }
+    return true;
+  }
+
+  HyperGraphElementAction* EdgeSwitchSE2DrawAction::operator()(HyperGraph::HyperGraphElement* element,
+               HyperGraphElementAction::Parameters* params_){
+    if (typeid(*element).name()!=_typeName)
+      return nullptr;
+
+    refreshPropertyPtrs(params_);
+    if (! _previousParams)
+      return this;
+
+    if (_show && !_show->value())
+      return this;
+
+    EdgeSwitchSE2* e =  static_cast<EdgeSwitchSE2*>(element);
+    VertexSE2* from = static_cast<VertexSE2*>(e->vertex(0));
+    VertexSE2* to   = static_cast<VertexSE2*>(e->vertex(1));
+    if (! from && ! to)
+      return this;
+    SE2 fromTransform;
+    SE2 toTransform;
+    glPushAttrib(GL_ENABLE_BIT | GL_LIGHTING | GL_COLOR);
+    glDisable(GL_LIGHTING);
+    if (! from) {
+      glColor3f(POSE_EDGE_GHOST_COLOR);
+      toTransform = to->estimate();
+      fromTransform = to->estimate()*e->measurement().inverse();
+      // DRAW THE FROM EDGE AS AN ARROW
+      glPushMatrix();
+      glTranslatef((float)fromTransform.translation().x(), (float)fromTransform.translation().y(),0.f);
+      glRotatef((float)RAD2DEG(fromTransform.rotation().angle()),0.f,0.f,1.f);
+      opengl::drawArrow2D((float)_triangleX->value(), (float)_triangleY->value(), (float)_triangleX->value()*.3f);
+      glPopMatrix();
+    } else if (! to){
+      glColor3f(POSE_EDGE_GHOST_COLOR);
+      fromTransform = from->estimate();
+      toTransform = from->estimate()*e->measurement();
+      // DRAW THE TO EDGE AS AN ARROW
+      glPushMatrix();
+      glTranslatef(toTransform.translation().x(),toTransform.translation().y(),0.f);
+      glRotatef((float)RAD2DEG(toTransform.rotation().angle()),0.f,0.f,1.f);
+      opengl::drawArrow2D((float)_triangleX->value(), (float)_triangleY->value(), (float)_triangleX->value()*.3f);
+      glPopMatrix();
+    } else {
+      glColor3f(POSE_EDGE_COLOR);
+      fromTransform = from->estimate();
+      toTransform = to->estimate();
+    }
+    glBegin(GL_LINES);
+    glVertex3f((float)fromTransform.translation().x(),(float)fromTransform.translation().y(),0.f);
+    glVertex3f((float)toTransform.translation().x(),(float)toTransform.translation().y(),0.f);
+    glEnd();
+    glPopAttrib();
+    return this;
+  }
+#endif
+
+} // end namespace
diff --git a/g2o/types/slam2d/edge_em_se2.h b/g2o/types/slam2d/edge_em_se2.h
new file mode 100644
index 00000000..a2199848
--- /dev/null
+++ b/g2o/types/slam2d/edge_em_se2.h
@@ -0,0 +1,126 @@
+// g2o - General Graph Optimization
+// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright
+//   notice, this list of conditions and the following disclaimer in the
+//   documentation and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef G2O_EDGE_EXPECTMAXIM_SE2_H
+#define G2O_EDGE_EXPECTMAXIM_SE2_H
+
+//#define NUMERIC_JACOBIAN_TWO_D_TYPES
+
+#include "vertex_se2.h"
+#include "vertex_switch.h"
+#include "parameter_switch_weight.h"
+#include "g2o/config.h"
+#include "g2o/core/base_binary_edge.h"
+#include "g2o_types_slam2d_api.h"
+
+namespace g2o {
+
+  /**
+   * \brief 2D edge between two Vertex2
+   */
+  class G2O_TYPES_SLAM2D_API EdgeSwitchSE2 : public BaseBinaryEdge<3, SE2, VertexSE2, VertexSE2>
+  {
+    public:
+      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+          EdgeSwitchSE2();
+
+      void computeError()
+      {
+        const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
+        const VertexSE2* v2 = static_cast<const VertexSE2*>(_vertices[1]);
+        SE2 delta = _inverseMeasurement * (v1->estimate().inverse()*v2->estimate());
+        delta.setRotation(Rotation2D(normalize_theta(delta.rotation().angle())));
+        _error.block<3,1>(0,0) = s * delta.toVector();
+      }
+      virtual bool read(std::istream& is);
+      virtual bool write(std::ostream& os) const;
+
+      virtual void setMeasurement(const SE2& m){
+        _measurement = m;
+        _inverseMeasurement = m.inverse();
+      }
+
+      virtual bool setMeasurementData(const number_t* d){
+        _measurement=SE2(d[0], d[1], d[2]);
+        _inverseMeasurement = _measurement.inverse();
+        return true;
+      }
+
+      virtual bool getMeasurementData(number_t* d) const {
+        Vector3 v=_measurement.toVector();
+        d[0] = v[0];
+        d[1] = v[1];
+        d[2] = v[2];
+        return true;
+      }
+
+      virtual int measurementDimension() const {return 3;}
+
+      virtual bool setMeasurementFromState() {
+        const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
+        const VertexSE2* v2 = static_cast<const VertexSE2*>(_vertices[1]);
+        _measurement = v1->estimate().inverse()*v2->estimate();
+        _inverseMeasurement = _measurement.inverse();
+        return true;
+      }
+
+
+      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& , OptimizableGraph::Vertex* ) { return 1.;}
+      virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+      virtual void linearizeOplus();
+#endif
+    protected:
+      SE2 _inverseMeasurement;
+
+  private:
+      ParameterSwitchWeight* _WeightInfo;
+      number_t info;
+      number_t s;
+  };
+
+  class G2O_TYPES_SLAM2D_API EdgeSwitchSE2WriteGnuplotAction: public WriteGnuplotAction {
+  public:
+    EdgeSwitchSE2WriteGnuplotAction();
+    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
+            HyperGraphElementAction::Parameters* params_);
+  };
+
+#ifdef G2O_HAVE_OPENGL
+  class G2O_TYPES_SLAM2D_API EdgeSwitchSE2DrawAction: public DrawAction{
+  public:
+    EdgeSwitchSE2DrawAction();
+    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
+            HyperGraphElementAction::Parameters* params_);
+  protected:
+    virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
+    FloatProperty *_triangleX, *_triangleY;
+  };
+#endif
+
+} // end namespace
+
+#endif
diff --git a/g2o/types/slam2d/edge_prox.cpp b/g2o/types/slam2d/edge_prox.cpp
new file mode 100644
<<<<<<< HEAD:0001-.patch
index 00000000..70014b09
--- /dev/null
+++ b/g2o/types/slam2d/edge_prox.cpp
@@ -0,0 +1,248 @@
=======
index 00000000..9d51058d
--- /dev/null
+++ b/g2o/types/slam2d/edge_prox.cpp
@@ -0,0 +1,159 @@
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
+// This library was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#include "edge_prox.h"
+#include <iostream>
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+  using namespace std;
+
+
+  EdgeProx::EdgeProx()
<<<<<<< HEAD:0001-.patch
+      : BaseBinaryEdge<2, array<int, 2>, VertexProx, VertexProx>() {
=======
+      : BaseBinaryEdge<2, array<int, 2>, VertexProx, VertexProx>(), _proxPair() {
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
+      information().setZero();
+      _cacheFrom = 0;
+      _cacheTo = 0;
+  }
+
+  bool EdgeProx::resolveCaches() {
+      ParameterVector pv(0);
+      resolveCache(_cacheFrom, (OptimizableGraph::Vertex*)_vertices[0],
+          "CACHE_PROX", pv);
+      resolveCache(_cacheTo, (OptimizableGraph::Vertex*)_vertices[1],
+          "CACHE_PROX", pv);
+      return (_cacheFrom && _cacheTo);
+  }
+
+  bool EdgeProx::read(std::istream& is) {
+    setMeasurementData(0);
+    if (is.bad()) return false;
<<<<<<< HEAD:0001-.patch
+    is >> _measurement[0] >> _measurement[1];
=======
+    is >> _proxPair[0] >> _proxPair[1];
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
+    double info;
+    is >> info;
+    information().setZero();
+    information()(0, 0) = info;
+    information()(1, 1) = info;
+    if (is.bad()) return false;
+    return true;
+  }
+
+  bool EdgeProx::write(std::ostream& os) const {
<<<<<<< HEAD:0001-.patch
+      os << _measurement[0] << " " << _measurement[1] << " " << information()(0, 0) << " ";
=======
+      os << _proxPair[0] << " " << _proxPair[1] << " " << information()(0, 0) << " ";
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
+      return true;
+  }
+
+  void EdgeProx::computeError() {
+      _error.setZero();
+      const int fi = fp(), ti = tp();
+      _error(0, 0) = fc()->e(fi).dot(tc()->q(ti) - fc()->q(fi));
+      _error(1, 0) = tc()->e(ti).dot(fc()->q(fi) - tc()->q(ti));
+  }
+
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+  void EdgeProx::linearizeOplus() {
+      _jacobianOplusXi.setZero();
+      _jacobianOplusXj.setZero();
+      const SE2 vi = dynamic_cast<VertexProx*>(_vertices[0])->estimate();
+      const SE2 vj = dynamic_cast<VertexProx*>(_vertices[1])->estimate();
+      const Matrix2 Ri = vi.rotation().toRotationMatrix(),
+          Rj = vj.rotation().toRotationMatrix();
+      const int fi = fp(), ti = tp();
+      _jacobianOplusXi.block<1, 2>(0, 0) = -fc()->u(fi);
+      _jacobianOplusXi(0, 2) = fc()->de(fi).dot(tc()->q(ti) - fc()->q(fi)) - fc()->e(fi).dot(fc()->dq(fi));
+      _jacobianOplusXi.block<1, 2>(1, 0) = Ri.transpose() * tc()->e(ti);
+      _jacobianOplusXi(1, 2) = tc()->e(ti).dot(fc()->dq(fi));
+      _jacobianOplusXj.block<1, 2>(0, 0) = Rj.transpose() * fc()->e(fi);
+      _jacobianOplusXj(0, 2) = fc()->e(fi).dot(tc()->dq(ti));
+      _jacobianOplusXj.block<1, 2>(1, 0) = -tc()->u(ti);
+      _jacobianOplusXj(1, 2) = tc()->de(ti).dot(fc()->q(fi) - tc()->q(ti)) - tc()->e(ti).dot(tc()->dq(ti));
+  }
+#endif
+
+  bool EdgeProx::setMeasurementFromState(){
+      //VertexSE2Proximity* from_node = static_cast<VertexSE2Proximity*>(_vertices[0]);
+      //VertexSE2Proximity* to_node = static_cast<VertexSE2Proximity*>(_vertices[1]);
+      //_measurement = from_node->estimate().inverse() * to_node->estimate();
+    return true;
+  }
+
+
+  void EdgeProx::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* /*to_*/)
+  {
+    //VertexSE2Proximity* from_node = dynamic_cast<VertexSE2Proximity*>(_vertices[0]);
+    //VertexSE2Proximity* to_node = dynamic_cast<VertexSE2Proximity*>(_vertices[1]);
+    //if (from.count(from_node) > 0)
+    //    to_node->setEstimate(from_node->estimate() * _measurement);
+    //else
+    //    from_node->setEstimate(to_node->estimate() * _measurement.inverse());
+  }
+
<<<<<<< HEAD:0001-.patch
+  bool EdgeMEstProx::read(std::istream& is) {
+      setMeasurementData(0);
+      if (is.bad()) return false;
+      double robustKernelDelta;
+      is >> _strRobustKernel >> robustKernelDelta;
+      is >> _measurement[0] >> _measurement[1];
+      double info;
+      is >> info;
+      information().setZero();
+      information()(0, 0) = info;
+      information()(1, 1) = info;
+      if (is.bad()) return false;
+      setRobustKernel(RobustKernelFactory::instance()->creator(_strRobustKernel)->construct());
+      robustKernel()->setDelta(robustKernelDelta);
+      return true;
+  }
+
+  bool EdgeMEstProx::write(std::ostream& os) const {
+      vector<string> strRobustKernels;
+      RobustKernelFactory::instance()->fillKnownKernels(strRobustKernels);
+      os << _strRobustKernel << " " << robustKernel()->delta() << " "
+          << _measurement[0] << " " << _measurement[1] << " " << information()(0, 0) << " ";
+      return true;
+  }
+
=======
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
+#ifdef G2O_HAVE_OPENGL
+  EdgeProxDrawAction::EdgeProxDrawAction()
+      : DrawAction(typeid(EdgeProx).name()), _triangleY(nullptr), _triangleZ(nullptr) {}
+
+  bool EdgeProxDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_) {
+      if (!DrawAction::refreshPropertyPtrs(params_))
+          return false;
+      if (_previousParams) {
+          _triangleY = _previousParams->makeProperty<FloatProperty>(_typeName + "::N_Edge_Width", 3.0f);
+          _triangleZ = _previousParams->makeProperty<FloatProperty>(_typeName + "::P_Edge_Width", 2.0f);
+      }
+      else {
+          _triangleY = 0;
+          _triangleZ = 0;
+      }
+      return true;
+  }
+
+  HyperGraphElementAction* EdgeProxDrawAction::operator()(HyperGraph::HyperGraphElement* element,
+      HyperGraphElementAction::Parameters* params_) {
+      if (typeid(*element).name() != _typeName)
+          return nullptr;
+
+      refreshPropertyPtrs(params_);
+      if (!_previousParams)
+          return this;
+
+      if (_show && !_show->value())
+          return this;
+
+      EdgeProx* e = static_cast<EdgeProx*>(element);
+      VertexProx* from = static_cast<VertexProx*>(e->vertex(0));
+      VertexProx* to = static_cast<VertexProx*>(e->vertex(1));
+      if (!from && !to)
+          return this;
+      SE2 fromTransform;
+      SE2 toTransform;
+      Vector2 fromProximity;
+      Vector2 toProximity;
+      glPushAttrib(GL_ENABLE_BIT | GL_LIGHTING | GL_COLOR);
+      glDisable(GL_LIGHTING);
+      fromTransform = from->estimate();
+      toTransform = to->estimate();
+      fromProximity = e->fc()->q(e->fp());
+      toProximity = e->tc()->q(e->tp());
+      if (_triangleY->value() != 0) {
+          glLineWidth((float)_triangleY->value());
+          glColor3f(POSE_EDGE_COLOR);
+          glBegin(GL_LINES);
+          glVertex3f((float)fromTransform.translation().x(), (float)fromTransform.translation().y(), 0.f);
+          glVertex3f((float)toTransform.translation().x(), (float)toTransform.translation().y(), 0.f);
+          glEnd();
+      }
+      if (_triangleZ->value() != 0) {
+          glLineWidth((float)_triangleZ->value());
+          glColor3f(LANDMARK_EDGE_COLOR);
+          glBegin(GL_LINES);
+          glVertex3f((float)fromProximity.x(), (float)fromProximity.y(), 0.f);
+          glVertex3f((float)toProximity.x(), (float)toProximity.y(), 0.f);
+          glEnd();
<<<<<<< HEAD:0001-.patch
+      }
+      glPopAttrib();
+      return this;
+  }
+
+  EdgeMEstProxDrawAction::EdgeMEstProxDrawAction()
+      : DrawAction(typeid(EdgeMEstProx).name()), _triangleY(nullptr), _triangleZ(nullptr) {}
+
+  bool EdgeMEstProxDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_) {
+      if (!DrawAction::refreshPropertyPtrs(params_))
+          return false;
+      if (_previousParams) {
+          _triangleY = _previousParams->makeProperty<FloatProperty>(_typeName + "::N_Edge_Width", 3.0f);
+          _triangleZ = _previousParams->makeProperty<FloatProperty>(_typeName + "::P_Edge_Width", 2.0f);
+      }
+      else {
+          _triangleY = 0;
+          _triangleZ = 0;
+      }
+      return true;
+  }
+
+  HyperGraphElementAction* EdgeMEstProxDrawAction::operator()(HyperGraph::HyperGraphElement* element,
+      HyperGraphElementAction::Parameters* params_) {
+      if (typeid(*element).name() != _typeName)
+          return nullptr;
+
+      refreshPropertyPtrs(params_);
+      if (!_previousParams)
+          return this;
+
+      if (_show && !_show->value())
+          return this;
+
+      EdgeMEstProx* e = static_cast<EdgeMEstProx*>(element);
+      VertexProx* from = static_cast<VertexProx*>(e->vertex(0));
+      VertexProx* to = static_cast<VertexProx*>(e->vertex(1));
+      if (!from && !to)
+          return this;
+      SE2 fromTransform;
+      SE2 toTransform;
+      Vector2 fromProximity;
+      Vector2 toProximity;
+      glPushAttrib(GL_ENABLE_BIT | GL_LIGHTING | GL_COLOR);
+      glDisable(GL_LIGHTING);
+      fromTransform = from->estimate();
+      toTransform = to->estimate();
+      fromProximity = e->fc()->q(e->fp());
+      toProximity = e->tc()->q(e->tp());
+      if (_triangleY->value() != 0) {
+          glLineWidth((float)_triangleY->value());
+          glColor3f(POSE_EDGE_COLOR);
+          glBegin(GL_LINES);
+          glVertex3f((float)fromTransform.translation().x(), (float)fromTransform.translation().y(), 0.f);
+          glVertex3f((float)toTransform.translation().x(), (float)toTransform.translation().y(), 0.f);
+          glEnd();
+      }
+      if (_triangleZ->value() != 0) {
+          glLineWidth((float)_triangleZ->value());
+          glColor3f(LANDMARK_EDGE_COLOR);
+          glBegin(GL_LINES);
+          glVertex3f((float)fromProximity.x(), (float)fromProximity.y(), 0.f);
+          glVertex3f((float)toProximity.x(), (float)toProximity.y(), 0.f);
+          glEnd();
=======
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
+      }
+      glPopAttrib();
+      return this;
+  }
+#endif
+}
diff --git a/g2o/types/slam2d/edge_prox.h b/g2o/types/slam2d/edge_prox.h
new file mode 100644
<<<<<<< HEAD:0001-.patch
index 00000000..2f0dcfcd
--- /dev/null
+++ b/g2o/types/slam2d/edge_prox.h
@@ -0,0 +1,117 @@
=======
index 00000000..339dd231
--- /dev/null
+++ b/g2o/types/slam2d/edge_prox.h
@@ -0,0 +1,92 @@
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
+// This library was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#ifndef G2O_EDGE_SE2_PROXIMITY_H_
+#define G2O_EDGE_SE2_PROXIMITY_H_
+
+//#define NUMERIC_JACOBIAN_TWO_D_TYPES
+
+#include "g2o/core/base_binary_edge.h"
+#include "vertex_prox.h"
+#include "cache_prox.h"
+#include "g2o_types_slam2d_api.h"
<<<<<<< HEAD:0001-.patch
+#include "g2o/core/robust_kernel_impl.h"
+#include "g2o/core/robust_kernel_factory.h"
+
+namespace g2o {
+
+class G2O_TYPES_SLAM2D_API EdgeProx : public BaseBinaryEdge < 2, std::array<int, 2>, VertexProx, VertexProx > {
=======
+
+namespace g2o {
+
+    class G2O_TYPES_SLAM2D_API EdgeProx : public BaseBinaryEdge < 2, std::array<int, 2>, VertexProx, VertexProx > {
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
+  public:
+      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+          EdgeProx();
+
+      virtual bool resolveCaches();
+
+      virtual bool read(std::istream& is);
+      virtual bool write(std::ostream& os) const;
+
+      void computeError();
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+      virtual void linearizeOplus();
+#endif
+
+      virtual void setMeasurement(const std::array<int, 2> m) {
+          for (int i = 0; i < 2; i++)
+              _measurement[i] = m[i];
+      }
+
+      virtual void setMeasurement(const int m[2]) {
+          for (int i = 0; i < 2; i++)
+              _measurement[i] = m[i];
+      }
+
+      virtual bool setMeasurementData(const int* d) {
+          for(int i = 0; i < 2; i++)
+              _measurement[i] = d[i];
+          return true;
+      }
+
+      virtual bool setMeasurementData(const int d) {
+          for (int i = 0; i < 2; i++)
+              _measurement[i] = d;
+          return true;
+      }
+
+      virtual bool getMeasurementData(int d[2]) const {
+          for (int i = 0; i < 2; i++)
+              d[i] = _measurement[i];
+          return true;
+      }
+
+      virtual int measurementDimension() const { return 3; }
+
+      virtual bool setMeasurementFromState();
+
+      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to) {
+          (void)to;
+          return (from.count(_vertices[0]) == 1 ? 1.0 : -1.0);
+      }
+
+      virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
+
<<<<<<< HEAD:0001-.patch
+      const virtual inline int fp() const { return _measurement[0]; };
+      const virtual inline int tp() const { return _measurement[1]; };
+      const virtual inline CacheProximity* fc() const { return _cacheFrom; };
+      const virtual inline CacheProximity* tc() const { return _cacheTo; };
+
+protected:
+    CacheProximity* _cacheFrom, * _cacheTo;
+};
+
+class G2O_TYPES_SLAM2D_API EdgeMEstProx : public EdgeProx {
+public:
+    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+        EdgeMEstProx() : EdgeProx(), _strRobustKernel(){};
+
+    virtual void setStrRobustKernel(const std::string& strRobustKernel) { _strRobustKernel = strRobustKernel; };
+
+    virtual bool read(std::istream& is);
+    virtual bool write(std::ostream& os) const;
+
+protected:
+    std::string _strRobustKernel;
=======
+      const virtual inline int fp() const { return _proxPair[0]; };
+      const virtual inline int tp() const { return _proxPair[1]; };
+      const virtual inline CacheProximity* fc() const { return _cacheFrom; };
+      const virtual inline CacheProximity* tc() const { return _cacheTo; };
+
+private:
+    std::array<int, 2> _proxPair;
+    CacheProximity* _cacheFrom, * _cacheTo;
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
+};
+
+#ifdef G2O_HAVE_OPENGL
+  class G2O_TYPES_SLAM2D_API EdgeProxDrawAction : public DrawAction {
+  public:
+      EdgeProxDrawAction();
+      virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
+          HyperGraphElementAction::Parameters* params_);
+  protected:
+      virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
+      FloatProperty* _triangleY, * _triangleZ;
<<<<<<< HEAD:0001-.patch
+  };
+
+  class G2O_TYPES_SLAM2D_API EdgeMEstProxDrawAction : public DrawAction {
+  public:
+      EdgeMEstProxDrawAction();
+      virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
+          HyperGraphElementAction::Parameters* params_);
+  protected:
+      virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
+      FloatProperty* _triangleY, * _triangleZ;
=======
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
+  };
+#endif
+
+}
+#endif
diff --git a/g2o/types/slam2d/edge_se2.cpp b/g2o/types/slam2d/edge_se2.cpp
index 0a06459a..ec28dae9 100644
--- a/g2o/types/slam2d/edge_se2.cpp
+++ b/g2o/types/slam2d/edge_se2.cpp
@@ -63,23 +63,19 @@ void EdgeSE2::initialEstimate(const OptimizableGraph::VertexSet& from,
 void EdgeSE2::linearizeOplus() {
   const VertexSE2* vi = static_cast<const VertexSE2*>(_vertices[0]);
   const VertexSE2* vj = static_cast<const VertexSE2*>(_vertices[1]);
-  number_t thetai = vi->estimate().rotation().angle();
-
+  number_t thetai = vi->estimate().rotation().angle(), 
+      thetaj = vj->estimate().rotation().angle(), 
+      thetam = measurement().rotation().angle();
   Vector2 dt = vj->estimate().translation() - vi->estimate().translation();
-  number_t si = std::sin(thetai), ci = std::cos(thetai);
-
-  _jacobianOplusXi << -ci, -si, -si * dt.x() + ci * dt.y(), si, -ci,
-      -ci * dt.x() - si * dt.y(), 0, 0, -1;
 
-  _jacobianOplusXj << ci, si, 0, -si, ci, 0, 0, 0, 1;
+  _jacobianOplusXi.setZero();
+  _jacobianOplusXi.block<2, 2>(0, 0) = -Matrix2(Rotation2D(-thetam));
+  _jacobianOplusXi.block<2, 1>(0, 2) = Matrix2(Rotation2D(-thetai - thetam - M_PI_2)) * dt;
+  _jacobianOplusXi(2, 2) = -1.;
 
-  const SE2& rmean = _inverseMeasurement;
-  Matrix3 z;
-  z.block<2, 2>(0, 0) = rmean.rotation().toRotationMatrix();
-  z.col(2) << cst(0.), cst(0.), cst(1.);
-  z.row(2).head<2>() << cst(0.), cst(0.);
-  _jacobianOplusXi = z * _jacobianOplusXi;
-  _jacobianOplusXj = z * _jacobianOplusXj;
+  _jacobianOplusXj.setZero();
+  _jacobianOplusXj.block<2, 2>(0, 0) = Matrix2(Rotation2D(thetaj - thetai - thetam));
+  _jacobianOplusXj(2, 2) = 1.;
 }
 #endif
 
diff --git a/g2o/types/slam2d/edge_se2.h b/g2o/types/slam2d/edge_se2.h
index afdf8e4e..ae47f01a 100644
--- a/g2o/types/slam2d/edge_se2.h
+++ b/g2o/types/slam2d/edge_se2.h
@@ -27,6 +27,8 @@
 #ifndef G2O_EDGE_SE2_H
 #define G2O_EDGE_SE2_H
 
+//#define NUMERIC_JACOBIAN_TWO_D_TYPES
+
 #include "g2o/config.h"
 #include "g2o/core/base_binary_edge.h"
 #include "g2o_types_slam2d_api.h"
@@ -50,6 +52,7 @@ class G2O_TYPES_SLAM2D_API EdgeSE2
         _inverseMeasurement * (v1->estimate().inverse() * v2->estimate());
     _error = delta.toVector();
   }
+  
   virtual bool read(std::istream& is);
   virtual bool write(std::ostream& os) const;
 
diff --git a/g2o/types/slam2d/edge_switch_prox.cpp b/g2o/types/slam2d/edge_switch_prox.cpp
new file mode 100644
<<<<<<< HEAD:0001-.patch
index 00000000..058ae9ca
--- /dev/null
+++ b/g2o/types/slam2d/edge_switch_prox.cpp
@@ -0,0 +1,199 @@
=======
index 00000000..e3b5d3ef
--- /dev/null
+++ b/g2o/types/slam2d/edge_switch_prox.cpp
@@ -0,0 +1,174 @@
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
+// This class was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#include "edge_switch_prox.h"
+#include <iostream>
+#include <iomanip>
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+  using namespace std;
+
+
+  // point to camera projection, monocular
+  EdgeSwitchProx::EdgeSwitchProx()
<<<<<<< HEAD:0001-.patch
+      : BaseTernaryEdge < 3, std::array<int, 2>, VertexProx, VertexProx, VertexSwitch >() {
=======
+      : BaseTernaryEdge < 3, std::array<int, 2>, VertexProx, VertexProx, VertexSwitch >(), _proxPair() {
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
+      _cacheFrom = 0;
+      _cacheTo = 0;
+    information().setZero();
+  }
+
+  bool EdgeSwitchProx::resolveCaches() {
+      ParameterVector pv(0);
+      resolveCache(_cacheFrom, (OptimizableGraph::Vertex*)_vertices[0],
+          "CACHE_PROX", pv);
+      resolveCache(_cacheTo, (OptimizableGraph::Vertex*)_vertices[1],
+          "CACHE_PROX", pv);
+      return (_cacheFrom && _cacheTo);
+  }
+
+  bool EdgeSwitchProx::resolveCaches() {
+      ParameterVector pv(0);
+      resolveCache(_cacheFrom, (OptimizableGraph::Vertex*)_vertices[0],
+          "CACHE_PROX", pv);
+      resolveCache(_cacheTo, (OptimizableGraph::Vertex*)_vertices[1],
+          "CACHE_PROX", pv);
+      return (_cacheFrom && _cacheTo);
+  }
+
+  bool EdgeSwitchProx::read(std::istream& is) {
+    setMeasurementData(0);
+    if (is.bad()) return false;
+    information().setZero();
<<<<<<< HEAD:0001-.patch
+
+    is >> _measurement[0] >> _measurement[1];
+    double info, sinfo;
+    is >> info >> sinfo;
+    information()(0, 0) = info;
+    information()(1, 1) = info;
+    information()(2, 2) = sinfo;
=======
+    if (!setParameterId(0, 0))
+        return false;
+    resolveParameters();
+    information()(2, 2) = _ProxPairWeightInfo->Info();
+
+    is >> _proxPair[0] >> _proxPair[1];
+    double info;
+    is >> info;
+    information()(0, 0) = info;
+    information()(1, 1) = info;
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
+    if (is.bad()) return false;
+    return true;
+  }
+
+  bool EdgeSwitchProx::write(std::ostream& os) const {
<<<<<<< HEAD:0001-.patch
+      os << _measurement[0] << " " << _measurement[1] << " "
+          << information()(0, 0) << " " << information()(2, 2) << " ";
=======
+      os << _proxPair[0] << " " << _proxPair[1] << " " << information()(0, 0) << " ";
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
+      return true;
+  }
+
+  void EdgeSwitchProx::computeError() {
+      _error.setZero();
+      const number_t vk = dynamic_cast<VertexSwitch*>(_vertices[2])->estimate();
+      const int fi = fp(), ti = tp();
+      _error(0, 0) = vk * fc()->e(fi).dot(tc()->q(ti) - fc()->q(fi));
+      _error(1, 0) = vk * tc()->e(ti).dot(fc()->q(fi) - tc()->q(ti));
+      _error(2, 0) = cst(1.) - vk;
+  }
+
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+  void EdgeSwitchProx::linearizeOplus() {
+      _jacobianOplusXi.setZero();
+      _jacobianOplusXj.setZero();
+      _jacobianOplusXk.setZero();
+      const SE2 vi = dynamic_cast<VertexProx*>(_vertices[0])->estimate();
+      const SE2 vj = dynamic_cast<VertexProx*>(_vertices[1])->estimate();
+      const number_t vk = dynamic_cast<VertexSwitch*>(_vertices[2])->estimate();
+      const Matrix2 Ri = vi.rotation().toRotationMatrix(),
+          Rj = vj.rotation().toRotationMatrix();
+      const int fi = fp(), ti = tp();
+      _jacobianOplusXi.block<1, 2>(0, 0) = -vk * fc()->u(fi);
+      _jacobianOplusXi(0, 2) = vk * (fc()->de(fi).dot(tc()->q(ti) - fc()->q(fi)) - fc()->e(fi).dot(fc()->dq(fi)));
+      _jacobianOplusXi.block<1, 2>(1, 0) = vk * Ri.transpose() * tc()->e(ti);
+      _jacobianOplusXi(1, 2) = vk * tc()->e(ti).dot(fc()->dq(fi));
+      _jacobianOplusXj.block<1, 2>(0, 0) = vk * Rj.transpose() * fc()->e(fi);
+      _jacobianOplusXj(0, 2) = vk * fc()->e(fi).dot(tc()->dq(ti));
+      _jacobianOplusXj.block<1, 2>(1, 0) = -vk * tc()->u(ti);
+      _jacobianOplusXj(1, 2) = vk * (tc()->de(ti).dot(fc()->q(fi) - tc()->q(ti)) - tc()->e(ti).dot(tc()->dq(ti)));
+      _jacobianOplusXk.block<2, 1>(0, 0) << cst(fc()->e(fi).dot(tc()->q(ti) - fc()->q(fi))), cst(tc()->e(ti).dot(fc()->q(fi) - tc()->q(ti)));
+      _jacobianOplusXk(2, 0) = -cst(1.);  }
+#endif
+
+  bool EdgeSwitchProx::setMeasurementFromState(){
+      //VertexSE2Proximity* from_node = static_cast<VertexSE2Proximity*>(_vertices[0]);
+      //VertexSE2Proximity* to_node = static_cast<VertexSE2Proximity*>(_vertices[1]);
+      //_measurement = from_node->estimate().inverse() * to_node->estimate();
+    return true;
+  }
+
+
+  void EdgeSwitchProx::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* /*to_*/)
+  {
+    //VertexSE2Proximity* from_node = dynamic_cast<VertexSE2Proximity*>(_vertices[0]);
+    //VertexSE2Proximity* to_node = dynamic_cast<VertexSE2Proximity*>(_vertices[1]);
+    //if (from.count(from_node) > 0)
+    //    to_node->setEstimate(from_node->estimate() * _measurement);
+    //else
+    //    from_node->setEstimate(to_node->estimate() * _measurement.inverse());
+  }
<<<<<<< HEAD:0001-.patch
+
+  // point to camera projection, monocular
+  EdgeSwitchProxSIP::EdgeSwitchProxSIP()
+      : EdgeSwitchProx() {
+      _ProxPairWeightInfo = 0;
+      resizeParameters(1);
+      installParameter(_ProxPairWeightInfo, 0);
+  }
+
+  bool EdgeSwitchProxSIP::read(std::istream& is) {
+      setMeasurementData(0);
+      if (is.bad()) return false;
+      information().setZero();
+      if (!setParameterId(0, 0))
+          return false;
+
+      is >> _measurement[0] >> _measurement[1];
+      double info;
+      is >> info;
+      information()(0, 0) = info;
+      information()(1, 1) = info;
+      information()(2, 2) = _ProxPairWeightInfo->Info();
+      if (is.bad()) return false;
+      return true;
+  }
+
+  bool EdgeSwitchProxSIP::write(std::ostream& os) const {
+      os << _measurement[0] << " " << _measurement[1] << " " << information()(0, 0) << " ";
+      return true;
+  }
=======
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
+
+#ifdef G2O_HAVE_OPENGL
+  EdgeSwitchProxDrawAction::EdgeSwitchProxDrawAction()
+      : DrawAction(typeid(EdgeSwitchProx).name()), _triangleY(nullptr), _triangleZ(nullptr) {}
+
+  bool EdgeSwitchProxDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_) {
+      if (!DrawAction::refreshPropertyPtrs(params_))
+          return false;
+      if (_previousParams) {
+          _triangleY = _previousParams->makeProperty<FloatProperty>(_typeName + "::N_Edge_Width", 3.0f);
+          _triangleZ = _previousParams->makeProperty<FloatProperty>(_typeName + "::P_Edge_Width", 2.0f);
+      }
+      else {
+          _triangleY = 0;
+          _triangleZ = 0;
+      }
+      return true;
+  }
+
+  HyperGraphElementAction* EdgeSwitchProxDrawAction::operator()(HyperGraph::HyperGraphElement* element,
+      HyperGraphElementAction::Parameters* params_) {
+      if (typeid(*element).name() != _typeName)
+          return nullptr;
+
+      refreshPropertyPtrs(params_);
+      if (!_previousParams)
+          return this;
+
+      if (_show && !_show->value())
+          return this;
+
+      EdgeSwitchProx* e = static_cast<EdgeSwitchProx*>(element);
+      VertexProx* from = static_cast<VertexProx*>(e->vertex(0));
+      VertexProx* to = static_cast<VertexProx*>(e->vertex(1));
+      if (!from && !to)
+          return this;
+      SE2 fromTransform;
+      SE2 toTransform;
+      Vector2 fromProximity;
+      Vector2 toProximity;
+      glPushAttrib(GL_ENABLE_BIT | GL_LIGHTING | GL_COLOR);
+      glDisable(GL_LIGHTING);
+      fromTransform = from->estimate();
+      toTransform = to->estimate();
+      fromProximity = e->fc()->q(e->fp());
+      toProximity = e->tc()->q(e->tp());
+      if (_triangleY->value() != 0) {
+          glLineWidth((float)_triangleY->value());
+          glColor3f(POSE_EDGE_COLOR);
+          glBegin(GL_LINES);
+          glVertex3f((float)fromTransform.translation().x(), (float)fromTransform.translation().y(), 0.f);
+          glVertex3f((float)toTransform.translation().x(), (float)toTransform.translation().y(), 0.f);
+          glEnd();
+      }
+      if (_triangleZ->value() != 0) {
+          glLineWidth((float)_triangleZ->value());
+          glColor3f(LANDMARK_EDGE_COLOR);
+          glBegin(GL_LINES);
+          glVertex3f((float)fromProximity.x(), (float)fromProximity.y(), 0.f);
+          glVertex3f((float)toProximity.x(), (float)toProximity.y(), 0.f);
+          glEnd();
+      }
+      glPopAttrib();
+      return this;
+  }
+#endif
+}
diff --git a/g2o/types/slam2d/edge_switch_prox.h b/g2o/types/slam2d/edge_switch_prox.h
new file mode 100644
<<<<<<< HEAD:0001-.patch
index 00000000..4a396017
--- /dev/null
+++ b/g2o/types/slam2d/edge_switch_prox.h
@@ -0,0 +1,104 @@
=======
index 00000000..649c357b
--- /dev/null
+++ b/g2o/types/slam2d/edge_switch_prox.h
@@ -0,0 +1,94 @@
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
+// This class was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#ifndef G2O_EDGE_SWITCHING_PROX_H_
+#define G2O_EDGE_SWITCHING_PROX_H_
+
+//#define NUMERIC_JACOBIAN_TWO_D_TYPES
+
+#include "g2o/core/base_ternary_edge.h"
+#include "vertex_prox.h"
+#include "vertex_switch.h"
+#include "cache_prox.h"
+#include "parameter_switch_weight.h"
+#include "g2o_types_slam2d_api.h"
+
+namespace g2o {
+    class G2O_TYPES_SLAM2D_API EdgeSwitchProx : public BaseTernaryEdge < 3, std::array<int, 2>, VertexProx, VertexProx, VertexSwitch > {
+  public:
+      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+          EdgeSwitchProx();
+
+      virtual bool resolveCaches();
+
+      virtual bool read(std::istream& is);
+      virtual bool write(std::ostream& os) const;
+
+      void computeError();
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+      virtual void linearizeOplus();
+#endif
+
+      virtual void setMeasurement(const std::array<int, 2> m) {
+          for (int i = 0; i < 2; i++)
+              _measurement[i] = m[i];
+      }
+
+      virtual void setMeasurement(const int m[2]) {
+          for (int i = 0; i < 2; i++)
+              _measurement[i] = m[i];
+      }
+
+      virtual bool setMeasurementData(const int* d) {
+          for(int i = 0; i < 2; i++)
+              _measurement[i] = d[i];
+          return true;
+      }
+
+      virtual bool setMeasurementData(const int d) {
+          for (int i = 0; i < 2; i++)
+              _measurement[i] = d;
+          return true;
+      }
+
+      virtual bool getMeasurementData(int d[2]) const {
+          for (int i = 0; i < 2; i++)
+              d[i] = _measurement[i];
+          return true;
+      }
+
+      virtual int measurementDimension() const { return 3; }
+
+      virtual bool setMeasurementFromState();
+
+      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to) {
+          (void)to;
+          return (from.count(_vertices[0]) == 1 ? 1.0 : -1.0);
+      }
+
+      virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
+
+      const virtual inline int fp() const { return _measurement[0]; };
+      const virtual inline int tp() const { return _measurement[1]; };
+      const virtual inline CacheProximity* fc() const { return _cacheFrom; };
+      const virtual inline CacheProximity* tc() const { return _cacheTo; };
+
+  protected:
+      CacheProximity* _cacheFrom, * _cacheTo;
+  };
+
+    class G2O_TYPES_SLAM2D_API EdgeSwitchProxSIP : public EdgeSwitchProx {
+    public:
+        EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+            EdgeSwitchProxSIP();
+
<<<<<<< HEAD:0001-.patch
+        virtual bool read(std::istream& is);
+        virtual bool write(std::ostream& os) const;
+
+    private:
+        ParameterSwitchWeight* _ProxPairWeightInfo;
+    };
=======
+      const virtual inline int fp() const { return _proxPair[0]; };
+      const virtual inline int tp() const { return _proxPair[1]; };
+      const virtual inline CacheProximity* fc() const { return _cacheFrom; };
+      const virtual inline CacheProximity* tc() const { return _cacheTo; };
+
+  private:
+      int _proxPair[2];
+      ParameterSwitchWeight* _ProxPairWeightInfo;
+      CacheProximity* _cacheFrom, * _cacheTo;
+  };
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
+
+#ifdef G2O_HAVE_OPENGL
+  class G2O_TYPES_SLAM2D_API EdgeSwitchProxDrawAction : public DrawAction {
+  public:
+      EdgeSwitchProxDrawAction();
+      virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
+          HyperGraphElementAction::Parameters* params_);
+  protected:
+      virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
+      FloatProperty* _triangleY, * _triangleZ;
+  };
+#endif
+
+}
+#endif
diff --git a/g2o/types/slam2d/edge_switch_se2.cpp b/g2o/types/slam2d/edge_switch_se2.cpp
new file mode 100644
index 00000000..5f7a255b
--- /dev/null
+++ b/g2o/types/slam2d/edge_switch_se2.cpp
@@ -0,0 +1,228 @@
+// g2o - General Graph Optimization
+// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright
+//   notice, this list of conditions and the following disclaimer in the
+//   documentation and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "edge_switch_se2.h"
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+
+  EdgeSwitchSE2::EdgeSwitchSE2() :
+      BaseTernaryEdge<4, SE2, VertexSE2, VertexSE2, VertexSwitch>() {}
+
+  bool EdgeSwitchSE2::read(std::istream& is)
+  {
+    Vector3 p;
+    internal::readVector(is, p);
+    setMeasurement(SE2(p));
+    _inverseMeasurement = measurement().inverse();
+    information().setZero();
+    for (int i = 0; i < 3 && is.good(); ++i)
+        for (int j = i; j < 3 && is.good(); ++j) {
+            is >> information()(i, j);
+            if (i != j) information()(j, i) = information()(i, j);
+        }
+    is >> information()(3, 3);
+    return true;
+  }
+
+  bool EdgeSwitchSE2::write(std::ostream& os) const
+  {
+    internal::writeVector(os, measurement().toVector());
+    for (int i = 0; i < 3; ++i)
+        for (int j = i; j < 3; ++j)
+            os << information()(i, j) << " ";
+    os << information()(3, 3) << " ";
+    return true;
+  }
+
+  void EdgeSwitchSE2::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* /* to */)
+  {
+    VertexSE2* fromEdge = static_cast<VertexSE2*>(_vertices[0]);
+    VertexSE2* toEdge   = static_cast<VertexSE2*>(_vertices[1]);
+    if (from.count(fromEdge) > 0)
+      toEdge->setEstimate(fromEdge->estimate() * _measurement);
+    else
+      fromEdge->setEstimate(toEdge->estimate() * _inverseMeasurement);
+  }
+
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+  void EdgeSwitchSE2::linearizeOplus()
+  {
+      const VertexSE2* vi = static_cast<const VertexSE2*>(_vertices[0]);
+      const VertexSE2* vj = static_cast<const VertexSE2*>(_vertices[1]);
+      const VertexSwitch* s = static_cast<const VertexSwitch*>(_vertices[2]);
+      SE2 delta = _inverseMeasurement * (vi->estimate().inverse() * vj->estimate());
+      delta.setRotation(Rotation2D(normalize_theta(delta.rotation().angle())));
+
+      Vector2 dt = vj->estimate().translation() - vi->estimate().translation();
+      Matrix2 dR = vi->estimate().rotation().toRotationMatrix().transpose() * vj->estimate().rotation().toRotationMatrix();
+      const SE2& rmean = _inverseMeasurement;
+      Vector2 z = rmean.rotation().toRotationMatrix() * vi->estimate().rotation().toRotationMatrix().transpose() * dt;
+
+      _jacobianOplusXi.setZero();
+      _jacobianOplusXi.block<2, 2>(0, 0) = - s->estimate() * rmean.rotation().toRotationMatrix();
+      _jacobianOplusXi.col(2) = s->estimate() * Vector4{ z.y(), -z.x(), -1., 0. };
+      _jacobianOplusXj.setZero();
+      _jacobianOplusXj.block<2, 2>(0, 0) = s->estimate() * rmean.rotation().toRotationMatrix() * dR;
+      _jacobianOplusXj(2,2) = s->estimate();
+      _jacobianOplusXk << delta.toVector(), -cst(1.);
+  }
+#endif
+
+  EdgeSwitchSE2SIP::EdgeSwitchSE2SIP() : EdgeSwitchSE2()
+  {
+      _WeightInfo = 0;
+      resizeParameters(1);
+      installParameter(_WeightInfo, 0);
+  }
+
+  bool EdgeSwitchSE2SIP::read(std::istream& is)
+  {
+      Vector3 p;
+      internal::readVector(is, p);
+      setMeasurement(SE2(p));
+      _inverseMeasurement = measurement().inverse();
+      information().setZero();
+      for (int i = 0; i < 3 && is.good(); ++i)
+          for (int j = i; j < 3 && is.good(); ++j) {
+              is >> information()(i, j);
+              if (i != j) information()(j, i) = information()(i, j);
+          }
+      if (!setParameterId(0, 0))
+          return false;
+      resolveParameters();
+      information()(3, 3) = _WeightInfo->Info();
+      return true;
+  }
+
+  bool EdgeSwitchSE2SIP::write(std::ostream& os) const
+  {
+      internal::writeVector(os, measurement().toVector());
+      for (int i = 0; i < 3; ++i)
+          for (int j = i; j < 3; ++j)
+              os << information()(i, j);
+      return true;
+  }
+
+  EdgeSwitchSE2WriteGnuplotAction::EdgeSwitchSE2WriteGnuplotAction(): WriteGnuplotAction(typeid(EdgeSwitchSE2).name()){}
+
+  HyperGraphElementAction* EdgeSwitchSE2WriteGnuplotAction::operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* params_){
+    if (typeid(*element).name()!=_typeName)
+      return nullptr;
+    WriteGnuplotAction::Parameters* params=static_cast<WriteGnuplotAction::Parameters*>(params_);
+    if (!params->os){
+      std::cerr << __PRETTY_FUNCTION__ << ": warning, on valid os specified" << std::endl;
+      return nullptr;
+    }
+
+    EdgeSwitchSE2* e =  static_cast<EdgeSwitchSE2*>(element);
+    VertexSE2* fromEdge = static_cast<VertexSE2*>(e->vertex(0));
+    VertexSE2* toEdge   = static_cast<VertexSE2*>(e->vertex(1));
+    *(params->os) << fromEdge->estimate().translation().x() << " " << fromEdge->estimate().translation().y()
+      << " " << fromEdge->estimate().rotation().angle() << std::endl;
+    *(params->os) << toEdge->estimate().translation().x() << " " << toEdge->estimate().translation().y()
+      << " " << toEdge->estimate().rotation().angle() << std::endl;
+    *(params->os) << std::endl;
+    return this;
+  }
+
+#ifdef G2O_HAVE_OPENGL
+  EdgeSwitchSE2DrawAction::EdgeSwitchSE2DrawAction()
+      : DrawAction(typeid(EdgeSwitchSE2).name()), _triangleX(nullptr), _triangleY(nullptr) {}
+
+  bool EdgeSwitchSE2DrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_){
+    if (!DrawAction::refreshPropertyPtrs(params_))
+      return false;
+    if (_previousParams){
+      _triangleX = _previousParams->makeProperty<FloatProperty>(_typeName + "::GHOST_TRIANGLE_X", .2f);
+      _triangleY = _previousParams->makeProperty<FloatProperty>(_typeName + "::GHOST_TRIANGLE_Y", .05f);
+    } else {
+      _triangleX = 0;
+      _triangleY = 0;
+    }
+    return true;
+  }
+
+  HyperGraphElementAction* EdgeSwitchSE2DrawAction::operator()(HyperGraph::HyperGraphElement* element,
+               HyperGraphElementAction::Parameters* params_){
+    if (typeid(*element).name()!=_typeName)
+      return nullptr;
+
+    refreshPropertyPtrs(params_);
+    if (! _previousParams)
+      return this;
+
+    if (_show && !_show->value())
+      return this;
+
+    EdgeSwitchSE2* e =  static_cast<EdgeSwitchSE2*>(element);
+    VertexSE2* from = static_cast<VertexSE2*>(e->vertex(0));
+    VertexSE2* to   = static_cast<VertexSE2*>(e->vertex(1));
+    if (! from && ! to)
+      return this;
+    SE2 fromTransform;
+    SE2 toTransform;
+    glPushAttrib(GL_ENABLE_BIT | GL_LIGHTING | GL_COLOR);
+    glDisable(GL_LIGHTING);
+    if (! from) {
+      glColor3f(POSE_EDGE_GHOST_COLOR);
+      toTransform = to->estimate();
+      fromTransform = to->estimate()*e->measurement().inverse();
+      // DRAW THE FROM EDGE AS AN ARROW
+      glPushMatrix();
+      glTranslatef((float)fromTransform.translation().x(), (float)fromTransform.translation().y(),0.f);
+      glRotatef((float)RAD2DEG(fromTransform.rotation().angle()),0.f,0.f,1.f);
+      opengl::drawArrow2D((float)_triangleX->value(), (float)_triangleY->value(), (float)_triangleX->value()*.3f);
+      glPopMatrix();
+    } else if (! to){
+      glColor3f(POSE_EDGE_GHOST_COLOR);
+      fromTransform = from->estimate();
+      toTransform = from->estimate()*e->measurement();
+      // DRAW THE TO EDGE AS AN ARROW
+      glPushMatrix();
+      glTranslatef(toTransform.translation().x(),toTransform.translation().y(),0.f);
+      glRotatef((float)RAD2DEG(toTransform.rotation().angle()),0.f,0.f,1.f);
+      opengl::drawArrow2D((float)_triangleX->value(), (float)_triangleY->value(), (float)_triangleX->value()*.3f);
+      glPopMatrix();
+    } else {
+      glColor3f(POSE_EDGE_COLOR);
+      fromTransform = from->estimate();
+      toTransform = to->estimate();
+    }
+    glBegin(GL_LINES);
+    glVertex3f((float)fromTransform.translation().x(),(float)fromTransform.translation().y(),0.f);
+    glVertex3f((float)toTransform.translation().x(),(float)toTransform.translation().y(),0.f);
+    glEnd();
+    glPopAttrib();
+    return this;
+  }
+#endif
+
+} // end namespace
diff --git a/g2o/types/slam2d/edge_switch_se2.h b/g2o/types/slam2d/edge_switch_se2.h
new file mode 100644
index 00000000..4d0afffc
--- /dev/null
+++ b/g2o/types/slam2d/edge_switch_se2.h
@@ -0,0 +1,136 @@
+// g2o - General Graph Optimization
+// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright
+//   notice, this list of conditions and the following disclaimer in the
+//   documentation and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef G2O_EDGE_SWITCHING_SE2_H
+#define G2O_EDGE_SWITCHING_SE2_H
+
+//#define NUMERIC_JACOBIAN_TWO_D_TYPES
+
+#include "vertex_se2.h"
+#include "vertex_switch.h"
+#include "parameter_switch_weight.h"
+#include "g2o/config.h"
+#include "g2o/core/base_ternary_edge.h"
+#include "g2o_types_slam2d_api.h"
+
+namespace g2o {
+
+  /**
+   * \brief 2D edge between two Vertex2
+   */
+  class G2O_TYPES_SLAM2D_API EdgeSwitchSE2 : public BaseTernaryEdge<4, SE2, VertexSE2, VertexSE2, VertexSwitch>
+  {
+    public:
+      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+          EdgeSwitchSE2();
+
+      void computeError()
+      {
+        const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
+        const VertexSE2* v2 = static_cast<const VertexSE2*>(_vertices[1]);
+        const VertexSwitch* s = static_cast<const VertexSwitch*>(_vertices[2]);
+        SE2 delta = _inverseMeasurement * (v1->estimate().inverse()*v2->estimate());
+        delta.setRotation(Rotation2D(normalize_theta(delta.rotation().angle())));
+        _error.block<3,1>(0,0) = s->estimate() * delta.toVector();
+        _error(3, 0) = cst(1.) - s->estimate();
+      }
+      virtual bool read(std::istream& is);
+      virtual bool write(std::ostream& os) const;
+
+      virtual void setMeasurement(const SE2& m){
+        _measurement = m;
+        _inverseMeasurement = m.inverse();
+      }
+
+      virtual bool setMeasurementData(const number_t* d){
+        _measurement=SE2(d[0], d[1], d[2]);
+        _inverseMeasurement = _measurement.inverse();
+        return true;
+      }
+
+      virtual bool getMeasurementData(number_t* d) const {
+        Vector3 v=_measurement.toVector();
+        d[0] = v[0];
+        d[1] = v[1];
+        d[2] = v[2];
+        return true;
+      }
+
+      virtual int measurementDimension() const {return 3;}
+
+      virtual bool setMeasurementFromState() {
+        const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
+        const VertexSE2* v2 = static_cast<const VertexSE2*>(_vertices[1]);
+        _measurement = v1->estimate().inverse()*v2->estimate();
+        _inverseMeasurement = _measurement.inverse();
+        return true;
+      }
+
+
+      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& , OptimizableGraph::Vertex* ) { return 1.;}
+      virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+      virtual void linearizeOplus();
+#endif
+    protected:
+      SE2 _inverseMeasurement;
+  };
+
+  class G2O_TYPES_SLAM2D_API EdgeSwitchSE2SIP : public EdgeSwitchSE2
+  {
+  public:
+      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+          EdgeSwitchSE2SIP();
+
+      virtual bool read(std::istream& is);
+      virtual bool write(std::ostream& os) const;
+
+  private:
+      ParameterSwitchWeight* _WeightInfo;
+  };
+
+  class G2O_TYPES_SLAM2D_API EdgeSwitchSE2WriteGnuplotAction: public WriteGnuplotAction {
+  public:
+    EdgeSwitchSE2WriteGnuplotAction();
+    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
+            HyperGraphElementAction::Parameters* params_);
+  };
+
+#ifdef G2O_HAVE_OPENGL
+  class G2O_TYPES_SLAM2D_API EdgeSwitchSE2DrawAction: public DrawAction{
+  public:
+    EdgeSwitchSE2DrawAction();
+    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
+            HyperGraphElementAction::Parameters* params_);
+  protected:
+    virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
+    FloatProperty *_triangleX, *_triangleY;
+  };
+#endif
+
+} // end namespace
+
+#endif
diff --git a/g2o/types/slam2d/parameter_em.cpp b/g2o/types/slam2d/parameter_em.cpp
new file mode 100644
index 00000000..55d95599
--- /dev/null
+++ b/g2o/types/slam2d/parameter_em.cpp
@@ -0,0 +1,63 @@
+#include "parameter_em.h"
+
+#include "g2o/core/io_helper.h"
+#include "vertex_se2.h"
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#endif
+
+namespace g2o {
+
+ParameterEM::ParameterEM() { setSwitch(); }
+
+void ParameterEM::setSwitch(const number_t& switch_) {
+    _switch = switch_;
+}
+
+bool ParameterEM::read(std::istream& is) {
+
+    number_t switch_;
+    is >> switch_;
+    if (is.bad()) return false;
+    setSwitch(switch_);
+    return true;
+}
+
+bool ParameterEM::write(std::ostream& os) const {
+    os << Switch();
+    return true;
+}
+
+CacheEM::CacheEM() : Cache(), _switchVariable(1.) {}
+
+bool CacheEM::resolveDependencies() {
+    return Cache::resolveDependancies();
+}
+
+void CacheEM::updateImpl() {
+    const VertexSE2* v = static_cast<const VertexSE2*>(vertex());
+    _se2_n2w = v->estimate() * _offsetParam->offset();
+
+    _n2w = _se2_n2w.rotation().toRotationMatrix();
+    _n2w.translation() = _se2_n2w.translation();
+
+    _se2_w2n = _se2_n2w.inverse();
+    _w2n = _se2_w2n.rotation().toRotationMatrix();
+    _w2n.translation() = _se2_w2n.translation();
+
+    SE2 w2l = v->estimate().inverse();
+    _w2l = w2l.rotation().toRotationMatrix();
+    _w2l.translation() = w2l.translation();
+
+    number_t alpha = v->estimate().rotation().angle();
+    number_t c = std::cos(alpha), s = std::sin(alpha);
+    Matrix2 RInversePrime;
+    RInversePrime << -s, c, -c, -s;
+    _RpInverse_RInversePrime =
+        _offsetParam->offset().rotation().toRotationMatrix().transpose() *
+        RInversePrime;
+    _RpInverse_RInverse = w2l.rotation();
+}
+
+}  // namespace g2o
\ No newline at end of file
diff --git a/g2o/types/slam2d/parameter_em.h b/g2o/types/slam2d/parameter_em.h
new file mode 100644
index 00000000..1294062d
--- /dev/null
+++ b/g2o/types/slam2d/parameter_em.h
@@ -0,0 +1,58 @@
+// This class was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#ifndef G2O_PARAMETERS_EM_H_
+#define G2O_PARAMETERS_EM_H_
+
+#include "g2o/core/cache.h"
+#include "g2o_types_slam2d_api.h"
+#include "se2.h"
+
+namespace g2o {
+
+class VertexSE2;
+
+/**
+    * \brief offset for an SE2
+    */
+class G2O_TYPES_SLAM2D_API ParameterEM : public Parameter {
+public:
+    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
+    ParameterEM();
+
+    virtual bool read(std::istream& is);
+    virtual bool write(std::ostream& os) const;
+
+    /**
+        * update the offset to a new value.
+        * re-calculates the different representations, e.g., the rotation matrix
+        */
+    void setSwitch(const number_t& switch_ = 0.);
+
+    const number_t& Switch() const { return _switch; }
+
+protected:
+    number_t _switch;
+};
+
+/**
+    * \brief caching the offset related to a vertex
+    */
+class G2O_TYPES_SLAM2D_API CacheEM : public Cache {
+public:
+    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
+    CacheEM();
+    virtual void updateImpl();
+
+    void setSwitch(const number_t& switch_ = 0.) { _switchVariable = switch_; }
+    const number_t& Switch() const { return _switchVariable; }
+
+protected:
+    number_t _switchVariable;  ///< the parameter connected to the cache
+
+protected:
+    virtual bool resolveDependencies();
+};
+
+}  // namespace g2o
+
+#endif
\ No newline at end of file
diff --git a/g2o/types/slam2d/parameter_em_prox.cpp b/g2o/types/slam2d/parameter_em_prox.cpp
new file mode 100644
index 00000000..77791749
--- /dev/null
+++ b/g2o/types/slam2d/parameter_em_prox.cpp
@@ -0,0 +1,311 @@
+// This class was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#include "edge_switch_prox.h"
+#include <iostream>
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+  using namespace std;
+
+
+  // point to camera projection, monocular
+  EdgeSwitchProx::EdgeSwitchProx()
+      : BaseTernaryEdge < 3 * prox_maxN, std::array<int, 2 * prox_maxN>, VertexProx, VertexProx, VertexSwitchProxPair >(), _num_prox_pairs(0), _prox_pairs(), info(1.) {
+      memset(_prox_pairs[0], 0, prox_maxN);
+      memset(_prox_pairs[1], 0, prox_maxN);
+    information().setZero();
+    _ProxPairWeightInfo = 0;
+    resizeParameters(1);
+    installParameter(_ProxPairWeightInfo, 0);
+  }
+
+  bool EdgeSwitchProx::read(std::istream& is) {
+    // measured keypoint
+    setMeasurementData(0);
+    if (is.bad()) return false;
+    //readInformationMatrix(is);
+    //  we overwrite the information matrix in case of read errors
+    //if (is.bad()) information().setIdentity();
+    information().setZero();
+    _num_prox_pairs = 0;
+    if (!setParameterId(0, 0))
+        return false;
+    resolveParameters();
+    info = _ProxPairWeightInfo->Info();
+    for(int i = 0; i < prox_maxN; i++)
+        information()(2 * prox_maxN + i, 2 * prox_maxN + i) = info;
+
+    int n;
+    is >> n;
+    for (int i = 0; i < n && i < prox_maxN; i++) {
+        is >> _prox_pairs[0][i] >> _prox_pairs[1][i];
+        double info;
+        is >> info;
+        information()(2*i, 2*i) = info;
+        information()(2*i+1, 2*i+1) = info;
+        if (is.bad()) return false;
+        _num_prox_pairs = i + 1;
+    }
+    return true;
+  }
+
+  bool EdgeSwitchProx::write(std::ostream& os) const {
+      int n = _num_prox_pairs;
+      os << _num_prox_pairs << " ";
+      for (int i = 0; i < _num_prox_pairs && i < prox_maxN; i++)
+          os << _prox_pairs[0][i] << " " << _prox_pairs[1][i] << " " << information()(2*i, 2*i) << " ";
+      return true;
+  }
+
+  void EdgeSwitchProx::computeError() {
+      const SE2 vi = dynamic_cast<VertexProx*>(_vertices[0])->estimate();
+      const SE2 vj = dynamic_cast<VertexProx*>(_vertices[1])->estimate();
+      //const std::array<number_t, prox_maxN> vk = sigmoid_est();
+      const std::array<number_t, prox_maxN> vk = dynamic_cast<VertexSwitchProxPair*>(_vertices[2])->estimate();
+      for (int k = 0; k < _num_prox_pairs && k < prox_maxN; k++) {
+          const Vector2 ri = from_prox(k),  rj = to_prox(k), qi = from_gr_prox(k), qj = to_gr_prox(k);
+          if (ri == Vector2() || rj == Vector2() || qi == Vector2() || qj == Vector2()) continue;
+          const Vector2 ei = vi.rotation() * ri, ej = vj.rotation() * rj;
+          const number_t li = cst((ei / ri.norm()).dot(qj - qi)), lj = cst((ej / rj.norm()).dot(qi - qj));
+          _error.block<2, 1>(2 * k, 0) << li * vk[k], lj * vk[k];
+      }
+      for (int k = 0; k < prox_maxN; k++)
+          _error(2 * prox_maxN + k) = cst(1.) - vk[k];
+          //_error(2 * prox_maxN + k) = cst(1.) - sqrt(fabs(vk[k]));
+  }
+
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+  void EdgeSwitchProx::linearizeOplus() {
+      _jacobianOplusXi.setZero();
+      _jacobianOplusXj.setZero();
+      _jacobianOplusXk.setZero();
+      const SE2 vi = dynamic_cast<VertexProx*>(_vertices[0])->estimate();
+      const SE2 vj = dynamic_cast<VertexProx*>(_vertices[1])->estimate();
+      //const std::array<number_t, prox_maxN> vk = sigmoid_est();
+      //const std::array<number_t, prox_maxN> dvk = def_sig_est();
+      const std::array<number_t, prox_maxN> vk = dynamic_cast<VertexSwitchProxPair*>(_vertices[2])->estimate();
+      const Vector2 dt = vj.translation() - vi.translation();
+      const Matrix2 Ri = vi.rotation().toRotationMatrix(),
+          Rj = vj.rotation().toRotationMatrix(),
+          dR = Ri.transpose() * Rj;
+      for (int k = 0; k < _num_prox_pairs && k < prox_maxN; k++) {
+          const Vector2 ri = from_prox(k), rj = to_prox(k), qi = from_gr_prox(k), qj = to_gr_prox(k);
+          if (ri == Vector2() || rj == Vector2() || qi == Vector2() || qj == Vector2()) continue;
+          const number_t ni = 1. / ri.norm(), nj = 1. / rj.norm();
+          const Vector2 ei = vi.rotation() * ri, ej = vj.rotation() * rj;
+          const number_t li = cst((ei * ni).dot(qj - qi)), lj = cst((ej * nj).dot(qi - qj));
+          Vector2 z;
+
+          _jacobianOplusXi.block<1, 2>(2*k, 0) = -ri;
+          _jacobianOplusXj.block<1, 2>(2*k, 0) = dR.transpose() * ri;
+          z = dR * rj + Ri.transpose() * dt;
+          _jacobianOplusXi(2*k, 2) = ri.x() * z.y() - ri.y() * z.x();
+          z = dR * rj;
+          _jacobianOplusXj(2*k, 2) = -ri.x() * z.y() + ri.y() * z.x();
+          _jacobianOplusXi.block<1, 3>(2*k, 0) = _jacobianOplusXi.block<1, 3>(2*k, 0) * ni * vk[k];
+          _jacobianOplusXj.block<1, 3>(2*k, 0) = _jacobianOplusXj.block<1, 3>(2*k, 0) * ni * vk[k];
+          _jacobianOplusXj.block<1, 2>(2*k+1, 0) = -rj;
+          _jacobianOplusXi.block<1, 2>(2*k+1, 0) = dR * rj;
+          z = dR.transpose() * ri - Rj.transpose() * dt;
+          _jacobianOplusXj(2*k+1, 2) = rj.x() * z.y() - rj.y() * z.x();
+          z = dR.transpose() * ri;
+          _jacobianOplusXi(2*k+1, 2) = -rj.x() * z.y() + rj.y() * z.x();
+          _jacobianOplusXj.block<1, 3>(2*k+1, 0) = _jacobianOplusXj.block<1, 3>(2*k+1, 0) * nj * vk[k];
+          _jacobianOplusXi.block<1, 3>(2*k+1, 0) = _jacobianOplusXi.block<1, 3>(2*k+1, 0) * nj * vk[k];
+          _jacobianOplusXk.block<2, 1>(2 * k, k) << li, lj;
+          //_jacobianOplusXk.block<2, 1>(2 * k, k) << li * dvk[k], lj * dvk[k];
+      }
+      for (int k = 0; k < prox_maxN; k++)
+          _jacobianOplusXk(2 * prox_maxN + k, k) = cst(-1.);
+          //_jacobianOplusXk(2 * prox_maxN + k, k) = -sign(vk[k]) / (2. * sqrt(fabs(vk[k])));
+          //_jacobianOplusXk(2 * prox_maxN + k, k) = -dvk[k];
+
+      /*
+      cout << this->id() << " : " << _vertices[0]->id() << endl;
+      for (int i = 0; i < 20; i++) {
+          if (_jacobianOplusXi.col(0)[i] == 0.) break;
+          cout << _jacobianOplusXi.col(0)[i] << ", ";
+      }
+      cout << endl;
+      for (int i = 0; i < 20; i++) {
+          if (_jacobianOplusXi.col(1)[i] == 0.) break;
+          cout << _jacobianOplusXi.col(1)[i] << ", ";
+      }
+      cout << endl;
+      for (int i = 0; i < 20; i++) {
+          if (_jacobianOplusXi.col(2)[i] == 0.) break;
+          cout << _jacobianOplusXi.col(2)[i] << ", ";
+      }
+      cout << endl << endl;
+      cout << this->id() << " : " << _vertices[1]->id() << endl;
+      for (int i = 0; i < 20; i++) {
+          if (_jacobianOplusXj.col(0)[i] == 0.) break;
+          cout << _jacobianOplusXj.col(0)[i] << ", ";
+      }
+      cout << endl;
+      for (int i = 0; i < 20; i++) {
+          if (_jacobianOplusXj.col(1)[i] == 0.) break;
+          cout << _jacobianOplusXj.col(1)[i] << ", ";
+      }
+      cout << endl;
+      for (int i = 0; i < 20; i++) {
+          if (_jacobianOplusXj.col(2)[i] == 0.) break;
+          cout << _jacobianOplusXj.col(2)[i] << ", ";
+      }
+      cout << endl << endl;
+      */
+  }
+#endif
+
+  bool EdgeSwitchProx::setMeasurementFromState(){
+      /*
+      VertexSE2Proximity* from_node = static_cast<VertexSE2Proximity*>(_vertices[0]);
+      VertexSE2Proximity* to_node = static_cast<VertexSE2Proximity*>(_vertices[1]);
+      
+      _measurement = from_node->estimate().inverse() * to_node->estimate();
+      */
+    return true;
+  }
+
+
+  void EdgeSwitchProx::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* /*to_*/)
+  {
+    /*
+    VertexSE2Proximity* from_node = dynamic_cast<VertexSE2Proximity*>(_vertices[0]);
+    VertexSE2Proximity* to_node = dynamic_cast<VertexSE2Proximity*>(_vertices[1]);
+    if (from.count(from_node) > 0)
+        to_node->setEstimate(from_node->estimate() * _measurement);
+    else
+        from_node->setEstimate(to_node->estimate() * _measurement.inverse());
+    */
+  }
+
+  inline Vector2 EdgeSwitchProx::from_prox(int i) const {
+      if (0 <= i && i < _num_prox_pairs)
+          return dynamic_cast<VertexProx*>(_vertices[0])->proximity(_prox_pairs[0][i]);
+      cerr << "out of range" << endl;
+      return Vector2();
+  };
+  inline Vector2 EdgeSwitchProx::to_prox(int i) const {
+      if (0 <= i && i < _num_prox_pairs)
+          return dynamic_cast<VertexProx*>(_vertices[1])->proximity(_prox_pairs[1][i]);
+      cerr << "out of range" << endl;
+      return Vector2();
+  };
+  inline Vector2 EdgeSwitchProx::from_gr_prox(int i) const {
+      if (0 <= i && i < _num_prox_pairs) {
+          Vector2 fp = from_prox(i);
+          if (fp == Vector2()) return Vector2();
+          return (dynamic_cast<VertexProx*>(_vertices[0])->estimate() * fp);
+      }
+      cerr << "out of range" << endl;
+      return Vector2();
+  };
+  inline Vector2 EdgeSwitchProx::to_gr_prox(int i) const {
+      if (0 <= i && i < _num_prox_pairs) {
+          Vector2 tp = to_prox(i);
+          if (tp == Vector2()) return Vector2();
+          return (dynamic_cast<VertexProx*>(_vertices[1])->estimate() * tp);
+      }
+      cerr << "out of range" << endl;
+      return Vector2();
+  };
+
+#ifdef G2O_HAVE_OPENGL
+  EdgeSwitchProxDrawAction::EdgeSwitchProxDrawAction()
+      : DrawAction(typeid(EdgeSwitchProx).name()), _triangleX(nullptr), _triangleY(nullptr), _triangleZ(nullptr) {}
+
+  bool EdgeSwitchProxDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_) {
+      if (!DrawAction::refreshPropertyPtrs(params_))
+          return false;
+      if (_previousParams) {
+          _triangleX = _previousParams->makeProperty<FloatProperty>(_typeName + "::N_Edge_Arrow_Length", .0f);
+          _triangleY = _previousParams->makeProperty<FloatProperty>(_typeName + "::N_Edge_Width", 3.0f);
+          _triangleZ = _previousParams->makeProperty<FloatProperty>(_typeName + "::P_Edge_Width", 2.0f);
+      }
+      else {
+          _triangleX = 0;
+          _triangleY = 0;
+          _triangleZ = 0;
+      }
+      return true;
+  }
+
+  HyperGraphElementAction* EdgeSwitchProxDrawAction::operator()(HyperGraph::HyperGraphElement* element,
+      HyperGraphElementAction::Parameters* params_) {
+      if (typeid(*element).name() != _typeName)
+          return nullptr;
+
+      refreshPropertyPtrs(params_);
+      if (!_previousParams)
+          return this;
+
+      if (_show && !_show->value())
+          return this;
+
+      EdgeSwitchProx* e = static_cast<EdgeSwitchProx*>(element);
+      VertexProx* from = static_cast<VertexProx*>(e->vertex(0));
+      VertexProx* to = static_cast<VertexProx*>(e->vertex(1));
+      if (!from && !to)
+          return this;
+      SE2 fromTransform;
+      SE2 toTransform;
+      glPushAttrib(GL_ENABLE_BIT | GL_LIGHTING | GL_COLOR);
+      glDisable(GL_LIGHTING);
+      /*
+      if (!from) {
+          glColor3f(POSE_EDGE_GHOST_COLOR);
+          toTransform = to->estimate();
+          fromTransform = to->estimate() * e->measurement().inverse();
+          // DRAW THE FROM EDGE AS AN ARROW
+          glPushMatrix();
+          glTranslatef((float)fromTransform.translation().x(), (float)fromTransform.translation().y(), 0.f);
+          glRotatef((float)RAD2DEG(fromTransform.rotation().angle()), 0.f, 0.f, 1.f);
+          opengl::drawArrow2D((float)_triangleX->value(), (float)_triangleY->value(), (float)_triangleX->value() * .3f);
+          glPopMatrix();
+      }
+      else if (!to) {
+          glColor3f(POSE_EDGE_GHOST_COLOR);
+          fromTransform = from->estimate();
+          toTransform = from->estimate() * e->measurement();
+          // DRAW THE TO EDGE AS AN ARROW
+          glPushMatrix();
+          glTranslatef(toTransform.translation().x(), toTransform.translation().y(), 0.f);
+          glRotatef((float)RAD2DEG(toTransform.rotation().angle()), 0.f, 0.f, 1.f);
+          opengl::drawArrow2D((float)_triangleX->value(), (float)_triangleY->value(), (float)_triangleX->value() * .3f);
+          glPopMatrix();
+      }
+      */
+      { //else {
+          glColor3f(POSE_EDGE_COLOR);
+          fromTransform = from->estimate();
+          toTransform = to->estimate();
+      }
+      //glGetFloatv(GL_LINE_WIDTH, &(float)_triangleY->value());
+      if (_triangleY->value() != 0) {
+          glLineWidth((float)_triangleY->value());
+          glBegin(GL_LINES);
+          glVertex3f((float)fromTransform.translation().x(), (float)fromTransform.translation().y(), 0.f);
+          glVertex3f((float)toTransform.translation().x(), (float)toTransform.translation().y(), 0.f);
+          glEnd();
+      }
+      //glGetFloatv(GL_LINE_WIDTH, &(float)_triangleZ->value());
+      if (_triangleZ->value() != 0) {
+          glLineWidth((float)_triangleZ->value());
+          glColor3f(LANDMARK_EDGE_COLOR);
+          glBegin(GL_LINES);
+          for (int i = 0; i < e->num_prox_pairs(); i++) {
+              glVertex3f((float)e->from_gr_prox(i).x(), (float)e->from_gr_prox(i).y(), 0.f);
+              glVertex3f((float)e->to_gr_prox(i).x(), (float)e->to_gr_prox(i).y(), 0.f);
+          }
+      }
+      glEnd();
+      glPopAttrib();
+      return this;
+  }
+#endif
+}
diff --git a/g2o/types/slam2d/parameter_em_prox.h b/g2o/types/slam2d/parameter_em_prox.h
new file mode 100644
index 00000000..b163089a
--- /dev/null
+++ b/g2o/types/slam2d/parameter_em_prox.h
@@ -0,0 +1,86 @@
+// This class was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#ifndef G2O_VERTEX_SE2_OFFSET_PARAMETERS_H_
+#define G2O_VERTEX_SE2_OFFSET_PARAMETERS_H_
+
+#include "g2o/core/cache.h"
+#include "g2o_types_slam2d_api.h"
+#include "se2.h"
+
+namespace g2o {
+
+class VertexSE2;
+
+/**
+    * \brief offset for an SE2
+    */
+class G2O_TYPES_SLAM2D_API ParameterSE2Offset : public Parameter {
+public:
+    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
+    ParameterSE2Offset();
+
+    virtual bool read(std::istream& is);
+    virtual bool write(std::ostream& os) const;
+
+    /**
+        * update the offset to a new value.
+        * re-calculates the different representations, e.g., the rotation matrix
+        */
+    void setOffset(const SE2& offset_ = SE2());
+
+    const SE2& offset() const { return _offset; }
+
+    //! rotation of the offset as 2x2 rotation matrix
+    const Isometry2& offsetMatrix() const { return _offsetMatrix; }
+
+    //! rotation of the inverse offset as 2x2 rotation matrix
+    const Isometry2& inverseOffsetMatrix() const { return _inverseOffsetMatrix; }
+
+protected:
+    SE2 _offset;
+    Isometry2 _offsetMatrix;
+    Isometry2 _inverseOffsetMatrix;
+};
+
+/**
+    * \brief caching the offset related to a vertex
+    */
+class G2O_TYPES_SLAM2D_API CacheSE2Offset : public Cache {
+public:
+    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
+    CacheSE2Offset();
+    virtual void updateImpl();
+
+    const ParameterSE2Offset* offsetParam() const { return _offsetParam; }
+    void setOffsetParam(ParameterSE2Offset* offsetParam);
+
+    const SE2& w2n() const { return _se2_w2n; }
+    const SE2& n2w() const { return _se2_n2w; }
+
+    const Isometry2& w2nMatrix() const { return _w2n; }
+    const Isometry2& n2wMatrix() const { return _n2w; }
+    const Isometry2& w2lMatrix() const { return _w2l; }
+
+    const Matrix2 RpInverseRInverseMatrix() const { return _RpInverse_RInverse; }
+    const Matrix2 RpInverseRInversePrimeMatrix() const {
+        return _RpInverse_RInversePrime;
+    }
+
+protected:
+    ParameterSE2Offset* _offsetParam;  ///< the parameter connected to the cache
+    SE2 _se2_w2n;
+    SE2 _se2_n2w;
+
+    Isometry2 _w2n;  ///< world to sensor transform
+    Isometry2 _w2l;  ///< world to local
+    Isometry2 _n2w;  ///< sensor to world
+    Matrix2 _RpInverse_RInverse;
+    Matrix2 _RpInverse_RInversePrime;
+
+protected:
+    virtual bool resolveDependencies();
+};
+
+}  // namespace g2o
+
+#endif
\ No newline at end of file
diff --git a/g2o/types/slam2d/parameter_switch_weight.cpp b/g2o/types/slam2d/parameter_switch_weight.cpp
new file mode 100644
index 00000000..c8a8fb3d
--- /dev/null
+++ b/g2o/types/slam2d/parameter_switch_weight.cpp
@@ -0,0 +1,53 @@
+// g2o - General Graph Optimization
+// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright
+//   notice, this list of conditions and the following disclaimer in the
+//   documentation and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "parameter_switch_weight.h"
+
+#include "g2o/core/io_helper.h"
+#include "vertex_se2.h"
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#endif
+
+namespace g2o {
+
+	ParameterSwitchWeight::ParameterSwitchWeight() { setInfo();}
+
+bool ParameterSwitchWeight::read(std::istream& is) {
+	number_t i;
+	is >> i;
+  if (is.bad()) return false;
+  setInfo(i);
+  return true;
+}
+
+bool ParameterSwitchWeight::write(std::ostream& os) const {
+	os << Info();
+	return true;
+}
+
+}  // namespace g2o
diff --git a/g2o/types/slam2d/parameter_switch_weight.h b/g2o/types/slam2d/parameter_switch_weight.h
new file mode 100644
index 00000000..08842e53
--- /dev/null
+++ b/g2o/types/slam2d/parameter_switch_weight.h
@@ -0,0 +1,59 @@
+// g2o - General Graph Optimization
+// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright
+//   notice, this list of conditions and the following disclaimer in the
+//   documentation and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef G2O_SWITCHING_WEIGHT_H_
+#define G2O_SWITCHING_WEIGHT_H_
+
+
+#include "g2o_types_slam2d_api.h"
+#include "g2o/core/cache.h"
+
+
+namespace g2o {
+
+  /**
+   * \brief offset for an SE2
+   */
+  class G2O_TYPES_SLAM2D_API ParameterSwitchWeight : public Parameter
+  {
+    public:
+      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
+      ParameterSwitchWeight();
+
+      virtual bool read(std::istream& is);
+      virtual bool write(std::ostream& os) const;
+
+      inline void setInfo(const number_t info = 0.) { _info = info; };
+
+      inline number_t Info() const { return _info; };
+
+    protected:
+      number_t _info;
+  };
+
+}
+
+#endif
diff --git a/g2o/types/slam2d/se2.h b/g2o/types/slam2d/se2.h
index 41a1280f..1f5e205c 100644
--- a/g2o/types/slam2d/se2.h
+++ b/g2o/types/slam2d/se2.h
@@ -36,60 +36,62 @@
 
 namespace g2o {
 
-/**
- * \brief represent SE2
- */
-class G2O_TYPES_SLAM2D_API SE2 {
- public:
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-  SE2() : _R(0), _t(0, 0) {}
-
-  SE2(const Isometry2& iso) : _R(0), _t(iso.translation()) {
-    _R.fromRotationMatrix(iso.linear());
-  }
-
-  SE2(const Vector3& v) : _R(v[2]), _t(v[0], v[1]) {}
-
-  SE2(number_t x, number_t y, number_t theta) : _R(theta), _t(x, y) {}
-
-  //! translational component
-  inline const Vector2& translation() const { return _t; }
-  void setTranslation(const Vector2& t_) { _t = t_; }
-
-  //! rotational component
-  inline const Rotation2D& rotation() const { return _R; }
-  void setRotation(const Rotation2D& R_) { _R = R_; }
-
-  //! concatenate two SE2 elements (motion composition)
-  inline SE2 operator*(const SE2& tr2) const {
-    SE2 result(*this);
-    result *= tr2;
-    return result;
-  }
-
-  //! motion composition operator
-  inline SE2& operator*=(const SE2& tr2) {
-    _t += _R * tr2._t;
-    _R.angle() += tr2._R.angle();
-    _R.angle() = normalize_theta(_R.angle());
-    return *this;
-  }
-
-  //! project a 2D vector
-  inline Vector2 operator*(const Vector2& v) const { return _t + _R * v; }
-
-  //! invert :-)
-  inline SE2 inverse() const {
-    SE2 ret;
-    ret._R = _R.inverse();
-    ret._R.angle() = normalize_theta(ret._R.angle());
+  /**
+   * \brief represent SE2
+   */
+  class G2O_TYPES_SLAM2D_API SE2 {
+    public:
+      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
+      SE2():_R(0),_t(0,0){}
+
+      SE2(const Isometry2& iso): _R(0), _t(iso.translation()){
+        _R.fromRotationMatrix(iso.linear());
+      }
+
+      SE2(const Vector3& v):_R(v[2]),_t(v[0],v[1]){}
+
+      SE2(number_t x, number_t y, number_t theta):_R(theta),_t(x,y){}
+
+      //! translational component
+      inline const Vector2& translation() const {return _t;}
+      void setTranslation(const Vector2& t_) {_t=t_;}
+
+      //! rotational component
+      inline const Rotation2D& rotation() const {return _R;}
+      void setRotation(const Rotation2D& R_) {_R=R_;}
+
+      //! concatenate two SE2 elements (motion composition)
+      inline SE2 operator * (const SE2& tr2) const{
+        SE2 result(*this);
+        result *= tr2;
+        return result;
+      }
+
+      //! motion composition operator
+      inline SE2& operator *= (const SE2& tr2){
+        _t+=_R*tr2._t;
+        _R.angle()+=tr2._R.angle();
+        _R.angle()=normalize_theta(_R.angle());
+        return *this;
+      }
+
+      //! project a 2D vector
+      inline Vector2 operator * (const Vector2& v) const {
+        return _t+_R*v;
+      }
+
+      //! invert :-)
+      inline SE2 inverse() const{
+        SE2 ret;
+        ret._R=_R.inverse();
+        ret._R.angle()=normalize_theta(ret._R.angle());
 #ifdef _MSC_VER
-    ret._t = ret._R * (Vector2(_t * -1.));
+        ret._t=ret._R*(Vector2(_t*-1.));
 #else
-    ret._t = ret._R * (_t * -1.);
+        ret._t=ret._R*(_t*-1.);
 #endif
-    return ret;
-  }
+        return ret;
+      }
 
   inline number_t operator[](int i) const {
     assert(i >= 0 && i < 3);
diff --git a/g2o/types/slam2d/types_slam2d.cpp b/g2o/types/slam2d/types_slam2d.cpp
<<<<<<< HEAD:0001-.patch
index 532f5bd4..1c432ffc 100644
=======
index 532f5bd4..ad7949ce 100644
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
--- a/g2o/types/slam2d/types_slam2d.cpp
+++ b/g2o/types/slam2d/types_slam2d.cpp
@@ -37,8 +37,12 @@ G2O_REGISTER_TYPE_GROUP(slam2d);
 
 G2O_REGISTER_TYPE(VERTEX_SE2, VertexSE2);
 G2O_REGISTER_TYPE(VERTEX_XY, VertexPointXY);
+G2O_REGISTER_TYPE(VERTEX_PROX, VertexProx);                       //added by wada
+G2O_REGISTER_TYPE(VERTEX_SWITCH, VertexSwitch);                   //added by wada
 G2O_REGISTER_TYPE(PARAMS_SE2OFFSET, ParameterSE2Offset);
+G2O_REGISTER_TYPE(PARAMS_SWITCH_WEIGHT, ParameterSwitchWeight);   //added by wada
 G2O_REGISTER_TYPE(CACHE_SE2_OFFSET, CacheSE2Offset);
+G2O_REGISTER_TYPE(CACHE_PROX, CacheProximity);                    //added by wada
 G2O_REGISTER_TYPE(EDGE_PRIOR_SE2, EdgeSE2Prior);
 G2O_REGISTER_TYPE(EDGE_PRIOR_SE2_XY, EdgeSE2XYPrior);
 G2O_REGISTER_TYPE(EDGE_SE2, EdgeSE2);
<<<<<<< HEAD:0001-.patch
@@ -51,9 +55,17 @@ G2O_REGISTER_TYPE(EDGE_POINTXY, EdgePointXY);
=======
@@ -51,9 +55,14 @@ G2O_REGISTER_TYPE(EDGE_POINTXY, EdgePointXY);
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
 G2O_REGISTER_TYPE(EDGE_SE2_TWOPOINTSXY, EdgeSE2TwoPointsXY);
 G2O_REGISTER_TYPE(EDGE_SE2_LOTSOFXY, EdgeSE2LotsOfXY);
 G2O_REGISTER_TYPE(EDGE_PRIOR_XY, EdgeXYPrior);
+G2O_REGISTER_TYPE(EDGE_PROX, EdgeProx);	                          //added by wada
<<<<<<< HEAD:0001-.patch
+G2O_REGISTER_TYPE(EDGE_M_Est_PROX, EdgeMEstProx);	              //added by wada
+G2O_REGISTER_TYPE(EDGE_SWITCH_SE2, EdgeSwitchSE2SIP);             //added by wada
+G2O_REGISTER_TYPE(EDGE_SWITCH_PROX, EdgeSwitchProxSIP);           //added by wada
+G2O_REGISTER_TYPE(EDGE_EM_PROX, EdgeEMProx);			          //added by wada
+G2O_REGISTER_TYPE(EDGE_SWITCH_SE2_, EdgeSwitchSE2);             //added by wada
+G2O_REGISTER_TYPE(EDGE_SWITCH_PROX_, EdgeSwitchProx);           //added by wada
=======
+G2O_REGISTER_TYPE(EDGE_SWITCH_SE2, EdgeSwitchSE2);                //added by wada
+G2O_REGISTER_TYPE(EDGE_SWITCH_PROX, EdgeSwitchProx);              //added by wada
+G2O_REGISTER_TYPE(EDGE_EM_PROX, EdgeEMProx);			          //added by wada
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
 
 G2O_REGISTER_ACTION(VertexSE2WriteGnuplotAction);
 G2O_REGISTER_ACTION(VertexPointXYWriteGnuplotAction);
+G2O_REGISTER_ACTION(VertexProxWriteGnuplotAction);                //added by wada
 G2O_REGISTER_ACTION(EdgeSE2WriteGnuplotAction);
 G2O_REGISTER_ACTION(EdgeSE2PointXYWriteGnuplotAction);
 G2O_REGISTER_ACTION(EdgeSE2PointXYBearingWriteGnuplotAction);
<<<<<<< HEAD:0001-.patch
@@ -61,9 +73,14 @@ G2O_REGISTER_ACTION(EdgeSE2PointXYBearingWriteGnuplotAction);
=======
@@ -61,9 +70,13 @@ G2O_REGISTER_ACTION(EdgeSE2PointXYBearingWriteGnuplotAction);
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
 #ifdef G2O_HAVE_OPENGL
 G2O_REGISTER_ACTION(VertexSE2DrawAction);
 G2O_REGISTER_ACTION(VertexPointXYDrawAction);
+G2O_REGISTER_ACTION(VertexProxDrawAction);                        //added by wada
 G2O_REGISTER_ACTION(EdgeSE2DrawAction);
 G2O_REGISTER_ACTION(EdgeSE2PointXYDrawAction);
 G2O_REGISTER_ACTION(EdgeSE2PointXYBearingDrawAction);
+G2O_REGISTER_ACTION(EdgeProxDrawAction);                          //added by wada
+G2O_REGISTER_ACTION(EdgeMEstProxDrawAction);                      //added by wada
+G2O_REGISTER_ACTION(EdgeSwitchProxDrawAction);                    //added by wada
+G2O_REGISTER_ACTION(EdgeEMProxDrawAction);                        //added by wada
 
 #endif
 }  // namespace g2o
diff --git a/g2o/types/slam2d/types_slam2d.h b/g2o/types/slam2d/types_slam2d.h
index 385f1cee..605d27e6 100644
--- a/g2o/types/slam2d/types_slam2d.h
+++ b/g2o/types/slam2d/types_slam2d.h
@@ -27,6 +27,7 @@
 #ifndef G2O_TYPES_SLAM2D_
 #define G2O_TYPES_SLAM2D_
 
+#include "cache_prox.h"				//added by wada
 #include "edge_pointxy.h"
 #include "edge_se2.h"
 #include "edge_se2_lotsofxy.h"
@@ -39,9 +40,16 @@
 #include "edge_se2_twopointsxy.h"
 #include "edge_se2_xyprior.h"
 #include "edge_xy_prior.h"
+#include "edge_prox.h"               //added by wada
+#include "edge_switch_prox.h"        //added by wada
+#include "edge_em_prox.h"            //added by wada
+#include "edge_switch_se2.h"         //added by wada
 #include "g2o/config.h"
 #include "parameter_se2_offset.h"
+#include "parameter_switch_weight.h" //added by wada
 #include "vertex_point_xy.h"
 #include "vertex_se2.h"
+#include "vertex_prox.h"             //added by wada
+#include "vertex_switch.h"           //added by wada
 
 #endif
diff --git a/g2o/types/slam2d/vertex_prox.cpp b/g2o/types/slam2d/vertex_prox.cpp
new file mode 100644
<<<<<<< HEAD:0001-.patch
index 00000000..d70ebb98
--- /dev/null
+++ b/g2o/types/slam2d/vertex_prox.cpp
@@ -0,0 +1,163 @@
=======
index 00000000..e112f50b
--- /dev/null
+++ b/g2o/types/slam2d/vertex_prox.cpp
@@ -0,0 +1,153 @@
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
+// This library was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#include <string>
+#include "vertex_prox.h"
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+
+  VertexProx::VertexProx() :
+    BaseVertex<3, SE2>(), _proximityParam(){}
+
+  void VertexProx::oplusImpl(const number_t* update)
+  {
+    SE2 t = _estimate, dt = SE2();
+    dt.setTranslation(Vector2(update[0], update[1]));
+    dt.setRotation(Rotation2D(normalize_theta(update[2])));
+    _estimate = t * dt;
+  }
+
+  bool VertexProx::setProximityParam(const std::vector<Vector2>& pp)
+  {
+      _proximityParam.clear();
+      for (const Vector2& _pp : pp)
+          _proximityParam.push_back(_pp);
+      return true;
+  }
+
+  bool VertexProx::read(std::istream& is)
+  {
+    Vector3 p;
+    bool state = internal::readVector(is, p);
+    setEstimate(p);
+    int n;
+    is >> n;
+    _proximityParam.resize(n);
<<<<<<< HEAD:0001-.patch
+    std::vector<Vector2> pp(n);
+    for (Vector2& r : pp) {
+        bool state_r = internal::readVector(is, r);
+        if (state_r == false) return false;
+    }
+    state = setProximityParam(pp) & state;
+    return state;
=======
+    for (Vector2& r : _proximityParam) {
+        bool state_r = internal::readVector(is, r);
+        if (state_r == false) return false;
+    }
+    return state_p;
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
+  }
+
+  bool VertexProx::write(std::ostream& os) const
+  {
+    bool state_p = internal::writeVector(os, estimate().toVector());
+    os << _proximityParam.size() << " ";
+    for (const Vector2& r : _proximityParam) {
+        bool state_r = internal::writeVector(os, r);
+        if (state_r == false) return false;
+    }
+    return state_p;
+  }
+
+  VertexProxWriteGnuplotAction::VertexProxWriteGnuplotAction(): WriteGnuplotAction(typeid(VertexProx).name()){}
+
+  HyperGraphElementAction* VertexProxWriteGnuplotAction::operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* params_){
+    if (typeid(*element).name()!=_typeName)
+      return nullptr;
+    WriteGnuplotAction::Parameters* params= dynamic_cast<WriteGnuplotAction::Parameters*>(params_);
+    if (!params || !params->os){
+      std::cerr << __PRETTY_FUNCTION__ << ": warning, no valid output stream specified" << std::endl;
+      return nullptr;
+    }
+
+    VertexProx* v = dynamic_cast<VertexProx*>(element);
+    *(params->os) << v->estimate().translation().x() << " " << v->estimate().translation().y()
+      << " " << v->estimate().rotation().angle() << std::endl;
+    return this;
+  }
+
+#ifdef G2O_HAVE_OPENGL
+  VertexProxDrawAction::VertexProxDrawAction()
+      : DrawAction(typeid(VertexProx).name()), _drawActions(nullptr), _arrow_length(nullptr), _arrow_width(nullptr),
+      _point_size(nullptr), _line_width(nullptr) {}
+
+  bool VertexProxDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_){
+    if (!DrawAction::refreshPropertyPtrs(params_))
+      return false;
+    if (_previousParams){
+        _arrow_length = _previousParams->makeProperty<FloatProperty>(_typeName + "::N_Vertex_Arrow_Length", .5f);
+        _arrow_width = _previousParams->makeProperty<FloatProperty>(_typeName + "::N_Vertex_Arrow_Width", .3f);
+        _point_size = _previousParams->makeProperty<FloatProperty>(_typeName + "::P_Vertex_Size", 5.0f);
+        _line_width = _previousParams->makeProperty<FloatProperty>(_typeName + "::PN_line_width", .0f);
+    } else {
+        _arrow_length = 0;
+        _arrow_width = 0;
+        _point_size = 0;
+        _line_width = 0;
+    }
+    return true;
+  }
+
+
+  HyperGraphElementAction* VertexProxDrawAction::operator()(HyperGraph::HyperGraphElement* element,
+                 HyperGraphElementAction::Parameters* params_){
+   if (typeid(*element).name()!=_typeName)
+      return nullptr;
+    //initializeDrawActionsCache();
+    refreshPropertyPtrs(params_);
+
+    if (! _previousParams)
+      return this;
+
+    if (_show && !_show->value())
+      return this;
+
+    VertexProx* that = static_cast<VertexProx*>(element);
+
+    glPushAttrib(GL_ENABLE_BIT | GL_LIGHTING | GL_COLOR);
+    glDisable(GL_LIGHTING);
+    glColor3f(POSE_VERTEX_COLOR);
+    glPushMatrix();
+    glTranslatef((float)that->estimate().translation().x(),(float)that->estimate().translation().y(),0.f);
+    glRotatef((float)RAD2DEG(that->estimate().rotation().angle()),0.f,0.f,1.f);
+    opengl::drawArrow2D((float)_arrow_length->value(), (float)_arrow_width->value(), (float)_arrow_width->value()*.5f);
+    //drawCache(that->cacheContainer(), params_);
+    //drawUserData(that->userData(), params_);
+    glPopMatrix();
+    glColor3f(LANDMARK_VERTEX_COLOR);
+    for (int i = 0; i < that->numProx(); i++) {
+        if ((float)_point_size->value() != 0) {
+            //glColor3f(POSE_VERTEX_COLOR);
+            glPushMatrix();
+            glTranslatef((float)(that->estimate() * that->proximity(i)).x(), (float)(that->estimate() * that->proximity(i)).y(), 0.f);
+            glRotatef((float)RAD2DEG(that->estimate().rotation().angle()), 0.f, 0.f, 1.f);
+            opengl::drawPoint((float)_point_size->value());
+            //drawCache(that->cacheContainer(), params_);
+            //drawUserData(that->userData(), params_);
+            glPopMatrix();
+            glColor3f(LANDMARK_VERTEX_COLOR);
+        }
+        if ((float)_line_width->value() != 0) {
+            glColor3f(POSE_VERTEX_COLOR);
+            glPushMatrix();
+            glTranslatef((float)that->estimate().translation().x(), (float)that->estimate().translation().y(), 0.f);
+            glRotatef((float)RAD2DEG(that->estimate().rotation().angle() + atan2(that->proximity(i).y(), that->proximity(i).x())), 0.f, 0.f, 1.f);
+            opengl::drawLine((float)that->proximity(i).norm(), (float)_line_width->value());
+            //drawCache(that->cacheContainer(), params_);
+            //drawUserData(that->userData(), params_);
+            glPopMatrix();
+            glColor3f(LANDMARK_VERTEX_COLOR);
+            //glLineWidth((float)_line_width->value());
+            //glBegin(GL_LINES);
+            //glVertex3f((float)that->estimate().translation().x(), (float)that->estimate().translation().y(), 0.f);
+            //glVertex3f((float)(that->estimate() * that->proximity(i)).x(), (float)(that->estimate() * that->proximity(i)).y(), 0.f);
+            //glEnd();
+        }
+    }
+    //drawCache(that->cacheContainer(), params_);
+    //drawUserData(that->userData(), params_);
+    glPopAttrib();
+    return this;
+  }
+#endif
+
+
+} // end namespace
diff --git a/g2o/types/slam2d/vertex_prox.h b/g2o/types/slam2d/vertex_prox.h
new file mode 100644
<<<<<<< HEAD:0001-.patch
index 00000000..37c7600c
--- /dev/null
+++ b/g2o/types/slam2d/vertex_prox.h
@@ -0,0 +1,91 @@
=======
index 00000000..291e4da1
--- /dev/null
+++ b/g2o/types/slam2d/vertex_prox.h
@@ -0,0 +1,89 @@
>>>>>>> a5b856c03613efff3a9695c84c01cc6571287405:0001-Pose-graph-optimization-using-proximity-point-pair-m.patch
+// This library was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#ifndef G2O_VERTEX_SE2_PROXIMITY_H
+#define G2O_VERTEX_SE2_PROXIMITY_H
+
+#include "g2o/core/base_binary_edge.h"
+
+#include "g2o/config.h"
+#include "g2o/core/base_vertex.h"
+#include "g2o/core/hyper_graph_action.h"
+#include "se2.h"
+#include "g2o_types_slam2d_api.h"
+
+namespace g2o {
+
+  class G2O_TYPES_SLAM2D_API VertexProx : public BaseVertex<3, SE2>
+  {
+    public:
+      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+          VertexProx();
+
+      virtual void setToOriginImpl() {
+        _estimate = SE2();
+      }
+
+      virtual void oplusImpl(const number_t* update);
+
+      virtual bool setEstimateDataImpl(const number_t* est){
+        _estimate=SE2(est[0], est[1], est[2]);
+        return true;
+      }
+
+      virtual bool getEstimateData(number_t* est) const {
+        Eigen::Map<Vector3> v(est);
+        v = _estimate.toVector();
+        return true;
+      }
+      
+      virtual int estimateDimension() const { return 3; }
+
+      virtual bool setMinimalEstimateDataImpl(const number_t* est){
+        return setEstimateData(est);
+      }
+
+      virtual bool getMinimalEstimateData(number_t* est) const {
+        return getEstimateData(est);
+      }
+      
+      virtual int minimalEstimateDimension() const { return 3; }
+
+      bool setProximityParam(const std::vector<Vector2>& pp);
+
+      virtual bool read(std::istream& is);
+      virtual bool write(std::ostream& os) const;
+
+      virtual inline int numProx() const { return _proximityParam.size(); };
+      virtual inline Vector2 proximity(int i) const {
+          if(0 <= i && i < numProx())
+            return _proximityParam[i];
+          std::cerr << typeid(*this).name() << " : Out of Proximity Index Range!" << std::endl;
+          return Vector2();
+      };
+
+  private:
+      std::vector<Vector2> _proximityParam;
+  };
+
+  class G2O_TYPES_SLAM2D_API VertexProxWriteGnuplotAction: public WriteGnuplotAction {
+  public:
+      VertexProxWriteGnuplotAction();
+    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element, 
+            HyperGraphElementAction::Parameters* params_ );
+  };
+
+#ifdef G2O_HAVE_OPENGL
+  class G2O_TYPES_SLAM2D_API VertexProxDrawAction: public DrawAction{
+  public:
+    VertexProxDrawAction();
+    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element, 
+            HyperGraphElementAction::Parameters* params_ );
+  protected:
+    HyperGraphElementAction* _drawActions;
+    virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
+    FloatProperty* _arrow_length, * _arrow_width, * _point_size, * _line_width;
+
+  };
+#endif
+
+} // end namespace
+
+#endif
diff --git a/g2o/types/slam2d/vertex_se2.h b/g2o/types/slam2d/vertex_se2.h
index e9fc88fc..91168c66 100644
--- a/g2o/types/slam2d/vertex_se2.h
+++ b/g2o/types/slam2d/vertex_se2.h
@@ -46,11 +46,10 @@ class G2O_TYPES_SLAM2D_API VertexSE2 : public BaseVertex<3, SE2> {
   virtual void setToOriginImpl() { _estimate = SE2(); }
 
   virtual void oplusImpl(const number_t* update) {
-    Vector2 t = _estimate.translation();
-    t += Eigen::Map<const Vector2>(update);
-    number_t angle = normalize_theta(_estimate.rotation().angle() + update[2]);
-    _estimate.setTranslation(t);
-    _estimate.setRotation(Rotation2D(angle));
+    SE2 t = _estimate, dt = SE2();
+    dt.setTranslation(Vector2(update[0], update[1]));
+    dt.setRotation(Rotation2D(normalize_theta(update[2])));
+    _estimate = t * dt;
   }
 
   virtual bool setEstimateDataImpl(const number_t* est) {
diff --git a/g2o/types/slam2d/vertex_switch.cpp b/g2o/types/slam2d/vertex_switch.cpp
new file mode 100644
index 00000000..4d2888d6
--- /dev/null
+++ b/g2o/types/slam2d/vertex_switch.cpp
@@ -0,0 +1,33 @@
+// This class was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#include <string>
+#include "vertex_switch.h"
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+
+    VertexSwitch::VertexSwitch() :
+        BaseVertex<1, number_t>() { 
+        setToOriginImpl();
+    }
+  void VertexSwitch::oplusImpl(const number_t* update) {
+      _estimate += update[0];
+  }
+
+  bool VertexSwitch::read(std::istream& is) {
+      setToOriginImpl();
+    if (is.bad()) return true;
+    is >> _estimate;
+    return true;
+  }
+
+  bool VertexSwitch::write(std::ostream& os) const {
+    os << _estimate << " ";
+    return true;
+  }
+
+} // end namespace
diff --git a/g2o/types/slam2d/vertex_switch.h b/g2o/types/slam2d/vertex_switch.h
new file mode 100644
index 00000000..bda3e668
--- /dev/null
+++ b/g2o/types/slam2d/vertex_switch.h
@@ -0,0 +1,60 @@
+// This class was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#ifndef G2O_SWITCHING_H
+#define G2O_SWITCHING_H
+
+#include "g2o/core/base_ternary_edge.h"
+#include "parameter_switch_weight.h"
+
+#include "g2o/config.h"
+#include "g2o/core/base_vertex.h"
+#include "g2o/core/hyper_graph_action.h"
+#include "g2o_types_slam2d_api.h"
+
+namespace g2o {
+
+    class G2O_TYPES_SLAM2D_API VertexSwitch : public BaseVertex<1, number_t>
+    {
+    public:
+        EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+            VertexSwitch();
+
+        virtual void setToOriginImpl() {
+            //for (int i = 0; i < prox_maxN; i++)
+            //    _estimate[i] = 1.;
+            _estimate = 1.;
+        }
+
+        virtual void oplusImpl(const number_t* update);
+
+        virtual bool setEstimateDataImpl(const number_t* est) {
+            _estimate = est[0];
+            return true;
+        }
+
+        virtual bool getEstimateData(number_t* est) const {
+            est[0] = _estimate;
+            return true;
+        }
+
+        virtual int estimateDimension() const { return 1; }
+
+        virtual bool setMinimalEstimateDataImpl(const number_t* est) {
+            return setEstimateData(est);
+        }
+
+        virtual bool getMinimalEstimateData(number_t* est) const {
+            return getEstimateData(est);
+        }
+
+        virtual int minimalEstimateDimension() const { return 1; }
+
+        virtual bool read(std::istream& is);
+        virtual bool write(std::ostream& os) const;
+
+    private:
+    };
+
+} // end namespace
+
+#endif
-- 
2.33.1.windows.1

