From 793b51a5e7ebeb1e5fb490c0498c0819a90ed3e0 Mon Sep 17 00:00:00 2001
From: Wada Kotaro <Wada_Kotaro@stu.kobe-u.ac.jp>
Date: Thu, 20 Oct 2022 11:16:40 +0900
Subject: [PATCH] ;

---
 g2o/core/CMakeLists.txt                      |  49 +--
 g2o/core/base_ternary_edge.h                 |  31 ++
 g2o/stuff/opengl_primitives.cpp              |   8 +
 g2o/stuff/opengl_primitives.h                |   5 +
 g2o/types/slam2d/CMakeLists.txt              |  40 ++-
 g2o/types/slam2d/edge_em_prox.cpp            | 311 +++++++++++++++++++
 g2o/types/slam2d/edge_em_prox.h              |  98 ++++++
 g2o/types/slam2d/edge_em_se2.cpp             | 220 +++++++++++++
 g2o/types/slam2d/edge_em_se2.h               | 126 ++++++++
 g2o/types/slam2d/edge_prox.cpp               | 287 +++++++++++++++++
 g2o/types/slam2d/edge_prox.h                 | 112 +++++++
 g2o/types/slam2d/edge_se2.h                  |   3 +
 g2o/types/slam2d/edge_switch_prox.cpp        | 311 +++++++++++++++++++
 g2o/types/slam2d/edge_switch_prox.h          |  98 ++++++
 g2o/types/slam2d/edge_switch_se2.cpp         | 222 +++++++++++++
 g2o/types/slam2d/edge_switch_se2.h           | 127 ++++++++
 g2o/types/slam2d/parameter_em.cpp            |  63 ++++
 g2o/types/slam2d/parameter_em.h              |  58 ++++
 g2o/types/slam2d/parameter_em_prox.cpp       | 311 +++++++++++++++++++
 g2o/types/slam2d/parameter_em_prox.h         |  86 +++++
 g2o/types/slam2d/parameter_prox.cpp          |  92 ++++++
 g2o/types/slam2d/parameter_prox.h            |  67 ++++
 g2o/types/slam2d/parameter_switch_weight.cpp |  53 ++++
 g2o/types/slam2d/parameter_switch_weight.h   |  59 ++++
 g2o/types/slam2d/se2.h                       | 104 ++++---
 g2o/types/slam2d/types_slam2d.cpp            |  11 +
 g2o/types/slam2d/types_slam2d.h              |   6 +
 g2o/types/slam2d/vertex_prox.cpp             | 160 ++++++++++
 g2o/types/slam2d/vertex_prox.h               | 100 ++++++
 g2o/types/slam2d/vertex_se2.h                |   9 +-
 g2o/types/slam2d/vertex_switch.cpp           |  33 ++
 g2o/types/slam2d/vertex_switch.h             |  60 ++++
 g2o/types/slam2d/vertex_switch_pp.cpp        |  54 ++++
 g2o/types/slam2d/vertex_switch_pp.h          |  67 ++++
 34 files changed, 3349 insertions(+), 92 deletions(-)
 create mode 100644 g2o/core/base_ternary_edge.h
 create mode 100644 g2o/types/slam2d/edge_em_prox.cpp
 create mode 100644 g2o/types/slam2d/edge_em_prox.h
 create mode 100644 g2o/types/slam2d/edge_em_se2.cpp
 create mode 100644 g2o/types/slam2d/edge_em_se2.h
 create mode 100644 g2o/types/slam2d/edge_prox.cpp
 create mode 100644 g2o/types/slam2d/edge_prox.h
 create mode 100644 g2o/types/slam2d/edge_switch_prox.cpp
 create mode 100644 g2o/types/slam2d/edge_switch_prox.h
 create mode 100644 g2o/types/slam2d/edge_switch_se2.cpp
 create mode 100644 g2o/types/slam2d/edge_switch_se2.h
 create mode 100644 g2o/types/slam2d/parameter_em.cpp
 create mode 100644 g2o/types/slam2d/parameter_em.h
 create mode 100644 g2o/types/slam2d/parameter_em_prox.cpp
 create mode 100644 g2o/types/slam2d/parameter_em_prox.h
 create mode 100644 g2o/types/slam2d/parameter_prox.cpp
 create mode 100644 g2o/types/slam2d/parameter_prox.h
 create mode 100644 g2o/types/slam2d/parameter_switch_weight.cpp
 create mode 100644 g2o/types/slam2d/parameter_switch_weight.h
 create mode 100644 g2o/types/slam2d/vertex_prox.cpp
 create mode 100644 g2o/types/slam2d/vertex_prox.h
 create mode 100644 g2o/types/slam2d/vertex_switch.cpp
 create mode 100644 g2o/types/slam2d/vertex_switch.h
 create mode 100644 g2o/types/slam2d/vertex_switch_pp.cpp
 create mode 100644 g2o/types/slam2d/vertex_switch_pp.h

diff --git a/g2o/core/CMakeLists.txt b/g2o/core/CMakeLists.txt
index 4ac05b18..92d6fcaf 100644
--- a/g2o/core/CMakeLists.txt
+++ b/g2o/core/CMakeLists.txt
@@ -3,40 +3,43 @@ dynamic_aligned_buffer.hpp
 ownership.h
 base_edge.h
 base_multi_edge.h
-base_fixed_sized_edge.h        hyper_graph_action.cpp
-base_fixed_sized_edge.hpp      hyper_graph_action.h
-base_variable_sized_edge.h     hyper_graph.cpp
-base_variable_sized_edge.hpp   hyper_graph.h
-base_unary_edge.h           linear_solver.h
-base_binary_edge.h          marginal_covariance_cholesky.cpp
-base_vertex.h               marginal_covariance_cholesky.h
-base_vertex.hpp             matrix_structure.cpp
-batch_stats.cpp             matrix_structure.h
-batch_stats.h               openmp_mutex.h
+base_fixed_sized_edge.hpp   base_fixed_sized_edge.h
+base_variable_sized_edge.h  base_variable_sized_edge.hpp
+base_unary_edge.h
+base_binary_edge.h
+base_ternary_edge.h
+base_vertex.h               base_vertex.hpp
+batch_stats.cpp             batch_stats.h
+hyper_graph_action.cpp      hyper_graph_action.h
+hyper_graph.cpp             hyper_graph.h
+linear_solver.h
+marginal_covariance_cholesky.cpp marginal_covariance_cholesky.h
+matrix_structure.cpp        matrix_structure.h
+openmp_mutex.h
 block_solver.h              block_solver.hpp
 parameter.cpp               parameter.h
 cache.cpp                   cache.h
 optimizable_graph.cpp       optimizable_graph.h
 solver.cpp                  solver.h
-creators.h                  optimization_algorithm_factory.cpp
-estimate_propagator.cpp     optimization_algorithm_factory.h
-estimate_propagator.h
-factory.cpp                 optimization_algorithm_property.h
-factory.h                   sparse_block_matrix.h
-sparse_optimizer.cpp  sparse_block_matrix.hpp
-sparse_optimizer.h
-hyper_dijkstra.cpp hyper_dijkstra.h
+creators.h
+estimate_propagator.cpp     estimate_propagator.h
+factory.cpp                 factory.h
+sparse_optimizer.cpp        sparse_optimizer.h
+optimization_algorithm_factory.cpp optimization_algorithm_factory.h
+optimization_algorithm_property.h
+sparse_block_matrix.h       sparse_block_matrix.hpp
+hyper_dijkstra.cpp          hyper_dijkstra.h
 parameter_container.cpp     parameter_container.h
-optimization_algorithm.cpp optimization_algorithm.h
+optimization_algorithm.cpp  optimization_algorithm.h
 optimization_algorithm_with_hessian.cpp optimization_algorithm_with_hessian.h
 optimization_algorithm_gauss_newton.cpp optimization_algorithm_gauss_newton.h
 optimization_algorithm_levenberg.cpp optimization_algorithm_levenberg.h
 optimization_algorithm_dogleg.cpp optimization_algorithm_dogleg.h
 sparse_optimizer_terminate_action.cpp sparse_optimizer_terminate_action.h
-jacobian_workspace.cpp jacobian_workspace.h
-robust_kernel.cpp robust_kernel.h
-robust_kernel_impl.cpp robust_kernel_impl.h
-robust_kernel_factory.cpp robust_kernel_factory.h
+jacobian_workspace.cpp      jacobian_workspace.h
+robust_kernel.cpp           robust_kernel.h
+robust_kernel_impl.cpp      robust_kernel_impl.h
+robust_kernel_factory.cpp   robust_kernel_factory.h
 io_helper.h
 g2o_core_api.h
 )
diff --git a/g2o/core/base_ternary_edge.h b/g2o/core/base_ternary_edge.h
new file mode 100644
index 00000000..eb7b613f
--- /dev/null
+++ b/g2o/core/base_ternary_edge.h
@@ -0,0 +1,31 @@
+// This class was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#ifndef G2O_BASE_TERNARY_EDGE_H
+#define G2O_BASE_TERNARY_EDGE_H
+
+#include "base_fixed_sized_edge.h"
+
+namespace g2o {
+
+// This could be a simple using statement, but in multiple places
+// _jacobianOplusXi, _jacobianOplusXj and _jacobianOplusXk are used.
+template <int D, typename E, typename VertexXi, typename VertexXj, typename VertexXk>
+class BaseTernaryEdge : public BaseFixedSizedEdge<D, E, VertexXi, VertexXj, VertexXk> {
+ public:
+  using VertexXiType = VertexXi;
+  using VertexXjType = VertexXj;
+  using VertexXkType = VertexXk;
+  BaseTernaryEdge() : BaseFixedSizedEdge<D, E, VertexXi, VertexXj, VertexXk>(){};
+
+ protected:
+  typename BaseFixedSizedEdge<D, E, VertexXi, VertexXj, VertexXk>::template JacobianType<
+      D, VertexXi::Dimension>& _jacobianOplusXi = std::get<0>(this->_jacobianOplus);
+  typename BaseFixedSizedEdge<D, E, VertexXi, VertexXj, VertexXk>::template JacobianType<
+      D, VertexXj::Dimension>& _jacobianOplusXj = std::get<1>(this->_jacobianOplus);
+  typename BaseFixedSizedEdge<D, E, VertexXi, VertexXj, VertexXk>::template JacobianType<
+      D, VertexXk::Dimension>& _jacobianOplusXk = std::get<2>(this->_jacobianOplus);
+};
+
+}  // namespace g2o
+
+#endif
diff --git a/g2o/stuff/opengl_primitives.cpp b/g2o/stuff/opengl_primitives.cpp
index 33be81e5..5bd69cfe 100644
--- a/g2o/stuff/opengl_primitives.cpp
+++ b/g2o/stuff/opengl_primitives.cpp
@@ -305,5 +305,13 @@ void drawPoint(float pointSize) {
   glVertex3f(0, 0, 0);
   glEnd();
 }
+
+void drawLine(float lineLength, float  lineWidth) {
+    glLineWidth(lineWidth);
+    glBegin(GL_LINES);
+    glVertex3f(0.f, 0.f, 0.f);
+    glVertex3f(lineLength, 0.f, 0.f);
+    glEnd();
+}
 }  // namespace opengl
 }  // namespace g2o
diff --git a/g2o/stuff/opengl_primitives.h b/g2o/stuff/opengl_primitives.h
index f3aade98..00b123ea 100644
--- a/g2o/stuff/opengl_primitives.h
+++ b/g2o/stuff/opengl_primitives.h
@@ -139,6 +139,11 @@ void G2O_OPENGL_API drawArrow2D(float len, float head_width, float head_len);
  */
 void G2O_OPENGL_API drawPoint(float pointSize);
 
+/**
+ * draw a line along the x axis
+ */
+void G2O_OPENGL_API drawLine(float lineLength, float  lineWidth);
+
 // @}
 
 #define POSE_VERTEX_COLOR 0.5f, 0.5f, 0.8f
diff --git a/g2o/types/slam2d/CMakeLists.txt b/g2o/types/slam2d/CMakeLists.txt
index a565f5fd..25dfc81e 100644
--- a/g2o/types/slam2d/CMakeLists.txt
+++ b/g2o/types/slam2d/CMakeLists.txt
@@ -1,19 +1,33 @@
 add_library(types_slam2d ${G2O_LIB_TYPE}
+  types_slam2d.cpp			types_slam2d.h
   se2.h
-  edge_se2_pointxy_bearing.h  edge_se2_prior.h
-  edge_se2.cpp                  edge_se2_pointxy_calib.cpp  types_slam2d.cpp
-  edge_se2.h                    edge_se2_pointxy_calib.h    vertex_point_xy.cpp
-  edge_se2_pointxy.cpp        vertex_point_xy.h
-  edge_se2_pointxy.h          vertex_se2.cpp
-  edge_se2_pointxy_bearing.cpp  edge_se2_prior.cpp          vertex_se2.h
-  parameter_se2_offset.cpp     parameter_se2_offset.h
-  edge_se2_offset.cpp          edge_se2_offset.h
-  edge_se2_pointxy_offset.cpp  edge_se2_pointxy_offset.h
-  edge_se2_xyprior.cpp edge_se2_xyprior.h
-  edge_pointxy.cpp             edge_pointxy.h
-  edge_se2_twopointsxy.cpp	edge_se2_twopointsxy.h
+  edge_se2.cpp				edge_se2.h
+  edge_se2_pointxy_bearing.cpp	edge_se2_pointxy_bearing.h
+  edge_se2_pointxy_calib.cpp	edge_se2_pointxy_calib.h
+  edge_se2_pointxy.cpp			edge_se2_pointxy.h
+  edge_se2_prior.cpp			edge_se2_prior.h
+  edge_se2_offset.cpp			edge_se2_offset.h
+  edge_se2_pointxy_offset.cpp	edge_se2_pointxy_offset.h
+  edge_se2_xyprior.cpp			edge_se2_xyprior.h
+  edge_pointxy.cpp				edge_pointxy.h
+  edge_se2_twopointsxy.cpp		edge_se2_twopointsxy.h
   edge_se2_lotsofxy.cpp		edge_se2_lotsofxy.h
-  edge_xy_prior.cpp		edge_xy_prior.h
+  edge_xy_prior.cpp			edge_xy_prior.h
+  edge_prox.cpp				edge_prox.h				#added by wada
+  edge_switch_se2.cpp		edge_switch_se2.h		#added by wada
+  edge_switch_prox.cpp		edge_switch_prox.h		#added by wada
+#  edge_em_se2.cpp			edge_em_se2.h			#added by wada
+#  edge_em_prox.cpp			edge_em_prox.h			#added by wada
+  vertex_se2.cpp			vertex_se2.h
+  vertex_point_xy.cpp		vertex_point_xy.h
+  vertex_switch.cpp			vertex_switch.h			#added by wada
+  vertex_prox.cpp			vertex_prox.h			#added by wada
+  vertex_switch_pp.cpp		vertex_switch_pp.h		#added by wada
+  parameter_se2_offset.cpp		parameter_se2_offset.h
+  parameter_prox.cpp		parameter_prox.h		#added by wada
+  parameter_switch_weight.cpp	parameter_switch_weight.h	#added by wada
+#  parameter_em_se2.cpp		parameter_em_se2.h		#added by wada
+#  parameter_em_prox.cpp		parameter_em_prox.h		#added by wada
   g2o_types_slam2d_api.h
 )
 
diff --git a/g2o/types/slam2d/edge_em_prox.cpp b/g2o/types/slam2d/edge_em_prox.cpp
new file mode 100644
index 00000000..77791749
--- /dev/null
+++ b/g2o/types/slam2d/edge_em_prox.cpp
@@ -0,0 +1,311 @@
+// This class was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#include "edge_switch_prox.h"
+#include <iostream>
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+  using namespace std;
+
+
+  // point to camera projection, monocular
+  EdgeSwitchProx::EdgeSwitchProx()
+      : BaseTernaryEdge < 3 * prox_maxN, std::array<int, 2 * prox_maxN>, VertexProx, VertexProx, VertexSwitchProxPair >(), _num_prox_pairs(0), _prox_pairs(), info(1.) {
+      memset(_prox_pairs[0], 0, prox_maxN);
+      memset(_prox_pairs[1], 0, prox_maxN);
+    information().setZero();
+    _ProxPairWeightInfo = 0;
+    resizeParameters(1);
+    installParameter(_ProxPairWeightInfo, 0);
+  }
+
+  bool EdgeSwitchProx::read(std::istream& is) {
+    // measured keypoint
+    setMeasurementData(0);
+    if (is.bad()) return false;
+    //readInformationMatrix(is);
+    //  we overwrite the information matrix in case of read errors
+    //if (is.bad()) information().setIdentity();
+    information().setZero();
+    _num_prox_pairs = 0;
+    if (!setParameterId(0, 0))
+        return false;
+    resolveParameters();
+    info = _ProxPairWeightInfo->Info();
+    for(int i = 0; i < prox_maxN; i++)
+        information()(2 * prox_maxN + i, 2 * prox_maxN + i) = info;
+
+    int n;
+    is >> n;
+    for (int i = 0; i < n && i < prox_maxN; i++) {
+        is >> _prox_pairs[0][i] >> _prox_pairs[1][i];
+        double info;
+        is >> info;
+        information()(2*i, 2*i) = info;
+        information()(2*i+1, 2*i+1) = info;
+        if (is.bad()) return false;
+        _num_prox_pairs = i + 1;
+    }
+    return true;
+  }
+
+  bool EdgeSwitchProx::write(std::ostream& os) const {
+      int n = _num_prox_pairs;
+      os << _num_prox_pairs << " ";
+      for (int i = 0; i < _num_prox_pairs && i < prox_maxN; i++)
+          os << _prox_pairs[0][i] << " " << _prox_pairs[1][i] << " " << information()(2*i, 2*i) << " ";
+      return true;
+  }
+
+  void EdgeSwitchProx::computeError() {
+      const SE2 vi = dynamic_cast<VertexProx*>(_vertices[0])->estimate();
+      const SE2 vj = dynamic_cast<VertexProx*>(_vertices[1])->estimate();
+      //const std::array<number_t, prox_maxN> vk = sigmoid_est();
+      const std::array<number_t, prox_maxN> vk = dynamic_cast<VertexSwitchProxPair*>(_vertices[2])->estimate();
+      for (int k = 0; k < _num_prox_pairs && k < prox_maxN; k++) {
+          const Vector2 ri = from_prox(k),  rj = to_prox(k), qi = from_gr_prox(k), qj = to_gr_prox(k);
+          if (ri == Vector2() || rj == Vector2() || qi == Vector2() || qj == Vector2()) continue;
+          const Vector2 ei = vi.rotation() * ri, ej = vj.rotation() * rj;
+          const number_t li = cst((ei / ri.norm()).dot(qj - qi)), lj = cst((ej / rj.norm()).dot(qi - qj));
+          _error.block<2, 1>(2 * k, 0) << li * vk[k], lj * vk[k];
+      }
+      for (int k = 0; k < prox_maxN; k++)
+          _error(2 * prox_maxN + k) = cst(1.) - vk[k];
+          //_error(2 * prox_maxN + k) = cst(1.) - sqrt(fabs(vk[k]));
+  }
+
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+  void EdgeSwitchProx::linearizeOplus() {
+      _jacobianOplusXi.setZero();
+      _jacobianOplusXj.setZero();
+      _jacobianOplusXk.setZero();
+      const SE2 vi = dynamic_cast<VertexProx*>(_vertices[0])->estimate();
+      const SE2 vj = dynamic_cast<VertexProx*>(_vertices[1])->estimate();
+      //const std::array<number_t, prox_maxN> vk = sigmoid_est();
+      //const std::array<number_t, prox_maxN> dvk = def_sig_est();
+      const std::array<number_t, prox_maxN> vk = dynamic_cast<VertexSwitchProxPair*>(_vertices[2])->estimate();
+      const Vector2 dt = vj.translation() - vi.translation();
+      const Matrix2 Ri = vi.rotation().toRotationMatrix(),
+          Rj = vj.rotation().toRotationMatrix(),
+          dR = Ri.transpose() * Rj;
+      for (int k = 0; k < _num_prox_pairs && k < prox_maxN; k++) {
+          const Vector2 ri = from_prox(k), rj = to_prox(k), qi = from_gr_prox(k), qj = to_gr_prox(k);
+          if (ri == Vector2() || rj == Vector2() || qi == Vector2() || qj == Vector2()) continue;
+          const number_t ni = 1. / ri.norm(), nj = 1. / rj.norm();
+          const Vector2 ei = vi.rotation() * ri, ej = vj.rotation() * rj;
+          const number_t li = cst((ei * ni).dot(qj - qi)), lj = cst((ej * nj).dot(qi - qj));
+          Vector2 z;
+
+          _jacobianOplusXi.block<1, 2>(2*k, 0) = -ri;
+          _jacobianOplusXj.block<1, 2>(2*k, 0) = dR.transpose() * ri;
+          z = dR * rj + Ri.transpose() * dt;
+          _jacobianOplusXi(2*k, 2) = ri.x() * z.y() - ri.y() * z.x();
+          z = dR * rj;
+          _jacobianOplusXj(2*k, 2) = -ri.x() * z.y() + ri.y() * z.x();
+          _jacobianOplusXi.block<1, 3>(2*k, 0) = _jacobianOplusXi.block<1, 3>(2*k, 0) * ni * vk[k];
+          _jacobianOplusXj.block<1, 3>(2*k, 0) = _jacobianOplusXj.block<1, 3>(2*k, 0) * ni * vk[k];
+          _jacobianOplusXj.block<1, 2>(2*k+1, 0) = -rj;
+          _jacobianOplusXi.block<1, 2>(2*k+1, 0) = dR * rj;
+          z = dR.transpose() * ri - Rj.transpose() * dt;
+          _jacobianOplusXj(2*k+1, 2) = rj.x() * z.y() - rj.y() * z.x();
+          z = dR.transpose() * ri;
+          _jacobianOplusXi(2*k+1, 2) = -rj.x() * z.y() + rj.y() * z.x();
+          _jacobianOplusXj.block<1, 3>(2*k+1, 0) = _jacobianOplusXj.block<1, 3>(2*k+1, 0) * nj * vk[k];
+          _jacobianOplusXi.block<1, 3>(2*k+1, 0) = _jacobianOplusXi.block<1, 3>(2*k+1, 0) * nj * vk[k];
+          _jacobianOplusXk.block<2, 1>(2 * k, k) << li, lj;
+          //_jacobianOplusXk.block<2, 1>(2 * k, k) << li * dvk[k], lj * dvk[k];
+      }
+      for (int k = 0; k < prox_maxN; k++)
+          _jacobianOplusXk(2 * prox_maxN + k, k) = cst(-1.);
+          //_jacobianOplusXk(2 * prox_maxN + k, k) = -sign(vk[k]) / (2. * sqrt(fabs(vk[k])));
+          //_jacobianOplusXk(2 * prox_maxN + k, k) = -dvk[k];
+
+      /*
+      cout << this->id() << " : " << _vertices[0]->id() << endl;
+      for (int i = 0; i < 20; i++) {
+          if (_jacobianOplusXi.col(0)[i] == 0.) break;
+          cout << _jacobianOplusXi.col(0)[i] << ", ";
+      }
+      cout << endl;
+      for (int i = 0; i < 20; i++) {
+          if (_jacobianOplusXi.col(1)[i] == 0.) break;
+          cout << _jacobianOplusXi.col(1)[i] << ", ";
+      }
+      cout << endl;
+      for (int i = 0; i < 20; i++) {
+          if (_jacobianOplusXi.col(2)[i] == 0.) break;
+          cout << _jacobianOplusXi.col(2)[i] << ", ";
+      }
+      cout << endl << endl;
+      cout << this->id() << " : " << _vertices[1]->id() << endl;
+      for (int i = 0; i < 20; i++) {
+          if (_jacobianOplusXj.col(0)[i] == 0.) break;
+          cout << _jacobianOplusXj.col(0)[i] << ", ";
+      }
+      cout << endl;
+      for (int i = 0; i < 20; i++) {
+          if (_jacobianOplusXj.col(1)[i] == 0.) break;
+          cout << _jacobianOplusXj.col(1)[i] << ", ";
+      }
+      cout << endl;
+      for (int i = 0; i < 20; i++) {
+          if (_jacobianOplusXj.col(2)[i] == 0.) break;
+          cout << _jacobianOplusXj.col(2)[i] << ", ";
+      }
+      cout << endl << endl;
+      */
+  }
+#endif
+
+  bool EdgeSwitchProx::setMeasurementFromState(){
+      /*
+      VertexSE2Proximity* from_node = static_cast<VertexSE2Proximity*>(_vertices[0]);
+      VertexSE2Proximity* to_node = static_cast<VertexSE2Proximity*>(_vertices[1]);
+      
+      _measurement = from_node->estimate().inverse() * to_node->estimate();
+      */
+    return true;
+  }
+
+
+  void EdgeSwitchProx::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* /*to_*/)
+  {
+    /*
+    VertexSE2Proximity* from_node = dynamic_cast<VertexSE2Proximity*>(_vertices[0]);
+    VertexSE2Proximity* to_node = dynamic_cast<VertexSE2Proximity*>(_vertices[1]);
+    if (from.count(from_node) > 0)
+        to_node->setEstimate(from_node->estimate() * _measurement);
+    else
+        from_node->setEstimate(to_node->estimate() * _measurement.inverse());
+    */
+  }
+
+  inline Vector2 EdgeSwitchProx::from_prox(int i) const {
+      if (0 <= i && i < _num_prox_pairs)
+          return dynamic_cast<VertexProx*>(_vertices[0])->proximity(_prox_pairs[0][i]);
+      cerr << "out of range" << endl;
+      return Vector2();
+  };
+  inline Vector2 EdgeSwitchProx::to_prox(int i) const {
+      if (0 <= i && i < _num_prox_pairs)
+          return dynamic_cast<VertexProx*>(_vertices[1])->proximity(_prox_pairs[1][i]);
+      cerr << "out of range" << endl;
+      return Vector2();
+  };
+  inline Vector2 EdgeSwitchProx::from_gr_prox(int i) const {
+      if (0 <= i && i < _num_prox_pairs) {
+          Vector2 fp = from_prox(i);
+          if (fp == Vector2()) return Vector2();
+          return (dynamic_cast<VertexProx*>(_vertices[0])->estimate() * fp);
+      }
+      cerr << "out of range" << endl;
+      return Vector2();
+  };
+  inline Vector2 EdgeSwitchProx::to_gr_prox(int i) const {
+      if (0 <= i && i < _num_prox_pairs) {
+          Vector2 tp = to_prox(i);
+          if (tp == Vector2()) return Vector2();
+          return (dynamic_cast<VertexProx*>(_vertices[1])->estimate() * tp);
+      }
+      cerr << "out of range" << endl;
+      return Vector2();
+  };
+
+#ifdef G2O_HAVE_OPENGL
+  EdgeSwitchProxDrawAction::EdgeSwitchProxDrawAction()
+      : DrawAction(typeid(EdgeSwitchProx).name()), _triangleX(nullptr), _triangleY(nullptr), _triangleZ(nullptr) {}
+
+  bool EdgeSwitchProxDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_) {
+      if (!DrawAction::refreshPropertyPtrs(params_))
+          return false;
+      if (_previousParams) {
+          _triangleX = _previousParams->makeProperty<FloatProperty>(_typeName + "::N_Edge_Arrow_Length", .0f);
+          _triangleY = _previousParams->makeProperty<FloatProperty>(_typeName + "::N_Edge_Width", 3.0f);
+          _triangleZ = _previousParams->makeProperty<FloatProperty>(_typeName + "::P_Edge_Width", 2.0f);
+      }
+      else {
+          _triangleX = 0;
+          _triangleY = 0;
+          _triangleZ = 0;
+      }
+      return true;
+  }
+
+  HyperGraphElementAction* EdgeSwitchProxDrawAction::operator()(HyperGraph::HyperGraphElement* element,
+      HyperGraphElementAction::Parameters* params_) {
+      if (typeid(*element).name() != _typeName)
+          return nullptr;
+
+      refreshPropertyPtrs(params_);
+      if (!_previousParams)
+          return this;
+
+      if (_show && !_show->value())
+          return this;
+
+      EdgeSwitchProx* e = static_cast<EdgeSwitchProx*>(element);
+      VertexProx* from = static_cast<VertexProx*>(e->vertex(0));
+      VertexProx* to = static_cast<VertexProx*>(e->vertex(1));
+      if (!from && !to)
+          return this;
+      SE2 fromTransform;
+      SE2 toTransform;
+      glPushAttrib(GL_ENABLE_BIT | GL_LIGHTING | GL_COLOR);
+      glDisable(GL_LIGHTING);
+      /*
+      if (!from) {
+          glColor3f(POSE_EDGE_GHOST_COLOR);
+          toTransform = to->estimate();
+          fromTransform = to->estimate() * e->measurement().inverse();
+          // DRAW THE FROM EDGE AS AN ARROW
+          glPushMatrix();
+          glTranslatef((float)fromTransform.translation().x(), (float)fromTransform.translation().y(), 0.f);
+          glRotatef((float)RAD2DEG(fromTransform.rotation().angle()), 0.f, 0.f, 1.f);
+          opengl::drawArrow2D((float)_triangleX->value(), (float)_triangleY->value(), (float)_triangleX->value() * .3f);
+          glPopMatrix();
+      }
+      else if (!to) {
+          glColor3f(POSE_EDGE_GHOST_COLOR);
+          fromTransform = from->estimate();
+          toTransform = from->estimate() * e->measurement();
+          // DRAW THE TO EDGE AS AN ARROW
+          glPushMatrix();
+          glTranslatef(toTransform.translation().x(), toTransform.translation().y(), 0.f);
+          glRotatef((float)RAD2DEG(toTransform.rotation().angle()), 0.f, 0.f, 1.f);
+          opengl::drawArrow2D((float)_triangleX->value(), (float)_triangleY->value(), (float)_triangleX->value() * .3f);
+          glPopMatrix();
+      }
+      */
+      { //else {
+          glColor3f(POSE_EDGE_COLOR);
+          fromTransform = from->estimate();
+          toTransform = to->estimate();
+      }
+      //glGetFloatv(GL_LINE_WIDTH, &(float)_triangleY->value());
+      if (_triangleY->value() != 0) {
+          glLineWidth((float)_triangleY->value());
+          glBegin(GL_LINES);
+          glVertex3f((float)fromTransform.translation().x(), (float)fromTransform.translation().y(), 0.f);
+          glVertex3f((float)toTransform.translation().x(), (float)toTransform.translation().y(), 0.f);
+          glEnd();
+      }
+      //glGetFloatv(GL_LINE_WIDTH, &(float)_triangleZ->value());
+      if (_triangleZ->value() != 0) {
+          glLineWidth((float)_triangleZ->value());
+          glColor3f(LANDMARK_EDGE_COLOR);
+          glBegin(GL_LINES);
+          for (int i = 0; i < e->num_prox_pairs(); i++) {
+              glVertex3f((float)e->from_gr_prox(i).x(), (float)e->from_gr_prox(i).y(), 0.f);
+              glVertex3f((float)e->to_gr_prox(i).x(), (float)e->to_gr_prox(i).y(), 0.f);
+          }
+      }
+      glEnd();
+      glPopAttrib();
+      return this;
+  }
+#endif
+}
diff --git a/g2o/types/slam2d/edge_em_prox.h b/g2o/types/slam2d/edge_em_prox.h
new file mode 100644
index 00000000..d09a7956
--- /dev/null
+++ b/g2o/types/slam2d/edge_em_prox.h
@@ -0,0 +1,98 @@
+// This class was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#ifndef G2O_EDGE_SWITCHING_PROX_H_
+#define G2O_EDGE_SWITCHING_PROX_H_
+
+//#define NUMERIC_JACOBIAN_TWO_D_TYPES
+
+#include "g2o/core/base_ternary_edge.h"
+#include "vertex_prox.h"
+#include "vertex_switch_pp.h"
+#include "parameter_switch_weight.h"
+
+//#include "vertex_se2.h"
+#include "g2o_types_slam2d_api.h"
+
+#ifndef prox_maxN
+#define prox_maxN 10
+#endif
+
+namespace g2o {
+    class G2O_TYPES_SLAM2D_API EdgeSwitchProx : public BaseTernaryEdge < 3 * prox_maxN, std::array<int, 2 * prox_maxN>, VertexProx, VertexProx, VertexSwitchProxPair > {
+  public:
+      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+          EdgeSwitchProx();
+      virtual bool read(std::istream& is);
+      virtual bool write(std::ostream& os) const;
+
+      void computeError();
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+      virtual void linearizeOplus();
+#endif
+
+      virtual void setMeasurement(const std::array<int, 2 * prox_maxN> m) {
+          for (int i = 0; i < 2 * prox_maxN; i++)
+              _measurement[i] = m[i];
+      }
+
+      virtual void setMeasurement(const int m[2 * prox_maxN]) {
+          for (int i = 0; i < 2 * prox_maxN; i++)
+              _measurement[i] = m[i];
+      }
+
+      virtual bool setMeasurementData(const int* d) {
+          for(int i = 0; i < 2 * prox_maxN; i++)
+              _measurement[i] = d[i];
+          return true;
+      }
+
+      virtual bool setMeasurementData(const int d) {
+          for (int i = 0; i < 2 * prox_maxN; i++)
+              _measurement[i] = d;
+          return true;
+      }
+
+      virtual bool getMeasurementData(int d[2 * prox_maxN]) const {
+          for (int i = 0; i < 2 * prox_maxN; i++)
+              d[i] = _measurement[i];
+          return true;
+      }
+
+      virtual int measurementDimension() const { return 3; }
+
+      virtual bool setMeasurementFromState();
+
+      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to) {
+          (void)to;
+          return (from.count(_vertices[0]) == 1 ? 1.0 : -1.0);
+      }
+
+      virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
+
+      virtual inline Vector2 from_prox(int i) const;
+      virtual inline Vector2 to_prox(int i) const;
+      virtual inline Vector2 from_gr_prox(int i) const;
+      virtual inline Vector2 to_gr_prox(int i) const;
+      virtual inline int num_prox_pairs() const { return _num_prox_pairs; };
+
+  private:
+      int _prox_pairs[2][prox_maxN];
+      int _num_prox_pairs;
+      ParameterSwitchWeight* _ProxPairWeightInfo;
+      number_t info;
+  };
+
+#ifdef G2O_HAVE_OPENGL
+  class G2O_TYPES_SLAM2D_API EdgeSwitchProxDrawAction : public DrawAction {
+  public:
+      EdgeSwitchProxDrawAction();
+      virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
+          HyperGraphElementAction::Parameters* params_);
+  protected:
+      virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
+      FloatProperty* _triangleX, * _triangleY, * _triangleZ;
+  };
+#endif
+
+}
+#endif
diff --git a/g2o/types/slam2d/edge_em_se2.cpp b/g2o/types/slam2d/edge_em_se2.cpp
new file mode 100644
index 00000000..c87f048d
--- /dev/null
+++ b/g2o/types/slam2d/edge_em_se2.cpp
@@ -0,0 +1,220 @@
+// g2o - General Graph Optimization
+// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright
+//   notice, this list of conditions and the following disclaimer in the
+//   documentation and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "edge_em_se2.h"
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+
+  EdgeSwitchSE2::EdgeSwitchSE2() :
+      BaseBinaryEdge<3, SE2, VertexSE2, VertexSE2>(), info(1.)
+  {
+      _WeightInfo = 0;
+      resizeParameters(1);
+      installParameter(_WeightInfo, 0);
+  }
+
+  bool EdgeSwitchSE2::read(std::istream& is)
+  {
+    Vector3 p;
+    internal::readVector(is, p);
+    setMeasurement(SE2(p));
+    _inverseMeasurement = measurement().inverse();
+    information().setZero();
+    for (int i = 0; i < 3 && is.good(); ++i)
+        for (int j = i; j < 3 && is.good(); ++j) {
+            is >> information()(i, j);
+            if (i != j) information()(j, i) = information()(i, j);
+        }
+    if (!setParameterId(0, 0))
+        return false;
+    resolveParameters();
+    info = _WeightInfo->Info();
+    information()(3, 3) = info;
+    return true;
+  }
+
+  bool EdgeSwitchSE2::write(std::ostream& os) const
+  {
+    internal::writeVector(os, measurement().toVector());
+    return writeInformationMatrix(os);
+  }
+
+  void EdgeSwitchSE2::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* /* to */)
+  {
+    VertexSE2* fromEdge = static_cast<VertexSE2*>(_vertices[0]);
+    VertexSE2* toEdge   = static_cast<VertexSE2*>(_vertices[1]);
+    if (from.count(fromEdge) > 0)
+      toEdge->setEstimate(fromEdge->estimate() * _measurement);
+    else
+      fromEdge->setEstimate(toEdge->estimate() * _inverseMeasurement);
+  }
+
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+  void EdgeSwitchSE2::linearizeOplus()
+  {
+    //const VertexSE2* vi = static_cast<const VertexSE2*>(_vertices[0]);
+    //const VertexSE2* vj = static_cast<const VertexSE2*>(_vertices[1]);
+    //number_t thetai = vi->estimate().rotation().angle();
+
+    //Vector2 dt = vj->estimate().translation() - vi->estimate().translation();
+    //number_t si=std::sin(thetai), ci=std::cos(thetai);
+
+    //_jacobianOplusXi <<
+    //    -ci, -si, -si*dt.x()+ci*dt.y(),
+    //     si, -ci, -ci*dt.x()-si*dt.y(),
+    //     0,  0,   -1;
+
+    //_jacobianOplusXj <<
+    //     ci, si, 0,
+    //    -si, ci, 0,
+    //     0,  0,  1;
+
+    //const SE2& rmean = _inverseMeasurement;
+    //Matrix3 z;
+    //z.block<2, 2>(0, 0) = rmean.rotation().toRotationMatrix();
+    //z.col(2) << cst(0.), cst(0.), cst(1.);
+    //z.row(2).head<2>() << cst(0.), cst(0.);
+    //_jacobianOplusXi = z * _jacobianOplusXi;
+    //_jacobianOplusXj = z * _jacobianOplusXj;
+      const VertexSE2* vi = static_cast<const VertexSE2*>(_vertices[0]);
+      const VertexSE2* vj = static_cast<const VertexSE2*>(_vertices[1]);
+      SE2 delta = _inverseMeasurement * (vi->estimate().inverse() * vj->estimate());
+      delta.setRotation(Rotation2D(normalize_theta(delta.rotation().angle())));
+
+      Vector2 dt = vj->estimate().translation() - vi->estimate().translation();
+      Matrix2 dR = vi->estimate().rotation().toRotationMatrix().transpose() * vj->estimate().rotation().toRotationMatrix();
+      const SE2& rmean = _inverseMeasurement;
+      Vector2 z = rmean.rotation().toRotationMatrix() * vi->estimate().rotation().toRotationMatrix().transpose() * dt;
+
+      _jacobianOplusXi.setZero();
+      _jacobianOplusXi.block<2, 2>(0, 0) = - s * rmean.rotation().toRotationMatrix();
+      _jacobianOplusXi.col(2) = s * Vector4{ z.y(), -z.x(), -1., 0. };
+      _jacobianOplusXj.setZero();
+      _jacobianOplusXj.block<2, 2>(0, 0) = s * rmean.rotation().toRotationMatrix() * dR;
+      _jacobianOplusXj(2,2) = s;
+  }
+#endif
+
+  EdgeSwitchSE2WriteGnuplotAction::EdgeSwitchSE2WriteGnuplotAction(): WriteGnuplotAction(typeid(EdgeSwitchSE2).name()){}
+
+  HyperGraphElementAction* EdgeSwitchSE2WriteGnuplotAction::operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* params_){
+    if (typeid(*element).name()!=_typeName)
+      return nullptr;
+    WriteGnuplotAction::Parameters* params=static_cast<WriteGnuplotAction::Parameters*>(params_);
+    if (!params->os){
+      std::cerr << __PRETTY_FUNCTION__ << ": warning, on valid os specified" << std::endl;
+      return nullptr;
+    }
+
+    EdgeSwitchSE2* e =  static_cast<EdgeSwitchSE2*>(element);
+    VertexSE2* fromEdge = static_cast<VertexSE2*>(e->vertex(0));
+    VertexSE2* toEdge   = static_cast<VertexSE2*>(e->vertex(1));
+    *(params->os) << fromEdge->estimate().translation().x() << " " << fromEdge->estimate().translation().y()
+      << " " << fromEdge->estimate().rotation().angle() << std::endl;
+    *(params->os) << toEdge->estimate().translation().x() << " " << toEdge->estimate().translation().y()
+      << " " << toEdge->estimate().rotation().angle() << std::endl;
+    *(params->os) << std::endl;
+    return this;
+  }
+
+#ifdef G2O_HAVE_OPENGL
+  EdgeSwitchSE2DrawAction::EdgeSwitchSE2DrawAction()
+      : DrawAction(typeid(EdgeSwitchSE2).name()), _triangleX(nullptr), _triangleY(nullptr) {}
+
+  bool EdgeSwitchSE2DrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_){
+    if (!DrawAction::refreshPropertyPtrs(params_))
+      return false;
+    if (_previousParams){
+      _triangleX = _previousParams->makeProperty<FloatProperty>(_typeName + "::GHOST_TRIANGLE_X", .2f);
+      _triangleY = _previousParams->makeProperty<FloatProperty>(_typeName + "::GHOST_TRIANGLE_Y", .05f);
+    } else {
+      _triangleX = 0;
+      _triangleY = 0;
+    }
+    return true;
+  }
+
+  HyperGraphElementAction* EdgeSwitchSE2DrawAction::operator()(HyperGraph::HyperGraphElement* element,
+               HyperGraphElementAction::Parameters* params_){
+    if (typeid(*element).name()!=_typeName)
+      return nullptr;
+
+    refreshPropertyPtrs(params_);
+    if (! _previousParams)
+      return this;
+
+    if (_show && !_show->value())
+      return this;
+
+    EdgeSwitchSE2* e =  static_cast<EdgeSwitchSE2*>(element);
+    VertexSE2* from = static_cast<VertexSE2*>(e->vertex(0));
+    VertexSE2* to   = static_cast<VertexSE2*>(e->vertex(1));
+    if (! from && ! to)
+      return this;
+    SE2 fromTransform;
+    SE2 toTransform;
+    glPushAttrib(GL_ENABLE_BIT | GL_LIGHTING | GL_COLOR);
+    glDisable(GL_LIGHTING);
+    if (! from) {
+      glColor3f(POSE_EDGE_GHOST_COLOR);
+      toTransform = to->estimate();
+      fromTransform = to->estimate()*e->measurement().inverse();
+      // DRAW THE FROM EDGE AS AN ARROW
+      glPushMatrix();
+      glTranslatef((float)fromTransform.translation().x(), (float)fromTransform.translation().y(),0.f);
+      glRotatef((float)RAD2DEG(fromTransform.rotation().angle()),0.f,0.f,1.f);
+      opengl::drawArrow2D((float)_triangleX->value(), (float)_triangleY->value(), (float)_triangleX->value()*.3f);
+      glPopMatrix();
+    } else if (! to){
+      glColor3f(POSE_EDGE_GHOST_COLOR);
+      fromTransform = from->estimate();
+      toTransform = from->estimate()*e->measurement();
+      // DRAW THE TO EDGE AS AN ARROW
+      glPushMatrix();
+      glTranslatef(toTransform.translation().x(),toTransform.translation().y(),0.f);
+      glRotatef((float)RAD2DEG(toTransform.rotation().angle()),0.f,0.f,1.f);
+      opengl::drawArrow2D((float)_triangleX->value(), (float)_triangleY->value(), (float)_triangleX->value()*.3f);
+      glPopMatrix();
+    } else {
+      glColor3f(POSE_EDGE_COLOR);
+      fromTransform = from->estimate();
+      toTransform = to->estimate();
+    }
+    glBegin(GL_LINES);
+    glVertex3f((float)fromTransform.translation().x(),(float)fromTransform.translation().y(),0.f);
+    glVertex3f((float)toTransform.translation().x(),(float)toTransform.translation().y(),0.f);
+    glEnd();
+    glPopAttrib();
+    return this;
+  }
+#endif
+
+} // end namespace
diff --git a/g2o/types/slam2d/edge_em_se2.h b/g2o/types/slam2d/edge_em_se2.h
new file mode 100644
index 00000000..a2199848
--- /dev/null
+++ b/g2o/types/slam2d/edge_em_se2.h
@@ -0,0 +1,126 @@
+// g2o - General Graph Optimization
+// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright
+//   notice, this list of conditions and the following disclaimer in the
+//   documentation and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef G2O_EDGE_EXPECTMAXIM_SE2_H
+#define G2O_EDGE_EXPECTMAXIM_SE2_H
+
+//#define NUMERIC_JACOBIAN_TWO_D_TYPES
+
+#include "vertex_se2.h"
+#include "vertex_switch.h"
+#include "parameter_switch_weight.h"
+#include "g2o/config.h"
+#include "g2o/core/base_binary_edge.h"
+#include "g2o_types_slam2d_api.h"
+
+namespace g2o {
+
+  /**
+   * \brief 2D edge between two Vertex2
+   */
+  class G2O_TYPES_SLAM2D_API EdgeSwitchSE2 : public BaseBinaryEdge<3, SE2, VertexSE2, VertexSE2>
+  {
+    public:
+      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+          EdgeSwitchSE2();
+
+      void computeError()
+      {
+        const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
+        const VertexSE2* v2 = static_cast<const VertexSE2*>(_vertices[1]);
+        SE2 delta = _inverseMeasurement * (v1->estimate().inverse()*v2->estimate());
+        delta.setRotation(Rotation2D(normalize_theta(delta.rotation().angle())));
+        _error.block<3,1>(0,0) = s * delta.toVector();
+      }
+      virtual bool read(std::istream& is);
+      virtual bool write(std::ostream& os) const;
+
+      virtual void setMeasurement(const SE2& m){
+        _measurement = m;
+        _inverseMeasurement = m.inverse();
+      }
+
+      virtual bool setMeasurementData(const number_t* d){
+        _measurement=SE2(d[0], d[1], d[2]);
+        _inverseMeasurement = _measurement.inverse();
+        return true;
+      }
+
+      virtual bool getMeasurementData(number_t* d) const {
+        Vector3 v=_measurement.toVector();
+        d[0] = v[0];
+        d[1] = v[1];
+        d[2] = v[2];
+        return true;
+      }
+
+      virtual int measurementDimension() const {return 3;}
+
+      virtual bool setMeasurementFromState() {
+        const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
+        const VertexSE2* v2 = static_cast<const VertexSE2*>(_vertices[1]);
+        _measurement = v1->estimate().inverse()*v2->estimate();
+        _inverseMeasurement = _measurement.inverse();
+        return true;
+      }
+
+
+      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& , OptimizableGraph::Vertex* ) { return 1.;}
+      virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+      virtual void linearizeOplus();
+#endif
+    protected:
+      SE2 _inverseMeasurement;
+
+  private:
+      ParameterSwitchWeight* _WeightInfo;
+      number_t info;
+      number_t s;
+  };
+
+  class G2O_TYPES_SLAM2D_API EdgeSwitchSE2WriteGnuplotAction: public WriteGnuplotAction {
+  public:
+    EdgeSwitchSE2WriteGnuplotAction();
+    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
+            HyperGraphElementAction::Parameters* params_);
+  };
+
+#ifdef G2O_HAVE_OPENGL
+  class G2O_TYPES_SLAM2D_API EdgeSwitchSE2DrawAction: public DrawAction{
+  public:
+    EdgeSwitchSE2DrawAction();
+    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
+            HyperGraphElementAction::Parameters* params_);
+  protected:
+    virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
+    FloatProperty *_triangleX, *_triangleY;
+  };
+#endif
+
+} // end namespace
+
+#endif
diff --git a/g2o/types/slam2d/edge_prox.cpp b/g2o/types/slam2d/edge_prox.cpp
new file mode 100644
index 00000000..c287f40c
--- /dev/null
+++ b/g2o/types/slam2d/edge_prox.cpp
@@ -0,0 +1,287 @@
+// This library was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#include "edge_prox.h"
+#include <iostream>
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+  using namespace std;
+
+
+  // point to camera projection, monocular
+#ifndef UseCache
+  EdgeProx::EdgeProx()
+      : BaseBinaryEdge<20, array<int, 2 * prox_maxN>, VertexProx, VertexProx>(), _num_prox_pairs(0), _prox_pairs() {
+    information().setZero();
+  }
+#else
+  EdgeProx::EdgeProx()
+      : BaseBinaryEdge<20, array<int, 2 * prox_maxN>, VertexProx, VertexProx>() {
+      information().setZero();
+      _cacheFrom = 0;
+      _cacheTo = 0;
+  }
+
+  bool EdgeProx::resolveCaches() {
+      ParameterVector pv(0);
+      resolveCache(_cacheFrom, (OptimizableGraph::Vertex*)_vertices[0],
+          "CACHE_PROXIMITY", pv);
+      resolveCache(_cacheTo, (OptimizableGraph::Vertex*)_vertices[1],
+          "CACHE_PROXIMITY", pv);
+      return (_cacheFrom && _cacheTo);
+  }
+#endif
+
+  bool EdgeProx::read(std::istream& is) {
+    // measured keypoint
+    setMeasurementData(0);
+    if (is.bad()) return false;
+    //readInformationMatrix(is);
+    //  we overwrite the information matrix in case of read errors
+    //if (is.bad()) information().setIdentity();
+    information().setZero();
+    int n;
+    is >> n;
+#ifndef UseCache
+    _num_prox_pairs = 0;
+    for (int i = 0; i < n && i < prox_maxN; i++) {
+        is >> _prox_pairs[0][i] >> _prox_pairs[1][i];
+        double info;
+        is >> info;
+        information()(2 * i, 2 * i) = info;
+        information()(2 * i + 1, 2 * i + 1) = info;
+        if (is.bad()) return false;
+        _num_prox_pairs = i + 1;
+    }
+#else
+    std::array<std::array<Vector2, prox_maxN>, 2> _prox_points;
+    for (int i = 0; i < n && i < prox_maxN; i++) {
+        is >> _prox_pairs[0][i] >> _prox_pairs[1][i];
+        _prox_points[0][i] = dynamic_cast<VertexProx*>(_vertices[0])->proximity(_prox_pairs[0][i]);
+        _prox_points[1][i] = dynamic_cast<VertexProx*>(_vertices[1])->proximity(_prox_pairs[1][i]);
+        double info;
+        is >> info;
+        information()(2 * i, 2 * i) = info;
+        information()(2 * i + 1, 2 * i + 1) = info;
+        if (is.bad()) return false;
+    }
+    _cacheFrom->setLocalProx(_prox_points[0]);
+    _cacheTo->setLocalProx(_prox_points[1]);
+#endif
+    return true;
+  }
+
+  bool EdgeProx::write(std::ostream& os) const {
+      int n = _num_prox_pairs;
+      os << _num_prox_pairs << " ";
+      for (int i = 0; i < _num_prox_pairs && i < prox_maxN; i++) {
+          double info;
+          os << _prox_pairs[0][i] << " " << _prox_pairs[1][i] << " " << information()(2*i, 2*i) << " ";
+      }
+      return true;
+  }
+
+  void EdgeProx::computeError() {
+#ifndef UseCache
+      const SE2 vi = dynamic_cast<VertexProx*>(_vertices[0])->estimate();
+      const SE2 vj = dynamic_cast<VertexProx*>(_vertices[1])->estimate();
+      for (int k = 0; k < _num_prox_pairs && k < prox_maxN; k++) {
+          const Vector2 ri = from_prox(k),  rj = to_prox(k), qi = from_gr_prox(k), qj = to_gr_prox(k);
+          if (ri == Vector2() || rj == Vector2() || qi == Vector2() || qj == Vector2()) continue;
+          const Vector2 ei = vi.rotation() * ri, ej = vj.rotation() * rj;
+          const number_t li = cst((ei / ri.norm()).dot(qj - qi)), lj = cst((ej / rj.norm()).dot(qi - qj));
+          _error.block<2, 1>(2*k, 0) << li, lj;
+      }
+#else
+      for (int i = 0; i < _num_prox_pairs && i < prox_maxN; i++) {
+          const number_t fl = cst(f()->e(i).dot(t()->q(i) - f()->q(i))), tl = cst(t()->e(i).dot(f()->q(i) - t()->q(i)));
+          _error.block<2, 1>(2 * i, 0) << fl, tl;
+      }
+#endif
+  }
+
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+  void EdgeProx::linearizeOplus() {
+      _jacobianOplusXi.setZero();
+      _jacobianOplusXj.setZero();
+#ifndef UseCache
+      const SE2 vi = dynamic_cast<VertexProx*>(_vertices[0])->estimate();
+      const SE2 vj = dynamic_cast<VertexProx*>(_vertices[1])->estimate();
+      const Vector2 dt = vj.translation() - vi.translation();
+      const Matrix2 Ri = vi.rotation().toRotationMatrix(),
+          Rj = vj.rotation().toRotationMatrix(),
+          dR = Ri.transpose() * Rj;
+      for (int k = 0; k < _num_prox_pairs && k < prox_maxN; k++) {
+          const Vector2 ri = from_prox(k), rj = to_prox(k);
+          if (ri == Vector2() || rj == Vector2()) continue;
+          const number_t ni = 1. / ri.norm(), nj = 1. / rj.norm();
+          Vector2 z;
+
+          _jacobianOplusXi.block<1, 2>(2*k, 0) = -ri;
+          _jacobianOplusXj.block<1, 2>(2*k, 0) = dR.transpose() * ri;
+          z = dR * rj + Ri.transpose() * dt;
+          _jacobianOplusXi(2*k, 2) = ri.x() * z.y() - ri.y() * z.x();
+          z = dR * rj;
+          _jacobianOplusXj(2*k, 2) = -ri.x() * z.y() + ri.y() * z.x();
+          _jacobianOplusXi.block<1, 3>(2*k, 0) = _jacobianOplusXi.block<1, 3>(2*k, 0) * ni;
+          _jacobianOplusXj.block<1, 3>(2*k, 0) = _jacobianOplusXj.block<1, 3>(2*k, 0) * ni;
+          _jacobianOplusXj.block<1, 2>(2*k+1, 0) = -rj;
+          _jacobianOplusXi.block<1, 2>(2*k+1, 0) = dR * rj;
+          z = dR.transpose() * ri - Rj.transpose() * dt;
+          _jacobianOplusXj(2*k+1, 2) = rj.x() * z.y() - rj.y() * z.x();
+          z = dR.transpose() * ri;
+          _jacobianOplusXi(2*k+1, 2) = -rj.x() * z.y() + rj.y() * z.x();
+          _jacobianOplusXj.block<1, 3>(2*k+1, 0) = _jacobianOplusXj.block<1, 3>(2*k+1, 0) * nj;
+          _jacobianOplusXi.block<1, 3>(2*k+1, 0) = _jacobianOplusXi.block<1, 3>(2*k+1, 0) * nj;
+      }
+#else
+      const SE2 vi = dynamic_cast<VertexProx*>(_vertices[0])->estimate();
+      const SE2 vj = dynamic_cast<VertexProx*>(_vertices[1])->estimate();
+      const Matrix2 Ri = vi.rotation().toRotationMatrix(),
+          Rj = vj.rotation().toRotationMatrix();
+      for (int k = 0; k < _num_prox_pairs && k < prox_maxN; k++) {
+          _jacobianOplusXi.block<1, 2>(2 * k, 0) = -f()->u(k);
+          _jacobianOplusXj.block<1, 2>(2 * k, 0) = Rj.transpose() * f()->e(k);
+          _jacobianOplusXi(2 * k, 2) = f()->de(k).dot(t()->q(k) - f()->q(k)) - f()->u(k).dot(f()->dq(k));
+          _jacobianOplusXj(2 * k, 2) = f()->u(k).dot(t()->dq(k));
+          _jacobianOplusXj.block<1, 2>(2 * k + 1, 0) = -t()->u(k);
+          _jacobianOplusXi.block<1, 2>(2 * k + 1, 0) = Ri.transpose() * t()->e(k);
+          _jacobianOplusXj(2 * k + 1, 2) = t()->de(k).dot(f()->q(k) - t()->q(k)) - t()->u(k).dot(t()->dq(k));
+          _jacobianOplusXi(2 * k + 1, 2) = t()->u(k).dot(f()->dq(k));
+      }
+#endif
+  }
+#endif
+
+  bool EdgeProx::setMeasurementFromState(){
+      //VertexSE2Proximity* from_node = static_cast<VertexSE2Proximity*>(_vertices[0]);
+      //VertexSE2Proximity* to_node = static_cast<VertexSE2Proximity*>(_vertices[1]);
+      //_measurement = from_node->estimate().inverse() * to_node->estimate();
+    return true;
+  }
+
+
+  void EdgeProx::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* /*to_*/)
+  {
+    //VertexSE2Proximity* from_node = dynamic_cast<VertexSE2Proximity*>(_vertices[0]);
+    //VertexSE2Proximity* to_node = dynamic_cast<VertexSE2Proximity*>(_vertices[1]);
+    //if (from.count(from_node) > 0)
+    //    to_node->setEstimate(from_node->estimate() * _measurement);
+    //else
+    //    from_node->setEstimate(to_node->estimate() * _measurement.inverse());
+  }
+
+#ifndef UseCache
+  inline Vector2 EdgeProx::from_prox(int i) const {
+      if (0 <= i && i < _num_prox_pairs)
+          return dynamic_cast<VertexProx*>(_vertices[0])->proximity(_prox_pairs[0][i]);
+      cerr << "out of range" << endl;
+      return Vector2();
+  };
+  inline Vector2 EdgeProx::to_prox(int i) const {
+      if (0 <= i && i < _num_prox_pairs)
+          return dynamic_cast<VertexProx*>(_vertices[1])->proximity(_prox_pairs[1][i]);
+      cerr << "out of range" << endl;
+      return Vector2();
+  };
+  inline Vector2 EdgeProx::from_gr_prox(int i) const {
+      if (0 <= i && i < _num_prox_pairs) {
+          Vector2 fp = from_prox(i);
+          if (fp == Vector2()) return Vector2();
+          return (dynamic_cast<VertexProx*>(_vertices[0])->estimate() * fp);
+      }
+      cerr << "out of range" << endl;
+      return Vector2();
+  };
+  inline Vector2 EdgeProx::to_gr_prox(int i) const {
+      if (0 <= i && i < _num_prox_pairs) {
+          Vector2 tp = to_prox(i);
+          if (tp == Vector2()) return Vector2();
+          return (dynamic_cast<VertexProx*>(_vertices[1])->estimate() * tp);
+      }
+      cerr << "out of range" << endl;
+      return Vector2();
+  };
+#else
+
+#endif
+
+#ifdef G2O_HAVE_OPENGL
+  EdgeProxDrawAction::EdgeProxDrawAction()
+      : DrawAction(typeid(EdgeProx).name()), _triangleX(nullptr), _triangleY(nullptr), _triangleZ(nullptr) {}
+
+  bool EdgeProxDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_) {
+      if (!DrawAction::refreshPropertyPtrs(params_))
+          return false;
+      if (_previousParams) {
+          _triangleX = _previousParams->makeProperty<FloatProperty>(_typeName + "::N_Edge_Arrow_Length", .0f);
+          _triangleY = _previousParams->makeProperty<FloatProperty>(_typeName + "::N_Edge_Width", 3.0f);
+          _triangleZ = _previousParams->makeProperty<FloatProperty>(_typeName + "::P_Edge_Width", 2.0f);
+      }
+      else {
+          _triangleX = 0;
+          _triangleY = 0;
+          _triangleZ = 0;
+      }
+      return true;
+  }
+
+  HyperGraphElementAction* EdgeProxDrawAction::operator()(HyperGraph::HyperGraphElement* element,
+      HyperGraphElementAction::Parameters* params_) {
+      if (typeid(*element).name() != _typeName)
+          return nullptr;
+
+      refreshPropertyPtrs(params_);
+      if (!_previousParams)
+          return this;
+
+      if (_show && !_show->value())
+          return this;
+
+      EdgeProx* e = static_cast<EdgeProx*>(element);
+      VertexProx* from = static_cast<VertexProx*>(e->vertex(0));
+      VertexProx* to = static_cast<VertexProx*>(e->vertex(1));
+      if (!from && !to)
+          return this;
+      SE2 fromTransform;
+      SE2 toTransform;
+      glPushAttrib(GL_ENABLE_BIT | GL_LIGHTING | GL_COLOR);
+      glDisable(GL_LIGHTING);
+      glColor3f(POSE_EDGE_COLOR);
+      fromTransform = from->estimate();
+      toTransform = to->estimate();
+      //glGetFloatv(GL_LINE_WIDTH, &(float)_triangleY->value());
+      if (_triangleY->value() != 0) {
+          glLineWidth((float)_triangleY->value());
+          glBegin(GL_LINES);
+          glVertex3f((float)fromTransform.translation().x(), (float)fromTransform.translation().y(), 0.f);
+          glVertex3f((float)toTransform.translation().x(), (float)toTransform.translation().y(), 0.f);
+          glEnd();
+      }
+      //glGetFloatv(GL_LINE_WIDTH, &(float)_triangleZ->value());
+      if (_triangleZ->value() != 0) {
+          glLineWidth((float)_triangleZ->value());
+          glColor3f(LANDMARK_EDGE_COLOR);
+          glBegin(GL_LINES);
+#ifndef UseCache
+          for (int i = 0; i < e->num_prox_pairs(); i++) {
+              glVertex3f((float)e->from_gr_prox(i).x(), (float)e->from_gr_prox(i).y(), 0.f);
+              glVertex3f((float)e->to_gr_prox(i).x(), (float)e->to_gr_prox(i).y(), 0.f);
+          }
+#else
+          for (int i = 0; i < e->f()->numPP() && i < e->t()->numPP() && i < prox_maxN; i++) {
+              glVertex3f((float)e->f()->q(i).x(), (float)e->f()->q(i).y(), 0.f);
+              glVertex3f((float)e->t()->q(i).x(), (float)e->t()->q(i).y(), 0.f);
+          }
+#endif
+      }
+      glEnd();
+      glPopAttrib();
+      return this;
+  }
+#endif
+}
diff --git a/g2o/types/slam2d/edge_prox.h b/g2o/types/slam2d/edge_prox.h
new file mode 100644
index 00000000..0b875698
--- /dev/null
+++ b/g2o/types/slam2d/edge_prox.h
@@ -0,0 +1,112 @@
+// This library was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#ifndef G2O_EDGE_SE2_PROXIMITY_H_
+#define G2O_EDGE_SE2_PROXIMITY_H_
+
+//#define NUMERIC_JACOBIAN_TWO_D_TYPES
+#define UseCache
+
+#include "g2o/core/base_binary_edge.h"
+#include "vertex_prox.h"
+#include "g2o_types_slam2d_api.h"
+
+#ifdef UseCache
+#include "parameter_prox.h"
+#endif
+
+#ifndef prox_maxN
+#define prox_maxN 10
+#endif
+
+namespace g2o {
+
+    class G2O_TYPES_SLAM2D_API EdgeProx : public BaseBinaryEdge < 2 * prox_maxN, std::array<int, 2 * prox_maxN>, VertexProx, VertexProx > {
+  public:
+      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+          EdgeProx();
+
+#ifdef UseCache
+      virtual bool resolveCaches();
+#endif
+
+      virtual bool read(std::istream& is);
+      virtual bool write(std::ostream& os) const;
+
+      void computeError();
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+      virtual void linearizeOplus();
+#endif
+
+      virtual void setMeasurement(const std::array<int, 2 * prox_maxN> m) {
+          for (int i = 0; i < 2 * prox_maxN; i++)
+              _measurement[i] = m[i];
+      }
+
+      virtual void setMeasurement(const int m[2 * prox_maxN]) {
+          for (int i = 0; i < 2 * prox_maxN; i++)
+              _measurement[i] = m[i];
+      }
+
+      virtual bool setMeasurementData(const int* d) {
+          for(int i = 0; i < 2 * prox_maxN; i++)
+              _measurement[i] = d[i];
+          return true;
+      }
+
+      virtual bool setMeasurementData(const int d) {
+          for (int i = 0; i < 2 * prox_maxN; i++)
+              _measurement[i] = d;
+          return true;
+      }
+
+      virtual bool getMeasurementData(int d[2 * prox_maxN]) const {
+          for (int i = 0; i < 2 * prox_maxN; i++)
+              d[i] = _measurement[i];
+          return true;
+      }
+
+      virtual int measurementDimension() const { return 3; }
+
+      virtual bool setMeasurementFromState();
+
+      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to) {
+          (void)to;
+          return (from.count(_vertices[0]) == 1 ? 1.0 : -1.0);
+      }
+
+      virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
+
+#ifndef UseCache
+      virtual inline Vector2 from_prox(int i) const;
+      virtual inline Vector2 to_prox(int i) const;
+      virtual inline Vector2 from_gr_prox(int i) const;
+      virtual inline Vector2 to_gr_prox(int i) const;
+      virtual inline int num_prox_pairs() const { return _num_prox_pairs; };
+#else
+      const virtual inline CacheProximity* f() const { return _cacheFrom; };
+      const virtual inline CacheProximity* t() const { return _cacheTo; };
+#endif
+
+private:
+    std::array<std::array<int, prox_maxN>, 2> _prox_pairs;
+    int _num_prox_pairs;
+#ifdef UseCache
+    CacheProximity* _cacheFrom, * _cacheTo;
+#endif
+
+};
+
+#ifdef G2O_HAVE_OPENGL
+  class G2O_TYPES_SLAM2D_API EdgeProxDrawAction : public DrawAction {
+  public:
+      EdgeProxDrawAction();
+      virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
+          HyperGraphElementAction::Parameters* params_);
+  protected:
+      virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
+      FloatProperty* _triangleX, * _triangleY, * _triangleZ;
+  };
+#endif
+
+}
+#endif
diff --git a/g2o/types/slam2d/edge_se2.h b/g2o/types/slam2d/edge_se2.h
index afdf8e4e..ae47f01a 100644
--- a/g2o/types/slam2d/edge_se2.h
+++ b/g2o/types/slam2d/edge_se2.h
@@ -27,6 +27,8 @@
 #ifndef G2O_EDGE_SE2_H
 #define G2O_EDGE_SE2_H
 
+//#define NUMERIC_JACOBIAN_TWO_D_TYPES
+
 #include "g2o/config.h"
 #include "g2o/core/base_binary_edge.h"
 #include "g2o_types_slam2d_api.h"
@@ -50,6 +52,7 @@ class G2O_TYPES_SLAM2D_API EdgeSE2
         _inverseMeasurement * (v1->estimate().inverse() * v2->estimate());
     _error = delta.toVector();
   }
+  
   virtual bool read(std::istream& is);
   virtual bool write(std::ostream& os) const;
 
diff --git a/g2o/types/slam2d/edge_switch_prox.cpp b/g2o/types/slam2d/edge_switch_prox.cpp
new file mode 100644
index 00000000..77791749
--- /dev/null
+++ b/g2o/types/slam2d/edge_switch_prox.cpp
@@ -0,0 +1,311 @@
+// This class was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#include "edge_switch_prox.h"
+#include <iostream>
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+  using namespace std;
+
+
+  // point to camera projection, monocular
+  EdgeSwitchProx::EdgeSwitchProx()
+      : BaseTernaryEdge < 3 * prox_maxN, std::array<int, 2 * prox_maxN>, VertexProx, VertexProx, VertexSwitchProxPair >(), _num_prox_pairs(0), _prox_pairs(), info(1.) {
+      memset(_prox_pairs[0], 0, prox_maxN);
+      memset(_prox_pairs[1], 0, prox_maxN);
+    information().setZero();
+    _ProxPairWeightInfo = 0;
+    resizeParameters(1);
+    installParameter(_ProxPairWeightInfo, 0);
+  }
+
+  bool EdgeSwitchProx::read(std::istream& is) {
+    // measured keypoint
+    setMeasurementData(0);
+    if (is.bad()) return false;
+    //readInformationMatrix(is);
+    //  we overwrite the information matrix in case of read errors
+    //if (is.bad()) information().setIdentity();
+    information().setZero();
+    _num_prox_pairs = 0;
+    if (!setParameterId(0, 0))
+        return false;
+    resolveParameters();
+    info = _ProxPairWeightInfo->Info();
+    for(int i = 0; i < prox_maxN; i++)
+        information()(2 * prox_maxN + i, 2 * prox_maxN + i) = info;
+
+    int n;
+    is >> n;
+    for (int i = 0; i < n && i < prox_maxN; i++) {
+        is >> _prox_pairs[0][i] >> _prox_pairs[1][i];
+        double info;
+        is >> info;
+        information()(2*i, 2*i) = info;
+        information()(2*i+1, 2*i+1) = info;
+        if (is.bad()) return false;
+        _num_prox_pairs = i + 1;
+    }
+    return true;
+  }
+
+  bool EdgeSwitchProx::write(std::ostream& os) const {
+      int n = _num_prox_pairs;
+      os << _num_prox_pairs << " ";
+      for (int i = 0; i < _num_prox_pairs && i < prox_maxN; i++)
+          os << _prox_pairs[0][i] << " " << _prox_pairs[1][i] << " " << information()(2*i, 2*i) << " ";
+      return true;
+  }
+
+  void EdgeSwitchProx::computeError() {
+      const SE2 vi = dynamic_cast<VertexProx*>(_vertices[0])->estimate();
+      const SE2 vj = dynamic_cast<VertexProx*>(_vertices[1])->estimate();
+      //const std::array<number_t, prox_maxN> vk = sigmoid_est();
+      const std::array<number_t, prox_maxN> vk = dynamic_cast<VertexSwitchProxPair*>(_vertices[2])->estimate();
+      for (int k = 0; k < _num_prox_pairs && k < prox_maxN; k++) {
+          const Vector2 ri = from_prox(k),  rj = to_prox(k), qi = from_gr_prox(k), qj = to_gr_prox(k);
+          if (ri == Vector2() || rj == Vector2() || qi == Vector2() || qj == Vector2()) continue;
+          const Vector2 ei = vi.rotation() * ri, ej = vj.rotation() * rj;
+          const number_t li = cst((ei / ri.norm()).dot(qj - qi)), lj = cst((ej / rj.norm()).dot(qi - qj));
+          _error.block<2, 1>(2 * k, 0) << li * vk[k], lj * vk[k];
+      }
+      for (int k = 0; k < prox_maxN; k++)
+          _error(2 * prox_maxN + k) = cst(1.) - vk[k];
+          //_error(2 * prox_maxN + k) = cst(1.) - sqrt(fabs(vk[k]));
+  }
+
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+  void EdgeSwitchProx::linearizeOplus() {
+      _jacobianOplusXi.setZero();
+      _jacobianOplusXj.setZero();
+      _jacobianOplusXk.setZero();
+      const SE2 vi = dynamic_cast<VertexProx*>(_vertices[0])->estimate();
+      const SE2 vj = dynamic_cast<VertexProx*>(_vertices[1])->estimate();
+      //const std::array<number_t, prox_maxN> vk = sigmoid_est();
+      //const std::array<number_t, prox_maxN> dvk = def_sig_est();
+      const std::array<number_t, prox_maxN> vk = dynamic_cast<VertexSwitchProxPair*>(_vertices[2])->estimate();
+      const Vector2 dt = vj.translation() - vi.translation();
+      const Matrix2 Ri = vi.rotation().toRotationMatrix(),
+          Rj = vj.rotation().toRotationMatrix(),
+          dR = Ri.transpose() * Rj;
+      for (int k = 0; k < _num_prox_pairs && k < prox_maxN; k++) {
+          const Vector2 ri = from_prox(k), rj = to_prox(k), qi = from_gr_prox(k), qj = to_gr_prox(k);
+          if (ri == Vector2() || rj == Vector2() || qi == Vector2() || qj == Vector2()) continue;
+          const number_t ni = 1. / ri.norm(), nj = 1. / rj.norm();
+          const Vector2 ei = vi.rotation() * ri, ej = vj.rotation() * rj;
+          const number_t li = cst((ei * ni).dot(qj - qi)), lj = cst((ej * nj).dot(qi - qj));
+          Vector2 z;
+
+          _jacobianOplusXi.block<1, 2>(2*k, 0) = -ri;
+          _jacobianOplusXj.block<1, 2>(2*k, 0) = dR.transpose() * ri;
+          z = dR * rj + Ri.transpose() * dt;
+          _jacobianOplusXi(2*k, 2) = ri.x() * z.y() - ri.y() * z.x();
+          z = dR * rj;
+          _jacobianOplusXj(2*k, 2) = -ri.x() * z.y() + ri.y() * z.x();
+          _jacobianOplusXi.block<1, 3>(2*k, 0) = _jacobianOplusXi.block<1, 3>(2*k, 0) * ni * vk[k];
+          _jacobianOplusXj.block<1, 3>(2*k, 0) = _jacobianOplusXj.block<1, 3>(2*k, 0) * ni * vk[k];
+          _jacobianOplusXj.block<1, 2>(2*k+1, 0) = -rj;
+          _jacobianOplusXi.block<1, 2>(2*k+1, 0) = dR * rj;
+          z = dR.transpose() * ri - Rj.transpose() * dt;
+          _jacobianOplusXj(2*k+1, 2) = rj.x() * z.y() - rj.y() * z.x();
+          z = dR.transpose() * ri;
+          _jacobianOplusXi(2*k+1, 2) = -rj.x() * z.y() + rj.y() * z.x();
+          _jacobianOplusXj.block<1, 3>(2*k+1, 0) = _jacobianOplusXj.block<1, 3>(2*k+1, 0) * nj * vk[k];
+          _jacobianOplusXi.block<1, 3>(2*k+1, 0) = _jacobianOplusXi.block<1, 3>(2*k+1, 0) * nj * vk[k];
+          _jacobianOplusXk.block<2, 1>(2 * k, k) << li, lj;
+          //_jacobianOplusXk.block<2, 1>(2 * k, k) << li * dvk[k], lj * dvk[k];
+      }
+      for (int k = 0; k < prox_maxN; k++)
+          _jacobianOplusXk(2 * prox_maxN + k, k) = cst(-1.);
+          //_jacobianOplusXk(2 * prox_maxN + k, k) = -sign(vk[k]) / (2. * sqrt(fabs(vk[k])));
+          //_jacobianOplusXk(2 * prox_maxN + k, k) = -dvk[k];
+
+      /*
+      cout << this->id() << " : " << _vertices[0]->id() << endl;
+      for (int i = 0; i < 20; i++) {
+          if (_jacobianOplusXi.col(0)[i] == 0.) break;
+          cout << _jacobianOplusXi.col(0)[i] << ", ";
+      }
+      cout << endl;
+      for (int i = 0; i < 20; i++) {
+          if (_jacobianOplusXi.col(1)[i] == 0.) break;
+          cout << _jacobianOplusXi.col(1)[i] << ", ";
+      }
+      cout << endl;
+      for (int i = 0; i < 20; i++) {
+          if (_jacobianOplusXi.col(2)[i] == 0.) break;
+          cout << _jacobianOplusXi.col(2)[i] << ", ";
+      }
+      cout << endl << endl;
+      cout << this->id() << " : " << _vertices[1]->id() << endl;
+      for (int i = 0; i < 20; i++) {
+          if (_jacobianOplusXj.col(0)[i] == 0.) break;
+          cout << _jacobianOplusXj.col(0)[i] << ", ";
+      }
+      cout << endl;
+      for (int i = 0; i < 20; i++) {
+          if (_jacobianOplusXj.col(1)[i] == 0.) break;
+          cout << _jacobianOplusXj.col(1)[i] << ", ";
+      }
+      cout << endl;
+      for (int i = 0; i < 20; i++) {
+          if (_jacobianOplusXj.col(2)[i] == 0.) break;
+          cout << _jacobianOplusXj.col(2)[i] << ", ";
+      }
+      cout << endl << endl;
+      */
+  }
+#endif
+
+  bool EdgeSwitchProx::setMeasurementFromState(){
+      /*
+      VertexSE2Proximity* from_node = static_cast<VertexSE2Proximity*>(_vertices[0]);
+      VertexSE2Proximity* to_node = static_cast<VertexSE2Proximity*>(_vertices[1]);
+      
+      _measurement = from_node->estimate().inverse() * to_node->estimate();
+      */
+    return true;
+  }
+
+
+  void EdgeSwitchProx::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* /*to_*/)
+  {
+    /*
+    VertexSE2Proximity* from_node = dynamic_cast<VertexSE2Proximity*>(_vertices[0]);
+    VertexSE2Proximity* to_node = dynamic_cast<VertexSE2Proximity*>(_vertices[1]);
+    if (from.count(from_node) > 0)
+        to_node->setEstimate(from_node->estimate() * _measurement);
+    else
+        from_node->setEstimate(to_node->estimate() * _measurement.inverse());
+    */
+  }
+
+  inline Vector2 EdgeSwitchProx::from_prox(int i) const {
+      if (0 <= i && i < _num_prox_pairs)
+          return dynamic_cast<VertexProx*>(_vertices[0])->proximity(_prox_pairs[0][i]);
+      cerr << "out of range" << endl;
+      return Vector2();
+  };
+  inline Vector2 EdgeSwitchProx::to_prox(int i) const {
+      if (0 <= i && i < _num_prox_pairs)
+          return dynamic_cast<VertexProx*>(_vertices[1])->proximity(_prox_pairs[1][i]);
+      cerr << "out of range" << endl;
+      return Vector2();
+  };
+  inline Vector2 EdgeSwitchProx::from_gr_prox(int i) const {
+      if (0 <= i && i < _num_prox_pairs) {
+          Vector2 fp = from_prox(i);
+          if (fp == Vector2()) return Vector2();
+          return (dynamic_cast<VertexProx*>(_vertices[0])->estimate() * fp);
+      }
+      cerr << "out of range" << endl;
+      return Vector2();
+  };
+  inline Vector2 EdgeSwitchProx::to_gr_prox(int i) const {
+      if (0 <= i && i < _num_prox_pairs) {
+          Vector2 tp = to_prox(i);
+          if (tp == Vector2()) return Vector2();
+          return (dynamic_cast<VertexProx*>(_vertices[1])->estimate() * tp);
+      }
+      cerr << "out of range" << endl;
+      return Vector2();
+  };
+
+#ifdef G2O_HAVE_OPENGL
+  EdgeSwitchProxDrawAction::EdgeSwitchProxDrawAction()
+      : DrawAction(typeid(EdgeSwitchProx).name()), _triangleX(nullptr), _triangleY(nullptr), _triangleZ(nullptr) {}
+
+  bool EdgeSwitchProxDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_) {
+      if (!DrawAction::refreshPropertyPtrs(params_))
+          return false;
+      if (_previousParams) {
+          _triangleX = _previousParams->makeProperty<FloatProperty>(_typeName + "::N_Edge_Arrow_Length", .0f);
+          _triangleY = _previousParams->makeProperty<FloatProperty>(_typeName + "::N_Edge_Width", 3.0f);
+          _triangleZ = _previousParams->makeProperty<FloatProperty>(_typeName + "::P_Edge_Width", 2.0f);
+      }
+      else {
+          _triangleX = 0;
+          _triangleY = 0;
+          _triangleZ = 0;
+      }
+      return true;
+  }
+
+  HyperGraphElementAction* EdgeSwitchProxDrawAction::operator()(HyperGraph::HyperGraphElement* element,
+      HyperGraphElementAction::Parameters* params_) {
+      if (typeid(*element).name() != _typeName)
+          return nullptr;
+
+      refreshPropertyPtrs(params_);
+      if (!_previousParams)
+          return this;
+
+      if (_show && !_show->value())
+          return this;
+
+      EdgeSwitchProx* e = static_cast<EdgeSwitchProx*>(element);
+      VertexProx* from = static_cast<VertexProx*>(e->vertex(0));
+      VertexProx* to = static_cast<VertexProx*>(e->vertex(1));
+      if (!from && !to)
+          return this;
+      SE2 fromTransform;
+      SE2 toTransform;
+      glPushAttrib(GL_ENABLE_BIT | GL_LIGHTING | GL_COLOR);
+      glDisable(GL_LIGHTING);
+      /*
+      if (!from) {
+          glColor3f(POSE_EDGE_GHOST_COLOR);
+          toTransform = to->estimate();
+          fromTransform = to->estimate() * e->measurement().inverse();
+          // DRAW THE FROM EDGE AS AN ARROW
+          glPushMatrix();
+          glTranslatef((float)fromTransform.translation().x(), (float)fromTransform.translation().y(), 0.f);
+          glRotatef((float)RAD2DEG(fromTransform.rotation().angle()), 0.f, 0.f, 1.f);
+          opengl::drawArrow2D((float)_triangleX->value(), (float)_triangleY->value(), (float)_triangleX->value() * .3f);
+          glPopMatrix();
+      }
+      else if (!to) {
+          glColor3f(POSE_EDGE_GHOST_COLOR);
+          fromTransform = from->estimate();
+          toTransform = from->estimate() * e->measurement();
+          // DRAW THE TO EDGE AS AN ARROW
+          glPushMatrix();
+          glTranslatef(toTransform.translation().x(), toTransform.translation().y(), 0.f);
+          glRotatef((float)RAD2DEG(toTransform.rotation().angle()), 0.f, 0.f, 1.f);
+          opengl::drawArrow2D((float)_triangleX->value(), (float)_triangleY->value(), (float)_triangleX->value() * .3f);
+          glPopMatrix();
+      }
+      */
+      { //else {
+          glColor3f(POSE_EDGE_COLOR);
+          fromTransform = from->estimate();
+          toTransform = to->estimate();
+      }
+      //glGetFloatv(GL_LINE_WIDTH, &(float)_triangleY->value());
+      if (_triangleY->value() != 0) {
+          glLineWidth((float)_triangleY->value());
+          glBegin(GL_LINES);
+          glVertex3f((float)fromTransform.translation().x(), (float)fromTransform.translation().y(), 0.f);
+          glVertex3f((float)toTransform.translation().x(), (float)toTransform.translation().y(), 0.f);
+          glEnd();
+      }
+      //glGetFloatv(GL_LINE_WIDTH, &(float)_triangleZ->value());
+      if (_triangleZ->value() != 0) {
+          glLineWidth((float)_triangleZ->value());
+          glColor3f(LANDMARK_EDGE_COLOR);
+          glBegin(GL_LINES);
+          for (int i = 0; i < e->num_prox_pairs(); i++) {
+              glVertex3f((float)e->from_gr_prox(i).x(), (float)e->from_gr_prox(i).y(), 0.f);
+              glVertex3f((float)e->to_gr_prox(i).x(), (float)e->to_gr_prox(i).y(), 0.f);
+          }
+      }
+      glEnd();
+      glPopAttrib();
+      return this;
+  }
+#endif
+}
diff --git a/g2o/types/slam2d/edge_switch_prox.h b/g2o/types/slam2d/edge_switch_prox.h
new file mode 100644
index 00000000..d09a7956
--- /dev/null
+++ b/g2o/types/slam2d/edge_switch_prox.h
@@ -0,0 +1,98 @@
+// This class was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#ifndef G2O_EDGE_SWITCHING_PROX_H_
+#define G2O_EDGE_SWITCHING_PROX_H_
+
+//#define NUMERIC_JACOBIAN_TWO_D_TYPES
+
+#include "g2o/core/base_ternary_edge.h"
+#include "vertex_prox.h"
+#include "vertex_switch_pp.h"
+#include "parameter_switch_weight.h"
+
+//#include "vertex_se2.h"
+#include "g2o_types_slam2d_api.h"
+
+#ifndef prox_maxN
+#define prox_maxN 10
+#endif
+
+namespace g2o {
+    class G2O_TYPES_SLAM2D_API EdgeSwitchProx : public BaseTernaryEdge < 3 * prox_maxN, std::array<int, 2 * prox_maxN>, VertexProx, VertexProx, VertexSwitchProxPair > {
+  public:
+      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+          EdgeSwitchProx();
+      virtual bool read(std::istream& is);
+      virtual bool write(std::ostream& os) const;
+
+      void computeError();
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+      virtual void linearizeOplus();
+#endif
+
+      virtual void setMeasurement(const std::array<int, 2 * prox_maxN> m) {
+          for (int i = 0; i < 2 * prox_maxN; i++)
+              _measurement[i] = m[i];
+      }
+
+      virtual void setMeasurement(const int m[2 * prox_maxN]) {
+          for (int i = 0; i < 2 * prox_maxN; i++)
+              _measurement[i] = m[i];
+      }
+
+      virtual bool setMeasurementData(const int* d) {
+          for(int i = 0; i < 2 * prox_maxN; i++)
+              _measurement[i] = d[i];
+          return true;
+      }
+
+      virtual bool setMeasurementData(const int d) {
+          for (int i = 0; i < 2 * prox_maxN; i++)
+              _measurement[i] = d;
+          return true;
+      }
+
+      virtual bool getMeasurementData(int d[2 * prox_maxN]) const {
+          for (int i = 0; i < 2 * prox_maxN; i++)
+              d[i] = _measurement[i];
+          return true;
+      }
+
+      virtual int measurementDimension() const { return 3; }
+
+      virtual bool setMeasurementFromState();
+
+      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to) {
+          (void)to;
+          return (from.count(_vertices[0]) == 1 ? 1.0 : -1.0);
+      }
+
+      virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
+
+      virtual inline Vector2 from_prox(int i) const;
+      virtual inline Vector2 to_prox(int i) const;
+      virtual inline Vector2 from_gr_prox(int i) const;
+      virtual inline Vector2 to_gr_prox(int i) const;
+      virtual inline int num_prox_pairs() const { return _num_prox_pairs; };
+
+  private:
+      int _prox_pairs[2][prox_maxN];
+      int _num_prox_pairs;
+      ParameterSwitchWeight* _ProxPairWeightInfo;
+      number_t info;
+  };
+
+#ifdef G2O_HAVE_OPENGL
+  class G2O_TYPES_SLAM2D_API EdgeSwitchProxDrawAction : public DrawAction {
+  public:
+      EdgeSwitchProxDrawAction();
+      virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
+          HyperGraphElementAction::Parameters* params_);
+  protected:
+      virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
+      FloatProperty* _triangleX, * _triangleY, * _triangleZ;
+  };
+#endif
+
+}
+#endif
diff --git a/g2o/types/slam2d/edge_switch_se2.cpp b/g2o/types/slam2d/edge_switch_se2.cpp
new file mode 100644
index 00000000..d5bd3188
--- /dev/null
+++ b/g2o/types/slam2d/edge_switch_se2.cpp
@@ -0,0 +1,222 @@
+// g2o - General Graph Optimization
+// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright
+//   notice, this list of conditions and the following disclaimer in the
+//   documentation and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "edge_switch_se2.h"
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+
+  EdgeSwitchSE2::EdgeSwitchSE2() :
+      BaseTernaryEdge<4, SE2, VertexSE2, VertexSE2, VertexSwitch>(), info(1.)
+  {
+      _WeightInfo = 0;
+      resizeParameters(1);
+      installParameter(_WeightInfo, 0);
+  }
+
+  bool EdgeSwitchSE2::read(std::istream& is)
+  {
+    Vector3 p;
+    internal::readVector(is, p);
+    setMeasurement(SE2(p));
+    _inverseMeasurement = measurement().inverse();
+    information().setZero();
+    for (int i = 0; i < 3 && is.good(); ++i)
+        for (int j = i; j < 3 && is.good(); ++j) {
+            is >> information()(i, j);
+            if (i != j) information()(j, i) = information()(i, j);
+        }
+    if (!setParameterId(0, 0))
+        return false;
+    resolveParameters();
+    info = _WeightInfo->Info();
+    information()(3, 3) = info;
+    return true;
+  }
+
+  bool EdgeSwitchSE2::write(std::ostream& os) const
+  {
+    internal::writeVector(os, measurement().toVector());
+    return writeInformationMatrix(os);
+  }
+
+  void EdgeSwitchSE2::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* /* to */)
+  {
+    VertexSE2* fromEdge = static_cast<VertexSE2*>(_vertices[0]);
+    VertexSE2* toEdge   = static_cast<VertexSE2*>(_vertices[1]);
+    if (from.count(fromEdge) > 0)
+      toEdge->setEstimate(fromEdge->estimate() * _measurement);
+    else
+      fromEdge->setEstimate(toEdge->estimate() * _inverseMeasurement);
+  }
+
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+  void EdgeSwitchSE2::linearizeOplus()
+  {
+    //const VertexSE2* vi = static_cast<const VertexSE2*>(_vertices[0]);
+    //const VertexSE2* vj = static_cast<const VertexSE2*>(_vertices[1]);
+    //number_t thetai = vi->estimate().rotation().angle();
+
+    //Vector2 dt = vj->estimate().translation() - vi->estimate().translation();
+    //number_t si=std::sin(thetai), ci=std::cos(thetai);
+
+    //_jacobianOplusXi <<
+    //    -ci, -si, -si*dt.x()+ci*dt.y(),
+    //     si, -ci, -ci*dt.x()-si*dt.y(),
+    //     0,  0,   -1;
+
+    //_jacobianOplusXj <<
+    //     ci, si, 0,
+    //    -si, ci, 0,
+    //     0,  0,  1;
+
+    //const SE2& rmean = _inverseMeasurement;
+    //Matrix3 z;
+    //z.block<2, 2>(0, 0) = rmean.rotation().toRotationMatrix();
+    //z.col(2) << cst(0.), cst(0.), cst(1.);
+    //z.row(2).head<2>() << cst(0.), cst(0.);
+    //_jacobianOplusXi = z * _jacobianOplusXi;
+    //_jacobianOplusXj = z * _jacobianOplusXj;
+      const VertexSE2* vi = static_cast<const VertexSE2*>(_vertices[0]);
+      const VertexSE2* vj = static_cast<const VertexSE2*>(_vertices[1]);
+      const VertexSwitch* s = static_cast<const VertexSwitch*>(_vertices[2]);
+      SE2 delta = _inverseMeasurement * (vi->estimate().inverse() * vj->estimate());
+      delta.setRotation(Rotation2D(normalize_theta(delta.rotation().angle())));
+
+      Vector2 dt = vj->estimate().translation() - vi->estimate().translation();
+      Matrix2 dR = vi->estimate().rotation().toRotationMatrix().transpose() * vj->estimate().rotation().toRotationMatrix();
+      const SE2& rmean = _inverseMeasurement;
+      Vector2 z = rmean.rotation().toRotationMatrix() * vi->estimate().rotation().toRotationMatrix().transpose() * dt;
+
+      _jacobianOplusXi.setZero();
+      _jacobianOplusXi.block<2, 2>(0, 0) = - s->estimate() * rmean.rotation().toRotationMatrix();
+      _jacobianOplusXi.col(2) = s->estimate() * Vector4{ z.y(), -z.x(), -1., 0. };
+      _jacobianOplusXj.setZero();
+      _jacobianOplusXj.block<2, 2>(0, 0) = s->estimate() * rmean.rotation().toRotationMatrix() * dR;
+      _jacobianOplusXj(2,2) = s->estimate();
+      _jacobianOplusXk << delta.toVector(), -cst(1.);
+  }
+#endif
+
+  EdgeSwitchSE2WriteGnuplotAction::EdgeSwitchSE2WriteGnuplotAction(): WriteGnuplotAction(typeid(EdgeSwitchSE2).name()){}
+
+  HyperGraphElementAction* EdgeSwitchSE2WriteGnuplotAction::operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* params_){
+    if (typeid(*element).name()!=_typeName)
+      return nullptr;
+    WriteGnuplotAction::Parameters* params=static_cast<WriteGnuplotAction::Parameters*>(params_);
+    if (!params->os){
+      std::cerr << __PRETTY_FUNCTION__ << ": warning, on valid os specified" << std::endl;
+      return nullptr;
+    }
+
+    EdgeSwitchSE2* e =  static_cast<EdgeSwitchSE2*>(element);
+    VertexSE2* fromEdge = static_cast<VertexSE2*>(e->vertex(0));
+    VertexSE2* toEdge   = static_cast<VertexSE2*>(e->vertex(1));
+    *(params->os) << fromEdge->estimate().translation().x() << " " << fromEdge->estimate().translation().y()
+      << " " << fromEdge->estimate().rotation().angle() << std::endl;
+    *(params->os) << toEdge->estimate().translation().x() << " " << toEdge->estimate().translation().y()
+      << " " << toEdge->estimate().rotation().angle() << std::endl;
+    *(params->os) << std::endl;
+    return this;
+  }
+
+#ifdef G2O_HAVE_OPENGL
+  EdgeSwitchSE2DrawAction::EdgeSwitchSE2DrawAction()
+      : DrawAction(typeid(EdgeSwitchSE2).name()), _triangleX(nullptr), _triangleY(nullptr) {}
+
+  bool EdgeSwitchSE2DrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_){
+    if (!DrawAction::refreshPropertyPtrs(params_))
+      return false;
+    if (_previousParams){
+      _triangleX = _previousParams->makeProperty<FloatProperty>(_typeName + "::GHOST_TRIANGLE_X", .2f);
+      _triangleY = _previousParams->makeProperty<FloatProperty>(_typeName + "::GHOST_TRIANGLE_Y", .05f);
+    } else {
+      _triangleX = 0;
+      _triangleY = 0;
+    }
+    return true;
+  }
+
+  HyperGraphElementAction* EdgeSwitchSE2DrawAction::operator()(HyperGraph::HyperGraphElement* element,
+               HyperGraphElementAction::Parameters* params_){
+    if (typeid(*element).name()!=_typeName)
+      return nullptr;
+
+    refreshPropertyPtrs(params_);
+    if (! _previousParams)
+      return this;
+
+    if (_show && !_show->value())
+      return this;
+
+    EdgeSwitchSE2* e =  static_cast<EdgeSwitchSE2*>(element);
+    VertexSE2* from = static_cast<VertexSE2*>(e->vertex(0));
+    VertexSE2* to   = static_cast<VertexSE2*>(e->vertex(1));
+    if (! from && ! to)
+      return this;
+    SE2 fromTransform;
+    SE2 toTransform;
+    glPushAttrib(GL_ENABLE_BIT | GL_LIGHTING | GL_COLOR);
+    glDisable(GL_LIGHTING);
+    if (! from) {
+      glColor3f(POSE_EDGE_GHOST_COLOR);
+      toTransform = to->estimate();
+      fromTransform = to->estimate()*e->measurement().inverse();
+      // DRAW THE FROM EDGE AS AN ARROW
+      glPushMatrix();
+      glTranslatef((float)fromTransform.translation().x(), (float)fromTransform.translation().y(),0.f);
+      glRotatef((float)RAD2DEG(fromTransform.rotation().angle()),0.f,0.f,1.f);
+      opengl::drawArrow2D((float)_triangleX->value(), (float)_triangleY->value(), (float)_triangleX->value()*.3f);
+      glPopMatrix();
+    } else if (! to){
+      glColor3f(POSE_EDGE_GHOST_COLOR);
+      fromTransform = from->estimate();
+      toTransform = from->estimate()*e->measurement();
+      // DRAW THE TO EDGE AS AN ARROW
+      glPushMatrix();
+      glTranslatef(toTransform.translation().x(),toTransform.translation().y(),0.f);
+      glRotatef((float)RAD2DEG(toTransform.rotation().angle()),0.f,0.f,1.f);
+      opengl::drawArrow2D((float)_triangleX->value(), (float)_triangleY->value(), (float)_triangleX->value()*.3f);
+      glPopMatrix();
+    } else {
+      glColor3f(POSE_EDGE_COLOR);
+      fromTransform = from->estimate();
+      toTransform = to->estimate();
+    }
+    glBegin(GL_LINES);
+    glVertex3f((float)fromTransform.translation().x(),(float)fromTransform.translation().y(),0.f);
+    glVertex3f((float)toTransform.translation().x(),(float)toTransform.translation().y(),0.f);
+    glEnd();
+    glPopAttrib();
+    return this;
+  }
+#endif
+
+} // end namespace
diff --git a/g2o/types/slam2d/edge_switch_se2.h b/g2o/types/slam2d/edge_switch_se2.h
new file mode 100644
index 00000000..8afd5167
--- /dev/null
+++ b/g2o/types/slam2d/edge_switch_se2.h
@@ -0,0 +1,127 @@
+// g2o - General Graph Optimization
+// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright
+//   notice, this list of conditions and the following disclaimer in the
+//   documentation and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef G2O_EDGE_SWITCHING_SE2_H
+#define G2O_EDGE_SWITCHING_SE2_H
+
+//#define NUMERIC_JACOBIAN_TWO_D_TYPES
+
+#include "vertex_se2.h"
+#include "vertex_switch.h"
+#include "parameter_switch_weight.h"
+#include "g2o/config.h"
+#include "g2o/core/base_ternary_edge.h"
+#include "g2o_types_slam2d_api.h"
+
+namespace g2o {
+
+  /**
+   * \brief 2D edge between two Vertex2
+   */
+  class G2O_TYPES_SLAM2D_API EdgeSwitchSE2 : public BaseTernaryEdge<4, SE2, VertexSE2, VertexSE2, VertexSwitch>
+  {
+    public:
+      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+          EdgeSwitchSE2();
+
+      void computeError()
+      {
+        const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
+        const VertexSE2* v2 = static_cast<const VertexSE2*>(_vertices[1]);
+        const VertexSwitch* s = static_cast<const VertexSwitch*>(_vertices[2]);
+        SE2 delta = _inverseMeasurement * (v1->estimate().inverse()*v2->estimate());
+        delta.setRotation(Rotation2D(normalize_theta(delta.rotation().angle())));
+        _error.block<3,1>(0,0) = s->estimate() * delta.toVector();
+        _error(3, 0) = cst(1.) - s->estimate();
+      }
+      virtual bool read(std::istream& is);
+      virtual bool write(std::ostream& os) const;
+
+      virtual void setMeasurement(const SE2& m){
+        _measurement = m;
+        _inverseMeasurement = m.inverse();
+      }
+
+      virtual bool setMeasurementData(const number_t* d){
+        _measurement=SE2(d[0], d[1], d[2]);
+        _inverseMeasurement = _measurement.inverse();
+        return true;
+      }
+
+      virtual bool getMeasurementData(number_t* d) const {
+        Vector3 v=_measurement.toVector();
+        d[0] = v[0];
+        d[1] = v[1];
+        d[2] = v[2];
+        return true;
+      }
+
+      virtual int measurementDimension() const {return 3;}
+
+      virtual bool setMeasurementFromState() {
+        const VertexSE2* v1 = static_cast<const VertexSE2*>(_vertices[0]);
+        const VertexSE2* v2 = static_cast<const VertexSE2*>(_vertices[1]);
+        _measurement = v1->estimate().inverse()*v2->estimate();
+        _inverseMeasurement = _measurement.inverse();
+        return true;
+      }
+
+
+      virtual number_t initialEstimatePossible(const OptimizableGraph::VertexSet& , OptimizableGraph::Vertex* ) { return 1.;}
+      virtual void initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to);
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+      virtual void linearizeOplus();
+#endif
+    protected:
+      SE2 _inverseMeasurement;
+
+  private:
+      ParameterSwitchWeight* _WeightInfo;
+      number_t info;
+  };
+
+  class G2O_TYPES_SLAM2D_API EdgeSwitchSE2WriteGnuplotAction: public WriteGnuplotAction {
+  public:
+    EdgeSwitchSE2WriteGnuplotAction();
+    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
+            HyperGraphElementAction::Parameters* params_);
+  };
+
+#ifdef G2O_HAVE_OPENGL
+  class G2O_TYPES_SLAM2D_API EdgeSwitchSE2DrawAction: public DrawAction{
+  public:
+    EdgeSwitchSE2DrawAction();
+    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element,
+            HyperGraphElementAction::Parameters* params_);
+  protected:
+    virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
+    FloatProperty *_triangleX, *_triangleY;
+  };
+#endif
+
+} // end namespace
+
+#endif
diff --git a/g2o/types/slam2d/parameter_em.cpp b/g2o/types/slam2d/parameter_em.cpp
new file mode 100644
index 00000000..55d95599
--- /dev/null
+++ b/g2o/types/slam2d/parameter_em.cpp
@@ -0,0 +1,63 @@
+#include "parameter_em.h"
+
+#include "g2o/core/io_helper.h"
+#include "vertex_se2.h"
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#endif
+
+namespace g2o {
+
+ParameterEM::ParameterEM() { setSwitch(); }
+
+void ParameterEM::setSwitch(const number_t& switch_) {
+    _switch = switch_;
+}
+
+bool ParameterEM::read(std::istream& is) {
+
+    number_t switch_;
+    is >> switch_;
+    if (is.bad()) return false;
+    setSwitch(switch_);
+    return true;
+}
+
+bool ParameterEM::write(std::ostream& os) const {
+    os << Switch();
+    return true;
+}
+
+CacheEM::CacheEM() : Cache(), _switchVariable(1.) {}
+
+bool CacheEM::resolveDependencies() {
+    return Cache::resolveDependancies();
+}
+
+void CacheEM::updateImpl() {
+    const VertexSE2* v = static_cast<const VertexSE2*>(vertex());
+    _se2_n2w = v->estimate() * _offsetParam->offset();
+
+    _n2w = _se2_n2w.rotation().toRotationMatrix();
+    _n2w.translation() = _se2_n2w.translation();
+
+    _se2_w2n = _se2_n2w.inverse();
+    _w2n = _se2_w2n.rotation().toRotationMatrix();
+    _w2n.translation() = _se2_w2n.translation();
+
+    SE2 w2l = v->estimate().inverse();
+    _w2l = w2l.rotation().toRotationMatrix();
+    _w2l.translation() = w2l.translation();
+
+    number_t alpha = v->estimate().rotation().angle();
+    number_t c = std::cos(alpha), s = std::sin(alpha);
+    Matrix2 RInversePrime;
+    RInversePrime << -s, c, -c, -s;
+    _RpInverse_RInversePrime =
+        _offsetParam->offset().rotation().toRotationMatrix().transpose() *
+        RInversePrime;
+    _RpInverse_RInverse = w2l.rotation();
+}
+
+}  // namespace g2o
\ No newline at end of file
diff --git a/g2o/types/slam2d/parameter_em.h b/g2o/types/slam2d/parameter_em.h
new file mode 100644
index 00000000..1294062d
--- /dev/null
+++ b/g2o/types/slam2d/parameter_em.h
@@ -0,0 +1,58 @@
+// This class was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#ifndef G2O_PARAMETERS_EM_H_
+#define G2O_PARAMETERS_EM_H_
+
+#include "g2o/core/cache.h"
+#include "g2o_types_slam2d_api.h"
+#include "se2.h"
+
+namespace g2o {
+
+class VertexSE2;
+
+/**
+    * \brief offset for an SE2
+    */
+class G2O_TYPES_SLAM2D_API ParameterEM : public Parameter {
+public:
+    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
+    ParameterEM();
+
+    virtual bool read(std::istream& is);
+    virtual bool write(std::ostream& os) const;
+
+    /**
+        * update the offset to a new value.
+        * re-calculates the different representations, e.g., the rotation matrix
+        */
+    void setSwitch(const number_t& switch_ = 0.);
+
+    const number_t& Switch() const { return _switch; }
+
+protected:
+    number_t _switch;
+};
+
+/**
+    * \brief caching the offset related to a vertex
+    */
+class G2O_TYPES_SLAM2D_API CacheEM : public Cache {
+public:
+    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
+    CacheEM();
+    virtual void updateImpl();
+
+    void setSwitch(const number_t& switch_ = 0.) { _switchVariable = switch_; }
+    const number_t& Switch() const { return _switchVariable; }
+
+protected:
+    number_t _switchVariable;  ///< the parameter connected to the cache
+
+protected:
+    virtual bool resolveDependencies();
+};
+
+}  // namespace g2o
+
+#endif
\ No newline at end of file
diff --git a/g2o/types/slam2d/parameter_em_prox.cpp b/g2o/types/slam2d/parameter_em_prox.cpp
new file mode 100644
index 00000000..77791749
--- /dev/null
+++ b/g2o/types/slam2d/parameter_em_prox.cpp
@@ -0,0 +1,311 @@
+// This class was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#include "edge_switch_prox.h"
+#include <iostream>
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+  using namespace std;
+
+
+  // point to camera projection, monocular
+  EdgeSwitchProx::EdgeSwitchProx()
+      : BaseTernaryEdge < 3 * prox_maxN, std::array<int, 2 * prox_maxN>, VertexProx, VertexProx, VertexSwitchProxPair >(), _num_prox_pairs(0), _prox_pairs(), info(1.) {
+      memset(_prox_pairs[0], 0, prox_maxN);
+      memset(_prox_pairs[1], 0, prox_maxN);
+    information().setZero();
+    _ProxPairWeightInfo = 0;
+    resizeParameters(1);
+    installParameter(_ProxPairWeightInfo, 0);
+  }
+
+  bool EdgeSwitchProx::read(std::istream& is) {
+    // measured keypoint
+    setMeasurementData(0);
+    if (is.bad()) return false;
+    //readInformationMatrix(is);
+    //  we overwrite the information matrix in case of read errors
+    //if (is.bad()) information().setIdentity();
+    information().setZero();
+    _num_prox_pairs = 0;
+    if (!setParameterId(0, 0))
+        return false;
+    resolveParameters();
+    info = _ProxPairWeightInfo->Info();
+    for(int i = 0; i < prox_maxN; i++)
+        information()(2 * prox_maxN + i, 2 * prox_maxN + i) = info;
+
+    int n;
+    is >> n;
+    for (int i = 0; i < n && i < prox_maxN; i++) {
+        is >> _prox_pairs[0][i] >> _prox_pairs[1][i];
+        double info;
+        is >> info;
+        information()(2*i, 2*i) = info;
+        information()(2*i+1, 2*i+1) = info;
+        if (is.bad()) return false;
+        _num_prox_pairs = i + 1;
+    }
+    return true;
+  }
+
+  bool EdgeSwitchProx::write(std::ostream& os) const {
+      int n = _num_prox_pairs;
+      os << _num_prox_pairs << " ";
+      for (int i = 0; i < _num_prox_pairs && i < prox_maxN; i++)
+          os << _prox_pairs[0][i] << " " << _prox_pairs[1][i] << " " << information()(2*i, 2*i) << " ";
+      return true;
+  }
+
+  void EdgeSwitchProx::computeError() {
+      const SE2 vi = dynamic_cast<VertexProx*>(_vertices[0])->estimate();
+      const SE2 vj = dynamic_cast<VertexProx*>(_vertices[1])->estimate();
+      //const std::array<number_t, prox_maxN> vk = sigmoid_est();
+      const std::array<number_t, prox_maxN> vk = dynamic_cast<VertexSwitchProxPair*>(_vertices[2])->estimate();
+      for (int k = 0; k < _num_prox_pairs && k < prox_maxN; k++) {
+          const Vector2 ri = from_prox(k),  rj = to_prox(k), qi = from_gr_prox(k), qj = to_gr_prox(k);
+          if (ri == Vector2() || rj == Vector2() || qi == Vector2() || qj == Vector2()) continue;
+          const Vector2 ei = vi.rotation() * ri, ej = vj.rotation() * rj;
+          const number_t li = cst((ei / ri.norm()).dot(qj - qi)), lj = cst((ej / rj.norm()).dot(qi - qj));
+          _error.block<2, 1>(2 * k, 0) << li * vk[k], lj * vk[k];
+      }
+      for (int k = 0; k < prox_maxN; k++)
+          _error(2 * prox_maxN + k) = cst(1.) - vk[k];
+          //_error(2 * prox_maxN + k) = cst(1.) - sqrt(fabs(vk[k]));
+  }
+
+#ifndef NUMERIC_JACOBIAN_TWO_D_TYPES
+  void EdgeSwitchProx::linearizeOplus() {
+      _jacobianOplusXi.setZero();
+      _jacobianOplusXj.setZero();
+      _jacobianOplusXk.setZero();
+      const SE2 vi = dynamic_cast<VertexProx*>(_vertices[0])->estimate();
+      const SE2 vj = dynamic_cast<VertexProx*>(_vertices[1])->estimate();
+      //const std::array<number_t, prox_maxN> vk = sigmoid_est();
+      //const std::array<number_t, prox_maxN> dvk = def_sig_est();
+      const std::array<number_t, prox_maxN> vk = dynamic_cast<VertexSwitchProxPair*>(_vertices[2])->estimate();
+      const Vector2 dt = vj.translation() - vi.translation();
+      const Matrix2 Ri = vi.rotation().toRotationMatrix(),
+          Rj = vj.rotation().toRotationMatrix(),
+          dR = Ri.transpose() * Rj;
+      for (int k = 0; k < _num_prox_pairs && k < prox_maxN; k++) {
+          const Vector2 ri = from_prox(k), rj = to_prox(k), qi = from_gr_prox(k), qj = to_gr_prox(k);
+          if (ri == Vector2() || rj == Vector2() || qi == Vector2() || qj == Vector2()) continue;
+          const number_t ni = 1. / ri.norm(), nj = 1. / rj.norm();
+          const Vector2 ei = vi.rotation() * ri, ej = vj.rotation() * rj;
+          const number_t li = cst((ei * ni).dot(qj - qi)), lj = cst((ej * nj).dot(qi - qj));
+          Vector2 z;
+
+          _jacobianOplusXi.block<1, 2>(2*k, 0) = -ri;
+          _jacobianOplusXj.block<1, 2>(2*k, 0) = dR.transpose() * ri;
+          z = dR * rj + Ri.transpose() * dt;
+          _jacobianOplusXi(2*k, 2) = ri.x() * z.y() - ri.y() * z.x();
+          z = dR * rj;
+          _jacobianOplusXj(2*k, 2) = -ri.x() * z.y() + ri.y() * z.x();
+          _jacobianOplusXi.block<1, 3>(2*k, 0) = _jacobianOplusXi.block<1, 3>(2*k, 0) * ni * vk[k];
+          _jacobianOplusXj.block<1, 3>(2*k, 0) = _jacobianOplusXj.block<1, 3>(2*k, 0) * ni * vk[k];
+          _jacobianOplusXj.block<1, 2>(2*k+1, 0) = -rj;
+          _jacobianOplusXi.block<1, 2>(2*k+1, 0) = dR * rj;
+          z = dR.transpose() * ri - Rj.transpose() * dt;
+          _jacobianOplusXj(2*k+1, 2) = rj.x() * z.y() - rj.y() * z.x();
+          z = dR.transpose() * ri;
+          _jacobianOplusXi(2*k+1, 2) = -rj.x() * z.y() + rj.y() * z.x();
+          _jacobianOplusXj.block<1, 3>(2*k+1, 0) = _jacobianOplusXj.block<1, 3>(2*k+1, 0) * nj * vk[k];
+          _jacobianOplusXi.block<1, 3>(2*k+1, 0) = _jacobianOplusXi.block<1, 3>(2*k+1, 0) * nj * vk[k];
+          _jacobianOplusXk.block<2, 1>(2 * k, k) << li, lj;
+          //_jacobianOplusXk.block<2, 1>(2 * k, k) << li * dvk[k], lj * dvk[k];
+      }
+      for (int k = 0; k < prox_maxN; k++)
+          _jacobianOplusXk(2 * prox_maxN + k, k) = cst(-1.);
+          //_jacobianOplusXk(2 * prox_maxN + k, k) = -sign(vk[k]) / (2. * sqrt(fabs(vk[k])));
+          //_jacobianOplusXk(2 * prox_maxN + k, k) = -dvk[k];
+
+      /*
+      cout << this->id() << " : " << _vertices[0]->id() << endl;
+      for (int i = 0; i < 20; i++) {
+          if (_jacobianOplusXi.col(0)[i] == 0.) break;
+          cout << _jacobianOplusXi.col(0)[i] << ", ";
+      }
+      cout << endl;
+      for (int i = 0; i < 20; i++) {
+          if (_jacobianOplusXi.col(1)[i] == 0.) break;
+          cout << _jacobianOplusXi.col(1)[i] << ", ";
+      }
+      cout << endl;
+      for (int i = 0; i < 20; i++) {
+          if (_jacobianOplusXi.col(2)[i] == 0.) break;
+          cout << _jacobianOplusXi.col(2)[i] << ", ";
+      }
+      cout << endl << endl;
+      cout << this->id() << " : " << _vertices[1]->id() << endl;
+      for (int i = 0; i < 20; i++) {
+          if (_jacobianOplusXj.col(0)[i] == 0.) break;
+          cout << _jacobianOplusXj.col(0)[i] << ", ";
+      }
+      cout << endl;
+      for (int i = 0; i < 20; i++) {
+          if (_jacobianOplusXj.col(1)[i] == 0.) break;
+          cout << _jacobianOplusXj.col(1)[i] << ", ";
+      }
+      cout << endl;
+      for (int i = 0; i < 20; i++) {
+          if (_jacobianOplusXj.col(2)[i] == 0.) break;
+          cout << _jacobianOplusXj.col(2)[i] << ", ";
+      }
+      cout << endl << endl;
+      */
+  }
+#endif
+
+  bool EdgeSwitchProx::setMeasurementFromState(){
+      /*
+      VertexSE2Proximity* from_node = static_cast<VertexSE2Proximity*>(_vertices[0]);
+      VertexSE2Proximity* to_node = static_cast<VertexSE2Proximity*>(_vertices[1]);
+      
+      _measurement = from_node->estimate().inverse() * to_node->estimate();
+      */
+    return true;
+  }
+
+
+  void EdgeSwitchProx::initialEstimate(const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* /*to_*/)
+  {
+    /*
+    VertexSE2Proximity* from_node = dynamic_cast<VertexSE2Proximity*>(_vertices[0]);
+    VertexSE2Proximity* to_node = dynamic_cast<VertexSE2Proximity*>(_vertices[1]);
+    if (from.count(from_node) > 0)
+        to_node->setEstimate(from_node->estimate() * _measurement);
+    else
+        from_node->setEstimate(to_node->estimate() * _measurement.inverse());
+    */
+  }
+
+  inline Vector2 EdgeSwitchProx::from_prox(int i) const {
+      if (0 <= i && i < _num_prox_pairs)
+          return dynamic_cast<VertexProx*>(_vertices[0])->proximity(_prox_pairs[0][i]);
+      cerr << "out of range" << endl;
+      return Vector2();
+  };
+  inline Vector2 EdgeSwitchProx::to_prox(int i) const {
+      if (0 <= i && i < _num_prox_pairs)
+          return dynamic_cast<VertexProx*>(_vertices[1])->proximity(_prox_pairs[1][i]);
+      cerr << "out of range" << endl;
+      return Vector2();
+  };
+  inline Vector2 EdgeSwitchProx::from_gr_prox(int i) const {
+      if (0 <= i && i < _num_prox_pairs) {
+          Vector2 fp = from_prox(i);
+          if (fp == Vector2()) return Vector2();
+          return (dynamic_cast<VertexProx*>(_vertices[0])->estimate() * fp);
+      }
+      cerr << "out of range" << endl;
+      return Vector2();
+  };
+  inline Vector2 EdgeSwitchProx::to_gr_prox(int i) const {
+      if (0 <= i && i < _num_prox_pairs) {
+          Vector2 tp = to_prox(i);
+          if (tp == Vector2()) return Vector2();
+          return (dynamic_cast<VertexProx*>(_vertices[1])->estimate() * tp);
+      }
+      cerr << "out of range" << endl;
+      return Vector2();
+  };
+
+#ifdef G2O_HAVE_OPENGL
+  EdgeSwitchProxDrawAction::EdgeSwitchProxDrawAction()
+      : DrawAction(typeid(EdgeSwitchProx).name()), _triangleX(nullptr), _triangleY(nullptr), _triangleZ(nullptr) {}
+
+  bool EdgeSwitchProxDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_) {
+      if (!DrawAction::refreshPropertyPtrs(params_))
+          return false;
+      if (_previousParams) {
+          _triangleX = _previousParams->makeProperty<FloatProperty>(_typeName + "::N_Edge_Arrow_Length", .0f);
+          _triangleY = _previousParams->makeProperty<FloatProperty>(_typeName + "::N_Edge_Width", 3.0f);
+          _triangleZ = _previousParams->makeProperty<FloatProperty>(_typeName + "::P_Edge_Width", 2.0f);
+      }
+      else {
+          _triangleX = 0;
+          _triangleY = 0;
+          _triangleZ = 0;
+      }
+      return true;
+  }
+
+  HyperGraphElementAction* EdgeSwitchProxDrawAction::operator()(HyperGraph::HyperGraphElement* element,
+      HyperGraphElementAction::Parameters* params_) {
+      if (typeid(*element).name() != _typeName)
+          return nullptr;
+
+      refreshPropertyPtrs(params_);
+      if (!_previousParams)
+          return this;
+
+      if (_show && !_show->value())
+          return this;
+
+      EdgeSwitchProx* e = static_cast<EdgeSwitchProx*>(element);
+      VertexProx* from = static_cast<VertexProx*>(e->vertex(0));
+      VertexProx* to = static_cast<VertexProx*>(e->vertex(1));
+      if (!from && !to)
+          return this;
+      SE2 fromTransform;
+      SE2 toTransform;
+      glPushAttrib(GL_ENABLE_BIT | GL_LIGHTING | GL_COLOR);
+      glDisable(GL_LIGHTING);
+      /*
+      if (!from) {
+          glColor3f(POSE_EDGE_GHOST_COLOR);
+          toTransform = to->estimate();
+          fromTransform = to->estimate() * e->measurement().inverse();
+          // DRAW THE FROM EDGE AS AN ARROW
+          glPushMatrix();
+          glTranslatef((float)fromTransform.translation().x(), (float)fromTransform.translation().y(), 0.f);
+          glRotatef((float)RAD2DEG(fromTransform.rotation().angle()), 0.f, 0.f, 1.f);
+          opengl::drawArrow2D((float)_triangleX->value(), (float)_triangleY->value(), (float)_triangleX->value() * .3f);
+          glPopMatrix();
+      }
+      else if (!to) {
+          glColor3f(POSE_EDGE_GHOST_COLOR);
+          fromTransform = from->estimate();
+          toTransform = from->estimate() * e->measurement();
+          // DRAW THE TO EDGE AS AN ARROW
+          glPushMatrix();
+          glTranslatef(toTransform.translation().x(), toTransform.translation().y(), 0.f);
+          glRotatef((float)RAD2DEG(toTransform.rotation().angle()), 0.f, 0.f, 1.f);
+          opengl::drawArrow2D((float)_triangleX->value(), (float)_triangleY->value(), (float)_triangleX->value() * .3f);
+          glPopMatrix();
+      }
+      */
+      { //else {
+          glColor3f(POSE_EDGE_COLOR);
+          fromTransform = from->estimate();
+          toTransform = to->estimate();
+      }
+      //glGetFloatv(GL_LINE_WIDTH, &(float)_triangleY->value());
+      if (_triangleY->value() != 0) {
+          glLineWidth((float)_triangleY->value());
+          glBegin(GL_LINES);
+          glVertex3f((float)fromTransform.translation().x(), (float)fromTransform.translation().y(), 0.f);
+          glVertex3f((float)toTransform.translation().x(), (float)toTransform.translation().y(), 0.f);
+          glEnd();
+      }
+      //glGetFloatv(GL_LINE_WIDTH, &(float)_triangleZ->value());
+      if (_triangleZ->value() != 0) {
+          glLineWidth((float)_triangleZ->value());
+          glColor3f(LANDMARK_EDGE_COLOR);
+          glBegin(GL_LINES);
+          for (int i = 0; i < e->num_prox_pairs(); i++) {
+              glVertex3f((float)e->from_gr_prox(i).x(), (float)e->from_gr_prox(i).y(), 0.f);
+              glVertex3f((float)e->to_gr_prox(i).x(), (float)e->to_gr_prox(i).y(), 0.f);
+          }
+      }
+      glEnd();
+      glPopAttrib();
+      return this;
+  }
+#endif
+}
diff --git a/g2o/types/slam2d/parameter_em_prox.h b/g2o/types/slam2d/parameter_em_prox.h
new file mode 100644
index 00000000..b163089a
--- /dev/null
+++ b/g2o/types/slam2d/parameter_em_prox.h
@@ -0,0 +1,86 @@
+// This class was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#ifndef G2O_VERTEX_SE2_OFFSET_PARAMETERS_H_
+#define G2O_VERTEX_SE2_OFFSET_PARAMETERS_H_
+
+#include "g2o/core/cache.h"
+#include "g2o_types_slam2d_api.h"
+#include "se2.h"
+
+namespace g2o {
+
+class VertexSE2;
+
+/**
+    * \brief offset for an SE2
+    */
+class G2O_TYPES_SLAM2D_API ParameterSE2Offset : public Parameter {
+public:
+    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
+    ParameterSE2Offset();
+
+    virtual bool read(std::istream& is);
+    virtual bool write(std::ostream& os) const;
+
+    /**
+        * update the offset to a new value.
+        * re-calculates the different representations, e.g., the rotation matrix
+        */
+    void setOffset(const SE2& offset_ = SE2());
+
+    const SE2& offset() const { return _offset; }
+
+    //! rotation of the offset as 2x2 rotation matrix
+    const Isometry2& offsetMatrix() const { return _offsetMatrix; }
+
+    //! rotation of the inverse offset as 2x2 rotation matrix
+    const Isometry2& inverseOffsetMatrix() const { return _inverseOffsetMatrix; }
+
+protected:
+    SE2 _offset;
+    Isometry2 _offsetMatrix;
+    Isometry2 _inverseOffsetMatrix;
+};
+
+/**
+    * \brief caching the offset related to a vertex
+    */
+class G2O_TYPES_SLAM2D_API CacheSE2Offset : public Cache {
+public:
+    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
+    CacheSE2Offset();
+    virtual void updateImpl();
+
+    const ParameterSE2Offset* offsetParam() const { return _offsetParam; }
+    void setOffsetParam(ParameterSE2Offset* offsetParam);
+
+    const SE2& w2n() const { return _se2_w2n; }
+    const SE2& n2w() const { return _se2_n2w; }
+
+    const Isometry2& w2nMatrix() const { return _w2n; }
+    const Isometry2& n2wMatrix() const { return _n2w; }
+    const Isometry2& w2lMatrix() const { return _w2l; }
+
+    const Matrix2 RpInverseRInverseMatrix() const { return _RpInverse_RInverse; }
+    const Matrix2 RpInverseRInversePrimeMatrix() const {
+        return _RpInverse_RInversePrime;
+    }
+
+protected:
+    ParameterSE2Offset* _offsetParam;  ///< the parameter connected to the cache
+    SE2 _se2_w2n;
+    SE2 _se2_n2w;
+
+    Isometry2 _w2n;  ///< world to sensor transform
+    Isometry2 _w2l;  ///< world to local
+    Isometry2 _n2w;  ///< sensor to world
+    Matrix2 _RpInverse_RInverse;
+    Matrix2 _RpInverse_RInversePrime;
+
+protected:
+    virtual bool resolveDependencies();
+};
+
+}  // namespace g2o
+
+#endif
\ No newline at end of file
diff --git a/g2o/types/slam2d/parameter_prox.cpp b/g2o/types/slam2d/parameter_prox.cpp
new file mode 100644
index 00000000..fe2133a6
--- /dev/null
+++ b/g2o/types/slam2d/parameter_prox.cpp
@@ -0,0 +1,92 @@
+// This library was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#include "parameter_prox.h"
+#include <iostream>
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+
+ParameterProximity::ParameterProximity() { setProx(); }
+
+void ParameterProximity::setProx(const std::array<Vector2, prox_maxN>& prox_) {
+    _prox_points = prox_;
+    _num_prox_points = _prox_points.size();
+}
+
+bool ParameterProximity::read(std::istream& is) {
+  _num_prox_points = 0;
+  int n;
+  is >> n;
+  for (int i = 0; i < n && i < prox_maxN; i++) {
+      bool state = internal::readVector(is, _prox_points[i]);
+      if (state == false) return false;
+      _num_prox_points++;
+  }
+  return true;
+}
+
+bool ParameterProximity::write(std::ostream& os) const {
+    os << _num_prox_points << " ";
+    for (int i = 0; i < _num_prox_points && i < prox_maxN; i++) {
+        bool state = internal::writeVector(os, _prox_points[i]);
+        if (state == false) return false;
+    }
+    return true;
+}
+
+CacheProximity::CacheProximity() : Cache(), 
+    _loc_prox_points(), _abs_prox_points(), _num_prox_pairs(0){}
+
+bool CacheProximity::resolveDependencies() {
+    return true;
+}
+
+inline Vector2 CacheProximity::loc_prox(int i) const {
+    if (0 <= i && i < numPP() && i < prox_maxN)
+        return _loc_prox_points[i];
+    std::cerr << "out of range" << std::endl;
+    return Vector2();
+};
+inline Vector2 CacheProximity::abs_prox(int i) const {
+    if (0 <= i && i < numPP() && i < prox_maxN)
+        return _abs_prox_points[i];
+    std::cerr << "out of range" << std::endl;
+    return Vector2();
+};
+
+void CacheProximity::updateImpl() {
+  const VertexProx* v = static_cast<const VertexProx*>(vertex());
+  _abs_prox_points.fill(Vector2());
+  _diff_prox_points.fill(Vector2());
+  _abs_normal_vecs.fill(Vector2());
+  _diff_normal_vecs.fill(Vector2());
+  Eigen::Rotation2Dd dR = Eigen::Rotation2Dd(v->estimate().rotation().angle() + 0.5 * M_PI);
+  for (int i = 0; i < numPP() && i < prox_maxN; i++) {
+      if (_loc_prox_points[i] != Vector2()) {
+          _abs_prox_points[i] = v->estimate() * _loc_prox_points[i];
+          _diff_prox_points[i] = dR * _loc_prox_points[i];
+          _abs_normal_vecs[i] = v->estimate().rotation() * _loc_normal_vecs[i];
+          _diff_normal_vecs[i] = dR * _loc_normal_vecs[i];
+      }
+  }
+}
+
+bool CacheProximity::setLocalProx(const std::array<Vector2, prox_maxN>& loc_prox_points_) {
+    _loc_prox_points.fill(Vector2());
+    _loc_normal_vecs.fill(Vector2());
+    for (int i = 0; i < prox_maxN; i++) {
+        if (loc_prox_points_[i] == Vector2()) {
+            _num_prox_pairs = i;
+        }
+        _loc_prox_points[i] = loc_prox_points_[i];
+        _loc_normal_vecs[i] = loc_prox_points_[i] / loc_prox_points_[i].norm();;
+    }
+    updateImpl();
+    return true;
+}
+
+}
diff --git a/g2o/types/slam2d/parameter_prox.h b/g2o/types/slam2d/parameter_prox.h
new file mode 100644
index 00000000..846b5936
--- /dev/null
+++ b/g2o/types/slam2d/parameter_prox.h
@@ -0,0 +1,67 @@
+// This library was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#ifndef G2O_PARAMETER_PROXIMITY_H_
+#define G2O_PARAMETER_PROXIMITY_H_
+
+#include <cmath>
+#include <vector>
+
+#include "g2o/core/cache.h"
+#include "g2o_types_slam2d_api.h"
+#include "vertex_prox.h"
+
+#ifndef prox_maxN
+#define prox_maxN 10
+#endif
+
+namespace g2o {
+
+class G2O_TYPES_SLAM2D_API ParameterProximity : public Parameter {
+public:
+    EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
+    ParameterProximity();
+
+    virtual bool read(std::istream& is);
+    virtual bool write(std::ostream& os) const;
+
+    void setProx(const std::array<Vector2, prox_maxN>& prox_ = std::array<Vector2, prox_maxN>());
+    inline const std::array<Vector2, prox_maxN>& prox_points() const { return _prox_points; }
+    inline const int& numProx() const { return _num_prox_points; }
+
+protected:
+    std::array<Vector2, prox_maxN> _prox_points;
+    int _num_prox_points;
+};
+
+class G2O_TYPES_SLAM2D_API CacheProximity : public Cache {
+ public:
+  EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
+  CacheProximity();
+  virtual void updateImpl();
+
+  virtual inline Vector2 loc_prox(int i) const;
+  virtual inline Vector2 abs_prox(int i) const;
+  inline const int& numPP() const { return _num_prox_pairs; }
+  inline const Vector2& r(int i) const { return _loc_prox_points[i]; }
+  inline const Vector2& u(int i) const { return _loc_normal_vecs[i]; }
+  inline const Vector2& q(int i) const { return _abs_prox_points[i]; }
+  inline const Vector2& e(int i) const { return _abs_normal_vecs[i]; }
+  inline const Vector2& dq(int i) const { return _diff_prox_points[i]; }
+  inline const Vector2& de(int i) const { return _diff_normal_vecs[i]; }
+  bool setLocalProx(const std::array<Vector2, prox_maxN> & loc_prox_points_);
+
+ protected:
+     std::array<Vector2, prox_maxN> _loc_prox_points;
+     std::array<Vector2, prox_maxN> _abs_prox_points;
+     std::array<Vector2, prox_maxN> _diff_prox_points;
+     std::array<Vector2, prox_maxN> _loc_normal_vecs;
+     std::array<Vector2, prox_maxN> _abs_normal_vecs;
+     std::array<Vector2, prox_maxN> _diff_normal_vecs;
+     int _num_prox_pairs;
+
+ protected:
+  virtual bool resolveDependencies();
+};
+
+}
+#endif
diff --git a/g2o/types/slam2d/parameter_switch_weight.cpp b/g2o/types/slam2d/parameter_switch_weight.cpp
new file mode 100644
index 00000000..c8a8fb3d
--- /dev/null
+++ b/g2o/types/slam2d/parameter_switch_weight.cpp
@@ -0,0 +1,53 @@
+// g2o - General Graph Optimization
+// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright
+//   notice, this list of conditions and the following disclaimer in the
+//   documentation and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "parameter_switch_weight.h"
+
+#include "g2o/core/io_helper.h"
+#include "vertex_se2.h"
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#endif
+
+namespace g2o {
+
+	ParameterSwitchWeight::ParameterSwitchWeight() { setInfo();}
+
+bool ParameterSwitchWeight::read(std::istream& is) {
+	number_t i;
+	is >> i;
+  if (is.bad()) return false;
+  setInfo(i);
+  return true;
+}
+
+bool ParameterSwitchWeight::write(std::ostream& os) const {
+	os << Info();
+	return true;
+}
+
+}  // namespace g2o
diff --git a/g2o/types/slam2d/parameter_switch_weight.h b/g2o/types/slam2d/parameter_switch_weight.h
new file mode 100644
index 00000000..08842e53
--- /dev/null
+++ b/g2o/types/slam2d/parameter_switch_weight.h
@@ -0,0 +1,59 @@
+// g2o - General Graph Optimization
+// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright
+//   notice, this list of conditions and the following disclaimer in the
+//   documentation and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef G2O_SWITCHING_WEIGHT_H_
+#define G2O_SWITCHING_WEIGHT_H_
+
+
+#include "g2o_types_slam2d_api.h"
+#include "g2o/core/cache.h"
+
+
+namespace g2o {
+
+  /**
+   * \brief offset for an SE2
+   */
+  class G2O_TYPES_SLAM2D_API ParameterSwitchWeight : public Parameter
+  {
+    public:
+      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
+      ParameterSwitchWeight();
+
+      virtual bool read(std::istream& is);
+      virtual bool write(std::ostream& os) const;
+
+      inline void setInfo(const number_t info = 0.) { _info = info; };
+
+      inline number_t Info() const { return _info; };
+
+    protected:
+      number_t _info;
+  };
+
+}
+
+#endif
diff --git a/g2o/types/slam2d/se2.h b/g2o/types/slam2d/se2.h
index 41a1280f..1f5e205c 100644
--- a/g2o/types/slam2d/se2.h
+++ b/g2o/types/slam2d/se2.h
@@ -36,60 +36,62 @@
 
 namespace g2o {
 
-/**
- * \brief represent SE2
- */
-class G2O_TYPES_SLAM2D_API SE2 {
- public:
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
-  SE2() : _R(0), _t(0, 0) {}
-
-  SE2(const Isometry2& iso) : _R(0), _t(iso.translation()) {
-    _R.fromRotationMatrix(iso.linear());
-  }
-
-  SE2(const Vector3& v) : _R(v[2]), _t(v[0], v[1]) {}
-
-  SE2(number_t x, number_t y, number_t theta) : _R(theta), _t(x, y) {}
-
-  //! translational component
-  inline const Vector2& translation() const { return _t; }
-  void setTranslation(const Vector2& t_) { _t = t_; }
-
-  //! rotational component
-  inline const Rotation2D& rotation() const { return _R; }
-  void setRotation(const Rotation2D& R_) { _R = R_; }
-
-  //! concatenate two SE2 elements (motion composition)
-  inline SE2 operator*(const SE2& tr2) const {
-    SE2 result(*this);
-    result *= tr2;
-    return result;
-  }
-
-  //! motion composition operator
-  inline SE2& operator*=(const SE2& tr2) {
-    _t += _R * tr2._t;
-    _R.angle() += tr2._R.angle();
-    _R.angle() = normalize_theta(_R.angle());
-    return *this;
-  }
-
-  //! project a 2D vector
-  inline Vector2 operator*(const Vector2& v) const { return _t + _R * v; }
-
-  //! invert :-)
-  inline SE2 inverse() const {
-    SE2 ret;
-    ret._R = _R.inverse();
-    ret._R.angle() = normalize_theta(ret._R.angle());
+  /**
+   * \brief represent SE2
+   */
+  class G2O_TYPES_SLAM2D_API SE2 {
+    public:
+      EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
+      SE2():_R(0),_t(0,0){}
+
+      SE2(const Isometry2& iso): _R(0), _t(iso.translation()){
+        _R.fromRotationMatrix(iso.linear());
+      }
+
+      SE2(const Vector3& v):_R(v[2]),_t(v[0],v[1]){}
+
+      SE2(number_t x, number_t y, number_t theta):_R(theta),_t(x,y){}
+
+      //! translational component
+      inline const Vector2& translation() const {return _t;}
+      void setTranslation(const Vector2& t_) {_t=t_;}
+
+      //! rotational component
+      inline const Rotation2D& rotation() const {return _R;}
+      void setRotation(const Rotation2D& R_) {_R=R_;}
+
+      //! concatenate two SE2 elements (motion composition)
+      inline SE2 operator * (const SE2& tr2) const{
+        SE2 result(*this);
+        result *= tr2;
+        return result;
+      }
+
+      //! motion composition operator
+      inline SE2& operator *= (const SE2& tr2){
+        _t+=_R*tr2._t;
+        _R.angle()+=tr2._R.angle();
+        _R.angle()=normalize_theta(_R.angle());
+        return *this;
+      }
+
+      //! project a 2D vector
+      inline Vector2 operator * (const Vector2& v) const {
+        return _t+_R*v;
+      }
+
+      //! invert :-)
+      inline SE2 inverse() const{
+        SE2 ret;
+        ret._R=_R.inverse();
+        ret._R.angle()=normalize_theta(ret._R.angle());
 #ifdef _MSC_VER
-    ret._t = ret._R * (Vector2(_t * -1.));
+        ret._t=ret._R*(Vector2(_t*-1.));
 #else
-    ret._t = ret._R * (_t * -1.);
+        ret._t=ret._R*(_t*-1.);
 #endif
-    return ret;
-  }
+        return ret;
+      }
 
   inline number_t operator[](int i) const {
     assert(i >= 0 && i < 3);
diff --git a/g2o/types/slam2d/types_slam2d.cpp b/g2o/types/slam2d/types_slam2d.cpp
index 532f5bd4..aad99fae 100644
--- a/g2o/types/slam2d/types_slam2d.cpp
+++ b/g2o/types/slam2d/types_slam2d.cpp
@@ -37,7 +37,11 @@ G2O_REGISTER_TYPE_GROUP(slam2d);
 
 G2O_REGISTER_TYPE(VERTEX_SE2, VertexSE2);
 G2O_REGISTER_TYPE(VERTEX_XY, VertexPointXY);
+G2O_REGISTER_TYPE(VERTEX_PROX, VertexProx);                       //added by wada
+G2O_REGISTER_TYPE(VERTEX_SWITCH, VertexSwitch);                   //added by wada
+G2O_REGISTER_TYPE(VERTEX_SWITCH_PROX_PAIR, VertexSwitchProxPair); //added by wada
 G2O_REGISTER_TYPE(PARAMS_SE2OFFSET, ParameterSE2Offset);
+G2O_REGISTER_TYPE(PARAMS_SWITCH_WEIGHT, ParameterSwitchWeight);   //added by wada
 G2O_REGISTER_TYPE(CACHE_SE2_OFFSET, CacheSE2Offset);
 G2O_REGISTER_TYPE(EDGE_PRIOR_SE2, EdgeSE2Prior);
 G2O_REGISTER_TYPE(EDGE_PRIOR_SE2_XY, EdgeSE2XYPrior);
@@ -51,9 +55,13 @@ G2O_REGISTER_TYPE(EDGE_POINTXY, EdgePointXY);
 G2O_REGISTER_TYPE(EDGE_SE2_TWOPOINTSXY, EdgeSE2TwoPointsXY);
 G2O_REGISTER_TYPE(EDGE_SE2_LOTSOFXY, EdgeSE2LotsOfXY);
 G2O_REGISTER_TYPE(EDGE_PRIOR_XY, EdgeXYPrior);
+G2O_REGISTER_TYPE(EDGE_PROX, EdgeProx); //added by wada
+G2O_REGISTER_TYPE(EDGE_SWITCH_SE2, EdgeSwitchSE2);                //added by wada
+G2O_REGISTER_TYPE(EDGE_SWITCH_PROX, EdgeSwitchProx);              //added by wada
 
 G2O_REGISTER_ACTION(VertexSE2WriteGnuplotAction);
 G2O_REGISTER_ACTION(VertexPointXYWriteGnuplotAction);
+G2O_REGISTER_ACTION(VertexProxWriteGnuplotAction);                //added by wada
 G2O_REGISTER_ACTION(EdgeSE2WriteGnuplotAction);
 G2O_REGISTER_ACTION(EdgeSE2PointXYWriteGnuplotAction);
 G2O_REGISTER_ACTION(EdgeSE2PointXYBearingWriteGnuplotAction);
@@ -61,9 +69,12 @@ G2O_REGISTER_ACTION(EdgeSE2PointXYBearingWriteGnuplotAction);
 #ifdef G2O_HAVE_OPENGL
 G2O_REGISTER_ACTION(VertexSE2DrawAction);
 G2O_REGISTER_ACTION(VertexPointXYDrawAction);
+G2O_REGISTER_ACTION(VertexProxDrawAction);                        //added by wada
 G2O_REGISTER_ACTION(EdgeSE2DrawAction);
 G2O_REGISTER_ACTION(EdgeSE2PointXYDrawAction);
 G2O_REGISTER_ACTION(EdgeSE2PointXYBearingDrawAction);
+G2O_REGISTER_ACTION(EdgeProxDrawAction);                          //added by wada
+G2O_REGISTER_ACTION(EdgeSwitchProxDrawAction);                    //added by wada
 
 #endif
 }  // namespace g2o
diff --git a/g2o/types/slam2d/types_slam2d.h b/g2o/types/slam2d/types_slam2d.h
index 385f1cee..eb8dd88f 100644
--- a/g2o/types/slam2d/types_slam2d.h
+++ b/g2o/types/slam2d/types_slam2d.h
@@ -39,9 +39,15 @@
 #include "edge_se2_twopointsxy.h"
 #include "edge_se2_xyprior.h"
 #include "edge_xy_prior.h"
+#include "edge_prox.h"        //added by wada
+#include "edge_switch_prox.h" //added by wada
+#include "edge_switch_se2.h"  //added by wada
 #include "g2o/config.h"
 #include "parameter_se2_offset.h"
 #include "vertex_point_xy.h"
 #include "vertex_se2.h"
+#include "vertex_prox.h"      //added by wada
+#include "vertex_switch_pp.h" //added by wada
+#include "vertex_switch.h"    //added by wada
 
 #endif
diff --git a/g2o/types/slam2d/vertex_prox.cpp b/g2o/types/slam2d/vertex_prox.cpp
new file mode 100644
index 00000000..8d9820f2
--- /dev/null
+++ b/g2o/types/slam2d/vertex_prox.cpp
@@ -0,0 +1,160 @@
+// This library was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#include <string>
+#include "vertex_prox.h"
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+
+  VertexProx::VertexProx() :
+    BaseVertex<3, SE2>(), _num_prox(0){}
+
+  void VertexProx::oplusImpl(const number_t* update)
+  {
+    //Vector2 t = _estimate.translation();
+    //t += Eigen::Map<const Vector2>(update);
+    //number_t angle = normalize_theta(_estimate.rotation().angle() + update[2]);
+    //_estimate.setTranslation(t);
+    //_estimate.setRotation(Rotation2D(angle));
+    SE2 t = _estimate, dt = SE2();
+    dt.setTranslation(Vector2(update[0], update[1]));
+    dt.setRotation(Rotation2D(normalize_theta(update[2])));
+    _estimate = t * dt;
+  }
+
+  bool VertexProx::read(std::istream& is)
+  {
+    Vector3 p;
+    bool state_p = internal::readVector(is, p);
+    setEstimate(p);
+    _num_prox = 0;
+    int n;
+    is >> n;
+    for (int i = 0; i < n && i < prox_maxN; i++) {
+        bool state_r = internal::readVector(is, *_proximityParam[i]);
+        if (state_r == false) return false;
+        _num_prox = i + 1;
+    }
+    _num_prox = n;
+    return state_p;
+  }
+
+  bool VertexProx::write(std::ostream& os) const
+  {
+    bool state_p = internal::writeVector(os, estimate().toVector());
+    os << _num_prox << " ";
+    for (int i = 0; i < _num_prox && i < prox_maxN; i++) {
+        bool state_r = internal::writeVector(os, *_proximityParam[i]);
+        if (state_r == false) return false;
+    }
+    return state_p;
+  }
+
+  VertexProxWriteGnuplotAction::VertexProxWriteGnuplotAction(): WriteGnuplotAction(typeid(VertexProx).name()){}
+
+  HyperGraphElementAction* VertexProxWriteGnuplotAction::operator()(HyperGraph::HyperGraphElement* element, HyperGraphElementAction::Parameters* params_){
+    if (typeid(*element).name()!=_typeName)
+      return nullptr;
+    WriteGnuplotAction::Parameters* params= dynamic_cast<WriteGnuplotAction::Parameters*>(params_);
+    if (!params || !params->os){
+      std::cerr << __PRETTY_FUNCTION__ << ": warning, no valid output stream specified" << std::endl;
+      return nullptr;
+    }
+
+    VertexProx* v = dynamic_cast<VertexProx*>(element);
+    *(params->os) << v->estimate().translation().x() << " " << v->estimate().translation().y()
+      << " " << v->estimate().rotation().angle() << std::endl;
+    return this;
+  }
+
+#ifdef G2O_HAVE_OPENGL
+  VertexProxDrawAction::VertexProxDrawAction()
+      : DrawAction(typeid(VertexProx).name()), _drawActions(nullptr), _arrow_length(nullptr), _arrow_width(nullptr),
+      _point_size(nullptr), _line_width(nullptr) {}
+
+  bool VertexProxDrawAction::refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_){
+    if (!DrawAction::refreshPropertyPtrs(params_))
+      return false;
+    if (_previousParams){
+        _arrow_length = _previousParams->makeProperty<FloatProperty>(_typeName + "::N_Vertex_Arrow_Length", .5f);
+        _arrow_width = _previousParams->makeProperty<FloatProperty>(_typeName + "::N_Vertex_Arrow_Width", .3f);
+        _point_size = _previousParams->makeProperty<FloatProperty>(_typeName + "::P_Vertex_Size", 5.0f);
+        _line_width = _previousParams->makeProperty<FloatProperty>(_typeName + "::PN_line_width", .0f);
+    } else {
+        _arrow_length = 0;
+        _arrow_width = 0;
+        _point_size = 0;
+        _line_width = 0;
+    }
+    return true;
+  }
+
+
+  HyperGraphElementAction* VertexProxDrawAction::operator()(HyperGraph::HyperGraphElement* element,
+                 HyperGraphElementAction::Parameters* params_){
+   if (typeid(*element).name()!=_typeName)
+      return nullptr;
+    //initializeDrawActionsCache();
+    refreshPropertyPtrs(params_);
+
+    if (! _previousParams)
+      return this;
+
+    if (_show && !_show->value())
+      return this;
+
+    VertexProx* that = static_cast<VertexProx*>(element);
+
+    glPushAttrib(GL_ENABLE_BIT | GL_LIGHTING | GL_COLOR);
+    glDisable(GL_LIGHTING);
+    glColor3f(POSE_VERTEX_COLOR);
+    glPushMatrix();
+    glTranslatef((float)that->estimate().translation().x(),(float)that->estimate().translation().y(),0.f);
+    glRotatef((float)RAD2DEG(that->estimate().rotation().angle()),0.f,0.f,1.f);
+    opengl::drawArrow2D((float)_arrow_length->value(), (float)_arrow_width->value(), (float)_arrow_width->value()*.5f);
+    //drawCache(that->cacheContainer(), params_);
+    //drawUserData(that->userData(), params_);
+    glPopMatrix();
+    glColor3f(LANDMARK_VERTEX_COLOR);
+    for (int i = 0; i < that->num_prox() && i < prox_maxN; i++) {
+        if ((float)_point_size->value() != 0) {
+            //glColor3f(POSE_VERTEX_COLOR);
+            glPushMatrix();
+            glTranslatef((float)(that->estimate() * that->proximity(i)).x(), (float)(that->estimate() * that->proximity(i)).y(), 0.f);
+            glRotatef((float)RAD2DEG(that->estimate().rotation().angle()), 0.f, 0.f, 1.f);
+            opengl::drawPoint((float)_point_size->value());
+            //drawCache(that->cacheContainer(), params_);
+            //drawUserData(that->userData(), params_);
+            glPopMatrix();
+            glColor3f(LANDMARK_VERTEX_COLOR);
+        }
+        if ((float)_line_width->value() != 0) {
+            glColor3f(POSE_VERTEX_COLOR);
+            glPushMatrix();
+            glTranslatef((float)that->estimate().translation().x(), (float)that->estimate().translation().y(), 0.f);
+            glRotatef((float)RAD2DEG(that->estimate().rotation().angle() + atan2(that->proximity(i).y(), that->proximity(i).x())), 0.f, 0.f, 1.f);
+            opengl::drawLine((float)that->proximity(i).norm(), (float)_line_width->value());
+            //drawCache(that->cacheContainer(), params_);
+            //drawUserData(that->userData(), params_);
+            glPopMatrix();
+            glColor3f(LANDMARK_VERTEX_COLOR);
+            //glLineWidth((float)_line_width->value());
+            //glBegin(GL_LINES);
+            //glVertex3f((float)that->estimate().translation().x(), (float)that->estimate().translation().y(), 0.f);
+            //glVertex3f((float)(that->estimate() * that->proximity(i)).x(), (float)(that->estimate() * that->proximity(i)).y(), 0.f);
+            //glEnd();
+        }
+    }
+    //drawCache(that->cacheContainer(), params_);
+    //drawUserData(that->userData(), params_);
+    glPopAttrib();
+    return this;
+  }
+#endif
+
+
+} // end namespace
diff --git a/g2o/types/slam2d/vertex_prox.h b/g2o/types/slam2d/vertex_prox.h
new file mode 100644
index 00000000..3a63a821
--- /dev/null
+++ b/g2o/types/slam2d/vertex_prox.h
@@ -0,0 +1,100 @@
+// This library was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#ifndef G2O_VERTEX_SE2_PROXIMITY_H
+#define G2O_VERTEX_SE2_PROXIMITY_H
+
+#include "g2o/core/base_binary_edge.h"
+
+#include "g2o/config.h"
+#include "g2o/core/base_vertex.h"
+#include "g2o/core/hyper_graph_action.h"
+#include "se2.h"
+#include "g2o_types_slam2d_api.h"
+
+#ifndef prox_maxN
+#define prox_maxN 10
+#endif
+
+namespace g2o {
+
+  /**
+   * \brief 2D pose Vertex, (x,y,theta)
+   */
+  class ParameterPointXYProximity;
+  class CachePointXYProximity;
+
+  class G2O_TYPES_SLAM2D_API VertexProx : public BaseVertex<3, SE2>
+  {
+    public:
+      EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+          VertexProx();
+
+      virtual void setToOriginImpl() {
+        _estimate = SE2();
+      }
+
+      virtual void oplusImpl(const number_t* update);
+
+      virtual bool setEstimateDataImpl(const number_t* est){
+        _estimate=SE2(est[0], est[1], est[2]);
+        return true;
+      }
+
+      virtual bool getEstimateData(number_t* est) const {
+        Eigen::Map<Vector3> v(est);
+        v = _estimate.toVector();
+        return true;
+      }
+      
+      virtual int estimateDimension() const { return 3; }
+
+      virtual bool setMinimalEstimateDataImpl(const number_t* est){
+        return setEstimateData(est);
+      }
+
+      virtual bool getMinimalEstimateData(number_t* est) const {
+        return getEstimateData(est);
+      }
+      
+      virtual int minimalEstimateDimension() const { return 3; }
+
+      virtual bool read(std::istream& is);
+      virtual bool write(std::ostream& os) const;
+
+      virtual inline Vector2 proximity(int i) const {
+          if(0 <= i && i < _num_prox)
+            return *_proximityParam[i];
+          std::cerr << "out of range" << std::endl;
+          return Vector2();
+      };
+      virtual inline int num_prox() const { return _num_prox; };
+
+  private:
+      std::array<Vector2*, prox_maxN> _proximityParam;
+      int _num_prox;
+  };
+
+  class G2O_TYPES_SLAM2D_API VertexProxWriteGnuplotAction: public WriteGnuplotAction {
+  public:
+      VertexProxWriteGnuplotAction();
+    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element, 
+            HyperGraphElementAction::Parameters* params_ );
+  };
+
+#ifdef G2O_HAVE_OPENGL
+  class G2O_TYPES_SLAM2D_API VertexProxDrawAction: public DrawAction{
+  public:
+    VertexProxDrawAction();
+    virtual HyperGraphElementAction* operator()(HyperGraph::HyperGraphElement* element, 
+            HyperGraphElementAction::Parameters* params_ );
+  protected:
+    HyperGraphElementAction* _drawActions;
+    virtual bool refreshPropertyPtrs(HyperGraphElementAction::Parameters* params_);
+    FloatProperty* _arrow_length, * _arrow_width, * _point_size, * _line_width;
+
+  };
+#endif
+
+} // end namespace
+
+#endif
diff --git a/g2o/types/slam2d/vertex_se2.h b/g2o/types/slam2d/vertex_se2.h
index e9fc88fc..91168c66 100644
--- a/g2o/types/slam2d/vertex_se2.h
+++ b/g2o/types/slam2d/vertex_se2.h
@@ -46,11 +46,10 @@ class G2O_TYPES_SLAM2D_API VertexSE2 : public BaseVertex<3, SE2> {
   virtual void setToOriginImpl() { _estimate = SE2(); }
 
   virtual void oplusImpl(const number_t* update) {
-    Vector2 t = _estimate.translation();
-    t += Eigen::Map<const Vector2>(update);
-    number_t angle = normalize_theta(_estimate.rotation().angle() + update[2]);
-    _estimate.setTranslation(t);
-    _estimate.setRotation(Rotation2D(angle));
+    SE2 t = _estimate, dt = SE2();
+    dt.setTranslation(Vector2(update[0], update[1]));
+    dt.setRotation(Rotation2D(normalize_theta(update[2])));
+    _estimate = t * dt;
   }
 
   virtual bool setEstimateDataImpl(const number_t* est) {
diff --git a/g2o/types/slam2d/vertex_switch.cpp b/g2o/types/slam2d/vertex_switch.cpp
new file mode 100644
index 00000000..4d2888d6
--- /dev/null
+++ b/g2o/types/slam2d/vertex_switch.cpp
@@ -0,0 +1,33 @@
+// This class was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#include <string>
+#include "vertex_switch.h"
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+
+    VertexSwitch::VertexSwitch() :
+        BaseVertex<1, number_t>() { 
+        setToOriginImpl();
+    }
+  void VertexSwitch::oplusImpl(const number_t* update) {
+      _estimate += update[0];
+  }
+
+  bool VertexSwitch::read(std::istream& is) {
+      setToOriginImpl();
+    if (is.bad()) return true;
+    is >> _estimate;
+    return true;
+  }
+
+  bool VertexSwitch::write(std::ostream& os) const {
+    os << _estimate << " ";
+    return true;
+  }
+
+} // end namespace
diff --git a/g2o/types/slam2d/vertex_switch.h b/g2o/types/slam2d/vertex_switch.h
new file mode 100644
index 00000000..bda3e668
--- /dev/null
+++ b/g2o/types/slam2d/vertex_switch.h
@@ -0,0 +1,60 @@
+// This class was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#ifndef G2O_SWITCHING_H
+#define G2O_SWITCHING_H
+
+#include "g2o/core/base_ternary_edge.h"
+#include "parameter_switch_weight.h"
+
+#include "g2o/config.h"
+#include "g2o/core/base_vertex.h"
+#include "g2o/core/hyper_graph_action.h"
+#include "g2o_types_slam2d_api.h"
+
+namespace g2o {
+
+    class G2O_TYPES_SLAM2D_API VertexSwitch : public BaseVertex<1, number_t>
+    {
+    public:
+        EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+            VertexSwitch();
+
+        virtual void setToOriginImpl() {
+            //for (int i = 0; i < prox_maxN; i++)
+            //    _estimate[i] = 1.;
+            _estimate = 1.;
+        }
+
+        virtual void oplusImpl(const number_t* update);
+
+        virtual bool setEstimateDataImpl(const number_t* est) {
+            _estimate = est[0];
+            return true;
+        }
+
+        virtual bool getEstimateData(number_t* est) const {
+            est[0] = _estimate;
+            return true;
+        }
+
+        virtual int estimateDimension() const { return 1; }
+
+        virtual bool setMinimalEstimateDataImpl(const number_t* est) {
+            return setEstimateData(est);
+        }
+
+        virtual bool getMinimalEstimateData(number_t* est) const {
+            return getEstimateData(est);
+        }
+
+        virtual int minimalEstimateDimension() const { return 1; }
+
+        virtual bool read(std::istream& is);
+        virtual bool write(std::ostream& os) const;
+
+    private:
+    };
+
+} // end namespace
+
+#endif
diff --git a/g2o/types/slam2d/vertex_switch_pp.cpp b/g2o/types/slam2d/vertex_switch_pp.cpp
new file mode 100644
index 00000000..def5157e
--- /dev/null
+++ b/g2o/types/slam2d/vertex_switch_pp.cpp
@@ -0,0 +1,54 @@
+// This class was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#include <string>
+#include "vertex_switch_pp.h"
+
+#ifdef G2O_HAVE_OPENGL
+#include "g2o/stuff/opengl_wrapper.h"
+#include "g2o/stuff/opengl_primitives.h"
+#endif
+
+namespace g2o {
+
+    VertexSwitchProxPair::VertexSwitchProxPair() :
+        BaseVertex<prox_maxN, std::array<number_t, prox_maxN>>(), _num_prox_pairs(0) { 
+        setToOriginImpl();
+    }
+  void VertexSwitchProxPair::oplusImpl(const number_t* update) {
+      for (int i = 0; i < _num_prox_pairs; i++) {
+          _estimate[i] += update[i];
+          //_estimate[i] += update[i];
+          //if(_estimate[i] + update[i] < 0.5)
+          //    _estimate[i] = 0.;
+          //else
+          //    _estimate[i] = 1.;
+          //_estimate[i] = std::max(std::min(_estimate[i], cst(30.)), cst(-4.5));
+          //_estimate[i] = std::min(std::max(_estimate[i] + update[i], 1.), 1.e-2);
+          //_estimate[i] = (_estimate[i] + update[i]) / (1. + _estimate[i] + update[i]);
+      }
+    for (int i = _num_prox_pairs; i < prox_maxN; i++)
+        _estimate[i] = 1.;
+  }
+
+  bool VertexSwitchProxPair::read(std::istream& is) {
+    if (is.bad()) return false;
+    std::array<number_t, prox_maxN> p;
+    int n;
+    is >> n;
+    setToOriginImpl();
+    _num_prox_pairs = std::min(n, prox_maxN);
+    for (int i = 0; i < _num_prox_pairs; i++) {
+        if (is.bad()) return true;
+        is >> _estimate[i];
+    }
+    return true;
+  }
+
+  bool VertexSwitchProxPair::write(std::ostream& os) const {
+    os << _num_prox_pairs << " ";
+    for (int i = 0; i < _num_prox_pairs && i < prox_maxN; i++)
+      os << _estimate[i] << " " ;
+    return true;
+  }
+
+} // end namespace
diff --git a/g2o/types/slam2d/vertex_switch_pp.h b/g2o/types/slam2d/vertex_switch_pp.h
new file mode 100644
index 00000000..b4bec56c
--- /dev/null
+++ b/g2o/types/slam2d/vertex_switch_pp.h
@@ -0,0 +1,67 @@
+// This class was made by Kotaro Wada. (211t373t[at]stu.kobe-u.ac.jp)
+
+#ifndef G2O_SWITCHING_PROX_PAIR_H
+#define G2O_SWITCHING_PROX_PAIR_H
+
+#include "g2o/core/base_ternary_edge.h"
+#include "parameter_switch_weight.h"
+
+#include "g2o/config.h"
+#include "g2o/core/base_vertex.h"
+#include "g2o/core/hyper_graph_action.h"
+#include "g2o_types_slam2d_api.h"
+
+#ifndef prox_maxN
+#define prox_maxN 10
+#endif
+
+namespace g2o {
+
+    class G2O_TYPES_SLAM2D_API VertexSwitchProxPair : public BaseVertex<prox_maxN, std::array<number_t, prox_maxN>>
+    {
+    public:
+        EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+            VertexSwitchProxPair();
+
+        virtual void setToOriginImpl() {
+            //for (int i = 0; i < prox_maxN; i++)
+            //    _estimate[i] = 1.;
+            _estimate.fill(1.);
+        }
+
+        virtual void oplusImpl(const number_t* update);
+
+        virtual bool setEstimateDataImpl(const number_t* est) {
+            for (int i = 0; i < prox_maxN; i++)
+                _estimate[i] = est[i];
+            return true;
+        }
+
+        virtual bool getEstimateData(number_t* est) const {
+            for (int i = 0; i < prox_maxN; i++)
+                est[i] = _estimate[i];
+            return true;
+        }
+
+        virtual int estimateDimension() const { return prox_maxN; }
+
+        virtual bool setMinimalEstimateDataImpl(const number_t* est) {
+            return setEstimateData(est);
+        }
+
+        virtual bool getMinimalEstimateData(number_t* est) const {
+            return getEstimateData(est);
+        }
+
+        virtual int minimalEstimateDimension() const { return prox_maxN; }
+
+        virtual bool read(std::istream& is);
+        virtual bool write(std::ostream& os) const;
+
+    private:
+        int _num_prox_pairs;
+    };
+
+} // end namespace
+
+#endif
-- 
2.33.1.windows.1

